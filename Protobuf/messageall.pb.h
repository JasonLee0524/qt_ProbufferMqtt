// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messageall.proto

#ifndef PROTOBUF_messageall_2eproto__INCLUDED
#define PROTOBUF_messageall_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messageall_2eproto();
void protobuf_AssignDesc_messageall_2eproto();
void protobuf_ShutdownFile_messageall_2eproto();

class Message;
class Message_ParamType;
class ACPowerCharger;
class ACPowerCharger_BasicInfo;
class ACPowerCharger_RealtimeInfo;
class ACPowerCharger_ServiceInfo;
class CommonBasicInfo;
class ServiceStateInfo;
class ConnectivityState;
class ChargingConnector;
class Alarm;
class LocalConfiguration;
class LocalConfigurationInfo;
class RemoteOperation;
class RemoteConfiguration;
class RemoteConfigurationInfo;
class RemoteControl;
class RemoteControlParam;
class RemoteUpgrade;
class RemoteOperationResponse;
class RemoteConfigurationResponse;
class RemoteControlResponse;
class RemoteUpgradeResponse;

enum Message_MessageType {
  Message_MessageType_NOTIFICATION = 0,
  Message_MessageType_CONTROL_COMMAND = 1,
  Message_MessageType_COMMAND_RESULT = 2,
  Message_MessageType_DATA_REPORT = 3,
  Message_MessageType_CLIENT_STATUS = 4
};
bool Message_MessageType_IsValid(int value);
const Message_MessageType Message_MessageType_MessageType_MIN = Message_MessageType_NOTIFICATION;
const Message_MessageType Message_MessageType_MessageType_MAX = Message_MessageType_CLIENT_STATUS;
const int Message_MessageType_MessageType_ARRAYSIZE = Message_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_MessageType_descriptor();
inline const ::std::string& Message_MessageType_Name(Message_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_MessageType_descriptor(), value);
}
inline bool Message_MessageType_Parse(
    const ::std::string& name, Message_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_MessageType>(
    Message_MessageType_descriptor(), name, value);
}
enum ACPowerCharger_DeviceWorkState {
  ACPowerCharger_DeviceWorkState_DWS_FREE = 0,
  ACPowerCharger_DeviceWorkState_DWS_IN_CHARGING = 1
};
bool ACPowerCharger_DeviceWorkState_IsValid(int value);
const ACPowerCharger_DeviceWorkState ACPowerCharger_DeviceWorkState_DeviceWorkState_MIN = ACPowerCharger_DeviceWorkState_DWS_FREE;
const ACPowerCharger_DeviceWorkState ACPowerCharger_DeviceWorkState_DeviceWorkState_MAX = ACPowerCharger_DeviceWorkState_DWS_IN_CHARGING;
const int ACPowerCharger_DeviceWorkState_DeviceWorkState_ARRAYSIZE = ACPowerCharger_DeviceWorkState_DeviceWorkState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACPowerCharger_DeviceWorkState_descriptor();
inline const ::std::string& ACPowerCharger_DeviceWorkState_Name(ACPowerCharger_DeviceWorkState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACPowerCharger_DeviceWorkState_descriptor(), value);
}
inline bool ACPowerCharger_DeviceWorkState_Parse(
    const ::std::string& name, ACPowerCharger_DeviceWorkState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACPowerCharger_DeviceWorkState>(
    ACPowerCharger_DeviceWorkState_descriptor(), name, value);
}
enum ACPowerCharger_PowerChargerType {
  ACPowerCharger_PowerChargerType_PCT_AC_ONLY = 0,
  ACPowerCharger_PowerChargerType_PCT_DC_ONLY = 1,
  ACPowerCharger_PowerChargerType_PCT_AC_DC_HYBRID = 2,
  ACPowerCharger_PowerChargerType_PCT_OTHER = 254,
  ACPowerCharger_PowerChargerType_PCT_UNKNOWN = 255
};
bool ACPowerCharger_PowerChargerType_IsValid(int value);
const ACPowerCharger_PowerChargerType ACPowerCharger_PowerChargerType_PowerChargerType_MIN = ACPowerCharger_PowerChargerType_PCT_AC_ONLY;
const ACPowerCharger_PowerChargerType ACPowerCharger_PowerChargerType_PowerChargerType_MAX = ACPowerCharger_PowerChargerType_PCT_UNKNOWN;
const int ACPowerCharger_PowerChargerType_PowerChargerType_ARRAYSIZE = ACPowerCharger_PowerChargerType_PowerChargerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACPowerCharger_PowerChargerType_descriptor();
inline const ::std::string& ACPowerCharger_PowerChargerType_Name(ACPowerCharger_PowerChargerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACPowerCharger_PowerChargerType_descriptor(), value);
}
inline bool ACPowerCharger_PowerChargerType_Parse(
    const ::std::string& name, ACPowerCharger_PowerChargerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACPowerCharger_PowerChargerType>(
    ACPowerCharger_PowerChargerType_descriptor(), name, value);
}
enum ServiceState {
  SS_ON_GOING = 0,
  SS_WAITING = 1,
  SS_STOP = 2,
  SS_PAUSE = 3,
  SS_UNDER_CONSTRUCTION = 4,
  SS_OFFLINE = 5,
  SS_OTHER = 254,
  SS_UNKNOWN = 255
};
bool ServiceState_IsValid(int value);
const ServiceState ServiceState_MIN = SS_ON_GOING;
const ServiceState ServiceState_MAX = SS_UNKNOWN;
const int ServiceState_ARRAYSIZE = ServiceState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceState_descriptor();
inline const ::std::string& ServiceState_Name(ServiceState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceState_descriptor(), value);
}
inline bool ServiceState_Parse(
    const ::std::string& name, ServiceState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceState>(
    ServiceState_descriptor(), name, value);
}
enum ServiceStateReason {
  SSR_OUT_OF_POWER = 0,
  SSR_LACK_OF_RANGE = 1,
  SSR_ALTERNATIVE_TRANSLATIONS = 2,
  SSR_OFF_WORK = 3,
  SSR_UPGRADE = 4,
  SSR_DOWNTIME = 5,
  SSR_MAINTENANCE = 6,
  SSR_SUPPLEMENTATION = 7,
  SSR_OTHER = 254,
  SSR_UNKNOWN = 255
};
bool ServiceStateReason_IsValid(int value);
const ServiceStateReason ServiceStateReason_MIN = SSR_OUT_OF_POWER;
const ServiceStateReason ServiceStateReason_MAX = SSR_UNKNOWN;
const int ServiceStateReason_ARRAYSIZE = ServiceStateReason_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceStateReason_descriptor();
inline const ::std::string& ServiceStateReason_Name(ServiceStateReason value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceStateReason_descriptor(), value);
}
inline bool ServiceStateReason_Parse(
    const ::std::string& name, ServiceStateReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceStateReason>(
    ServiceStateReason_descriptor(), name, value);
}
enum NetworkOperator {
  NO_CHINA_MOBILE = 0,
  NO_CHINA_UNICOM = 1,
  NO_CHINA_TELECOM = 2,
  NO_OTHER = 254,
  NO_UNKNOWN = 255
};
bool NetworkOperator_IsValid(int value);
const NetworkOperator NetworkOperator_MIN = NO_CHINA_MOBILE;
const NetworkOperator NetworkOperator_MAX = NO_UNKNOWN;
const int NetworkOperator_ARRAYSIZE = NetworkOperator_MAX + 1;

const ::google::protobuf::EnumDescriptor* NetworkOperator_descriptor();
inline const ::std::string& NetworkOperator_Name(NetworkOperator value) {
  return ::google::protobuf::internal::NameOfEnum(
    NetworkOperator_descriptor(), value);
}
inline bool NetworkOperator_Parse(
    const ::std::string& name, NetworkOperator* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetworkOperator>(
    NetworkOperator_descriptor(), name, value);
}
enum NetworkType {
  NT_RJ45 = 0,
  NT_RADIO_2G = 1,
  NT_RADIO_3G = 2,
  NT_RADIO_4G = 3,
  NT_OTHER = 254,
  NT_UNKNOWN = 255
};
bool NetworkType_IsValid(int value);
const NetworkType NetworkType_MIN = NT_RJ45;
const NetworkType NetworkType_MAX = NT_UNKNOWN;
const int NetworkType_ARRAYSIZE = NetworkType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NetworkType_descriptor();
inline const ::std::string& NetworkType_Name(NetworkType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NetworkType_descriptor(), value);
}
inline bool NetworkType_Parse(
    const ::std::string& name, NetworkType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetworkType>(
    NetworkType_descriptor(), name, value);
}
enum ChargingConnectorWorkState {
  CCWS_FREE = 0,
  CCWS_IN_CHARGING = 1,
  CCWS_CHARGING_COMPLETE = 3
};
bool ChargingConnectorWorkState_IsValid(int value);
const ChargingConnectorWorkState ChargingConnectorWorkState_MIN = CCWS_FREE;
const ChargingConnectorWorkState ChargingConnectorWorkState_MAX = CCWS_CHARGING_COMPLETE;
const int ChargingConnectorWorkState_ARRAYSIZE = ChargingConnectorWorkState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChargingConnectorWorkState_descriptor();
inline const ::std::string& ChargingConnectorWorkState_Name(ChargingConnectorWorkState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChargingConnectorWorkState_descriptor(), value);
}
inline bool ChargingConnectorWorkState_Parse(
    const ::std::string& name, ChargingConnectorWorkState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChargingConnectorWorkState>(
    ChargingConnectorWorkState_descriptor(), name, value);
}
enum ChargingConnectorConnectionState {
  CCCS_CONNECTED = 0,
  CCCS_DISCONNECTED = 1
};
bool ChargingConnectorConnectionState_IsValid(int value);
const ChargingConnectorConnectionState ChargingConnectorConnectionState_MIN = CCCS_CONNECTED;
const ChargingConnectorConnectionState ChargingConnectorConnectionState_MAX = CCCS_DISCONNECTED;
const int ChargingConnectorConnectionState_ARRAYSIZE = ChargingConnectorConnectionState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChargingConnectorConnectionState_descriptor();
inline const ::std::string& ChargingConnectorConnectionState_Name(ChargingConnectorConnectionState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChargingConnectorConnectionState_descriptor(), value);
}
inline bool ChargingConnectorConnectionState_Parse(
    const ::std::string& name, ChargingConnectorConnectionState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChargingConnectorConnectionState>(
    ChargingConnectorConnectionState_descriptor(), name, value);
}
enum ChargingConnectorFaultState {
  CCFS_NO_FAULT = 0,
  CCFS_HAVING_FAULT = 1
};
bool ChargingConnectorFaultState_IsValid(int value);
const ChargingConnectorFaultState ChargingConnectorFaultState_MIN = CCFS_NO_FAULT;
const ChargingConnectorFaultState ChargingConnectorFaultState_MAX = CCFS_HAVING_FAULT;
const int ChargingConnectorFaultState_ARRAYSIZE = ChargingConnectorFaultState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChargingConnectorFaultState_descriptor();
inline const ::std::string& ChargingConnectorFaultState_Name(ChargingConnectorFaultState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChargingConnectorFaultState_descriptor(), value);
}
inline bool ChargingConnectorFaultState_Parse(
    const ::std::string& name, ChargingConnectorFaultState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChargingConnectorFaultState>(
    ChargingConnectorFaultState_descriptor(), name, value);
}
enum PowerChargerConnectorOutputType {
  COT_3_PHASE = 0,
  COT_7_PIN = 1,
  COT_9_PIN = 2
};
bool PowerChargerConnectorOutputType_IsValid(int value);
const PowerChargerConnectorOutputType PowerChargerConnectorOutputType_MIN = COT_3_PHASE;
const PowerChargerConnectorOutputType PowerChargerConnectorOutputType_MAX = COT_9_PIN;
const int PowerChargerConnectorOutputType_ARRAYSIZE = PowerChargerConnectorOutputType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PowerChargerConnectorOutputType_descriptor();
inline const ::std::string& PowerChargerConnectorOutputType_Name(PowerChargerConnectorOutputType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PowerChargerConnectorOutputType_descriptor(), value);
}
inline bool PowerChargerConnectorOutputType_Parse(
    const ::std::string& name, PowerChargerConnectorOutputType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PowerChargerConnectorOutputType>(
    PowerChargerConnectorOutputType_descriptor(), name, value);
}
enum PowerChargerConnectorOutputVoltage {
  COV_380V = 0,
  COV_220V = 1,
  COV_500V = 2,
  COV_750V = 3
};
bool PowerChargerConnectorOutputVoltage_IsValid(int value);
const PowerChargerConnectorOutputVoltage PowerChargerConnectorOutputVoltage_MIN = COV_380V;
const PowerChargerConnectorOutputVoltage PowerChargerConnectorOutputVoltage_MAX = COV_750V;
const int PowerChargerConnectorOutputVoltage_ARRAYSIZE = PowerChargerConnectorOutputVoltage_MAX + 1;

const ::google::protobuf::EnumDescriptor* PowerChargerConnectorOutputVoltage_descriptor();
inline const ::std::string& PowerChargerConnectorOutputVoltage_Name(PowerChargerConnectorOutputVoltage value) {
  return ::google::protobuf::internal::NameOfEnum(
    PowerChargerConnectorOutputVoltage_descriptor(), value);
}
inline bool PowerChargerConnectorOutputVoltage_Parse(
    const ::std::string& name, PowerChargerConnectorOutputVoltage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PowerChargerConnectorOutputVoltage>(
    PowerChargerConnectorOutputVoltage_descriptor(), name, value);
}
enum ServiceEvent {
  SE_START = 0,
  SE_FINISH = 1
};
bool ServiceEvent_IsValid(int value);
const ServiceEvent ServiceEvent_MIN = SE_START;
const ServiceEvent ServiceEvent_MAX = SE_FINISH;
const int ServiceEvent_ARRAYSIZE = ServiceEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceEvent_descriptor();
inline const ::std::string& ServiceEvent_Name(ServiceEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceEvent_descriptor(), value);
}
inline bool ServiceEvent_Parse(
    const ::std::string& name, ServiceEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceEvent>(
    ServiceEvent_descriptor(), name, value);
}
enum ServiceFinishResult {
  SFR_OK = 0,
  SFR_ERROR = 1
};
bool ServiceFinishResult_IsValid(int value);
const ServiceFinishResult ServiceFinishResult_MIN = SFR_OK;
const ServiceFinishResult ServiceFinishResult_MAX = SFR_ERROR;
const int ServiceFinishResult_ARRAYSIZE = ServiceFinishResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* ServiceFinishResult_descriptor();
inline const ::std::string& ServiceFinishResult_Name(ServiceFinishResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    ServiceFinishResult_descriptor(), value);
}
inline bool ServiceFinishResult_Parse(
    const ::std::string& name, ServiceFinishResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ServiceFinishResult>(
    ServiceFinishResult_descriptor(), name, value);
}
enum AlarmState {
  AS_INACTIVE = 0,
  AS_ACTIVE = 1
};
bool AlarmState_IsValid(int value);
const AlarmState AlarmState_MIN = AS_INACTIVE;
const AlarmState AlarmState_MAX = AS_ACTIVE;
const int AlarmState_ARRAYSIZE = AlarmState_MAX + 1;

const ::google::protobuf::EnumDescriptor* AlarmState_descriptor();
inline const ::std::string& AlarmState_Name(AlarmState value) {
  return ::google::protobuf::internal::NameOfEnum(
    AlarmState_descriptor(), value);
}
inline bool AlarmState_Parse(
    const ::std::string& name, AlarmState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AlarmState>(
    AlarmState_descriptor(), name, value);
}
enum LocalConfigurationInfoAccessType {
  LCIAT_READONLY = 0,
  LCIAT_READWRITE = 1
};
bool LocalConfigurationInfoAccessType_IsValid(int value);
const LocalConfigurationInfoAccessType LocalConfigurationInfoAccessType_MIN = LCIAT_READONLY;
const LocalConfigurationInfoAccessType LocalConfigurationInfoAccessType_MAX = LCIAT_READWRITE;
const int LocalConfigurationInfoAccessType_ARRAYSIZE = LocalConfigurationInfoAccessType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LocalConfigurationInfoAccessType_descriptor();
inline const ::std::string& LocalConfigurationInfoAccessType_Name(LocalConfigurationInfoAccessType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LocalConfigurationInfoAccessType_descriptor(), value);
}
inline bool LocalConfigurationInfoAccessType_Parse(
    const ::std::string& name, LocalConfigurationInfoAccessType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LocalConfigurationInfoAccessType>(
    LocalConfigurationInfoAccessType_descriptor(), name, value);
}
enum RemoteControlCommand {
  RCC_SHUTDOWN = 0,
  RCC_REBOOT = 1,
  RCC_ENABLE_CONNECTOR = 2,
  RCC_DISABLE_CONNECTOR = 3,
  RCC_START_CHARGING = 4,
  RCC_STOP_CHARGING = 5,
  RCC_STARTUP = 6
};
bool RemoteControlCommand_IsValid(int value);
const RemoteControlCommand RemoteControlCommand_MIN = RCC_SHUTDOWN;
const RemoteControlCommand RemoteControlCommand_MAX = RCC_STARTUP;
const int RemoteControlCommand_ARRAYSIZE = RemoteControlCommand_MAX + 1;

const ::google::protobuf::EnumDescriptor* RemoteControlCommand_descriptor();
inline const ::std::string& RemoteControlCommand_Name(RemoteControlCommand value) {
  return ::google::protobuf::internal::NameOfEnum(
    RemoteControlCommand_descriptor(), value);
}
inline bool RemoteControlCommand_Parse(
    const ::std::string& name, RemoteControlCommand* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RemoteControlCommand>(
    RemoteControlCommand_descriptor(), name, value);
}
enum RemoteConfigurationResponseType {
  RCONFRT_RECEIVED = 0,
  RCONFRT_FINISHED_OK = 1,
  RCONFRT_FINISHED_FAILED = 2
};
bool RemoteConfigurationResponseType_IsValid(int value);
const RemoteConfigurationResponseType RemoteConfigurationResponseType_MIN = RCONFRT_RECEIVED;
const RemoteConfigurationResponseType RemoteConfigurationResponseType_MAX = RCONFRT_FINISHED_FAILED;
const int RemoteConfigurationResponseType_ARRAYSIZE = RemoteConfigurationResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RemoteConfigurationResponseType_descriptor();
inline const ::std::string& RemoteConfigurationResponseType_Name(RemoteConfigurationResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RemoteConfigurationResponseType_descriptor(), value);
}
inline bool RemoteConfigurationResponseType_Parse(
    const ::std::string& name, RemoteConfigurationResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RemoteConfigurationResponseType>(
    RemoteConfigurationResponseType_descriptor(), name, value);
}
enum RemoteControlResponseType {
  RCONTRT_RECEIVED = 0,
  RCONTRT_FINISHED_OK = 1,
  RCONTRT_FINISHED_FAILED = 2
};
bool RemoteControlResponseType_IsValid(int value);
const RemoteControlResponseType RemoteControlResponseType_MIN = RCONTRT_RECEIVED;
const RemoteControlResponseType RemoteControlResponseType_MAX = RCONTRT_FINISHED_FAILED;
const int RemoteControlResponseType_ARRAYSIZE = RemoteControlResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RemoteControlResponseType_descriptor();
inline const ::std::string& RemoteControlResponseType_Name(RemoteControlResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RemoteControlResponseType_descriptor(), value);
}
inline bool RemoteControlResponseType_Parse(
    const ::std::string& name, RemoteControlResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RemoteControlResponseType>(
    RemoteControlResponseType_descriptor(), name, value);
}
// ===================================================================

class Message_ParamType : public ::google::protobuf::Message {
 public:
  Message_ParamType();
  virtual ~Message_ParamType();

  Message_ParamType(const Message_ParamType& from);

  inline Message_ParamType& operator=(const Message_ParamType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_ParamType& default_instance();

  void Swap(Message_ParamType* other);

  // implements Message ----------------------------------------------

  Message_ParamType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_ParamType& from);
  void MergeFrom(const Message_ParamType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:Message.ParamType)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static Message_ParamType* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Message_ParamType ParamType;

  typedef Message_MessageType MessageType;
  static const MessageType NOTIFICATION = Message_MessageType_NOTIFICATION;
  static const MessageType CONTROL_COMMAND = Message_MessageType_CONTROL_COMMAND;
  static const MessageType COMMAND_RESULT = Message_MessageType_COMMAND_RESULT;
  static const MessageType DATA_REPORT = Message_MessageType_DATA_REPORT;
  static const MessageType CLIENT_STATUS = Message_MessageType_CLIENT_STATUS;
  static inline bool MessageType_IsValid(int value) {
    return Message_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    Message_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    Message_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    Message_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return Message_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return Message_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return Message_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional string id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional int64 publish_ts = 3;
  inline bool has_publish_ts() const;
  inline void clear_publish_ts();
  static const int kPublishTsFieldNumber = 3;
  inline ::google::protobuf::int64 publish_ts() const;
  inline void set_publish_ts(::google::protobuf::int64 value);

  // optional int64 ttl = 4;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 4;
  inline ::google::protobuf::int64 ttl() const;
  inline void set_ttl(::google::protobuf::int64 value);

  // optional .Message.MessageType type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::Message_MessageType type() const;
  inline void set_type(::Message_MessageType value);

  // optional string sub_type = 6;
  inline bool has_sub_type() const;
  inline void clear_sub_type();
  static const int kSubTypeFieldNumber = 6;
  inline const ::std::string& sub_type() const;
  inline void set_sub_type(const ::std::string& value);
  inline void set_sub_type(const char* value);
  inline void set_sub_type(const char* value, size_t size);
  inline ::std::string* mutable_sub_type();
  inline ::std::string* release_sub_type();
  inline void set_allocated_sub_type(::std::string* sub_type);

  // repeated .Message.ParamType params = 7;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 7;
  inline const ::Message_ParamType& params(int index) const;
  inline ::Message_ParamType* mutable_params(int index);
  inline ::Message_ParamType* add_params();
  inline const ::google::protobuf::RepeatedPtrField< ::Message_ParamType >&
      params() const;
  inline ::google::protobuf::RepeatedPtrField< ::Message_ParamType >*
      mutable_params();

  // @@protoc_insertion_point(class_scope:Message)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_publish_ts();
  inline void clear_has_publish_ts();
  inline void set_has_ttl();
  inline void clear_has_ttl();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_sub_type();
  inline void clear_has_sub_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::google::protobuf::int64 publish_ts_;
  ::google::protobuf::int32 version_;
  int type_;
  ::google::protobuf::int64 ttl_;
  ::std::string* sub_type_;
  ::google::protobuf::RepeatedPtrField< ::Message_ParamType > params_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class ACPowerCharger_BasicInfo : public ::google::protobuf::Message {
 public:
  ACPowerCharger_BasicInfo();
  virtual ~ACPowerCharger_BasicInfo();

  ACPowerCharger_BasicInfo(const ACPowerCharger_BasicInfo& from);

  inline ACPowerCharger_BasicInfo& operator=(const ACPowerCharger_BasicInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACPowerCharger_BasicInfo& default_instance();

  void Swap(ACPowerCharger_BasicInfo* other);

  // implements Message ----------------------------------------------

  ACPowerCharger_BasicInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACPowerCharger_BasicInfo& from);
  void MergeFrom(const ACPowerCharger_BasicInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CommonBasicInfo common_basic_info = 1;
  inline bool has_common_basic_info() const;
  inline void clear_common_basic_info();
  static const int kCommonBasicInfoFieldNumber = 1;
  inline const ::CommonBasicInfo& common_basic_info() const;
  inline ::CommonBasicInfo* mutable_common_basic_info();
  inline ::CommonBasicInfo* release_common_basic_info();
  inline void set_allocated_common_basic_info(::CommonBasicInfo* common_basic_info);

  // optional .ACPowerCharger.PowerChargerType power_charger_type = 2;
  inline bool has_power_charger_type() const;
  inline void clear_power_charger_type();
  static const int kPowerChargerTypeFieldNumber = 2;
  inline ::ACPowerCharger_PowerChargerType power_charger_type() const;
  inline void set_power_charger_type(::ACPowerCharger_PowerChargerType value);

  // optional int32 charging_connector_quantity = 3;
  inline bool has_charging_connector_quantity() const;
  inline void clear_charging_connector_quantity();
  static const int kChargingConnectorQuantityFieldNumber = 3;
  inline ::google::protobuf::int32 charging_connector_quantity() const;
  inline void set_charging_connector_quantity(::google::protobuf::int32 value);

  // optional float power = 4;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 4;
  inline float power() const;
  inline void set_power(float value);

  // @@protoc_insertion_point(class_scope:ACPowerCharger.BasicInfo)
 private:
  inline void set_has_common_basic_info();
  inline void clear_has_common_basic_info();
  inline void set_has_power_charger_type();
  inline void clear_has_power_charger_type();
  inline void set_has_charging_connector_quantity();
  inline void clear_has_charging_connector_quantity();
  inline void set_has_power();
  inline void clear_has_power();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CommonBasicInfo* common_basic_info_;
  int power_charger_type_;
  ::google::protobuf::int32 charging_connector_quantity_;
  float power_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static ACPowerCharger_BasicInfo* default_instance_;
};
// -------------------------------------------------------------------

class ACPowerCharger_RealtimeInfo : public ::google::protobuf::Message {
 public:
  ACPowerCharger_RealtimeInfo();
  virtual ~ACPowerCharger_RealtimeInfo();

  ACPowerCharger_RealtimeInfo(const ACPowerCharger_RealtimeInfo& from);

  inline ACPowerCharger_RealtimeInfo& operator=(const ACPowerCharger_RealtimeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACPowerCharger_RealtimeInfo& default_instance();

  void Swap(ACPowerCharger_RealtimeInfo* other);

  // implements Message ----------------------------------------------

  ACPowerCharger_RealtimeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACPowerCharger_RealtimeInfo& from);
  void MergeFrom(const ACPowerCharger_RealtimeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ConnectivityState connectivity_state = 1;
  inline bool has_connectivity_state() const;
  inline void clear_connectivity_state();
  static const int kConnectivityStateFieldNumber = 1;
  inline const ::ConnectivityState& connectivity_state() const;
  inline ::ConnectivityState* mutable_connectivity_state();
  inline ::ConnectivityState* release_connectivity_state();
  inline void set_allocated_connectivity_state(::ConnectivityState* connectivity_state);

  // optional .ACPowerCharger.DeviceWorkState device_work_state = 2;
  inline bool has_device_work_state() const;
  inline void clear_device_work_state();
  static const int kDeviceWorkStateFieldNumber = 2;
  inline ::ACPowerCharger_DeviceWorkState device_work_state() const;
  inline void set_device_work_state(::ACPowerCharger_DeviceWorkState value);

  // repeated .ChargingConnector charging_connector = 4;
  inline int charging_connector_size() const;
  inline void clear_charging_connector();
  static const int kChargingConnectorFieldNumber = 4;
  inline const ::ChargingConnector& charging_connector(int index) const;
  inline ::ChargingConnector* mutable_charging_connector(int index);
  inline ::ChargingConnector* add_charging_connector();
  inline const ::google::protobuf::RepeatedPtrField< ::ChargingConnector >&
      charging_connector() const;
  inline ::google::protobuf::RepeatedPtrField< ::ChargingConnector >*
      mutable_charging_connector();

  // @@protoc_insertion_point(class_scope:ACPowerCharger.RealtimeInfo)
 private:
  inline void set_has_connectivity_state();
  inline void clear_has_connectivity_state();
  inline void set_has_device_work_state();
  inline void clear_has_device_work_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ConnectivityState* connectivity_state_;
  ::google::protobuf::RepeatedPtrField< ::ChargingConnector > charging_connector_;
  int device_work_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static ACPowerCharger_RealtimeInfo* default_instance_;
};
// -------------------------------------------------------------------

class ACPowerCharger_ServiceInfo : public ::google::protobuf::Message {
 public:
  ACPowerCharger_ServiceInfo();
  virtual ~ACPowerCharger_ServiceInfo();

  ACPowerCharger_ServiceInfo(const ACPowerCharger_ServiceInfo& from);

  inline ACPowerCharger_ServiceInfo& operator=(const ACPowerCharger_ServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACPowerCharger_ServiceInfo& default_instance();

  void Swap(ACPowerCharger_ServiceInfo* other);

  // implements Message ----------------------------------------------

  ACPowerCharger_ServiceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACPowerCharger_ServiceInfo& from);
  void MergeFrom(const ACPowerCharger_ServiceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_id = 1;
  inline bool has_service_id() const;
  inline void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  inline const ::std::string& service_id() const;
  inline void set_service_id(const ::std::string& value);
  inline void set_service_id(const char* value);
  inline void set_service_id(const char* value, size_t size);
  inline ::std::string* mutable_service_id();
  inline ::std::string* release_service_id();
  inline void set_allocated_service_id(::std::string* service_id);

  // optional .ServiceEvent service_event = 2;
  inline bool has_service_event() const;
  inline void clear_service_event();
  static const int kServiceEventFieldNumber = 2;
  inline ::ServiceEvent service_event() const;
  inline void set_service_event(::ServiceEvent value);

  // optional int64 charging_event_timestamp = 3;
  inline bool has_charging_event_timestamp() const;
  inline void clear_charging_event_timestamp();
  static const int kChargingEventTimestampFieldNumber = 3;
  inline ::google::protobuf::int64 charging_event_timestamp() const;
  inline void set_charging_event_timestamp(::google::protobuf::int64 value);

  // optional string charging_connector_id = 4;
  inline bool has_charging_connector_id() const;
  inline void clear_charging_connector_id();
  static const int kChargingConnectorIdFieldNumber = 4;
  inline const ::std::string& charging_connector_id() const;
  inline void set_charging_connector_id(const ::std::string& value);
  inline void set_charging_connector_id(const char* value);
  inline void set_charging_connector_id(const char* value, size_t size);
  inline ::std::string* mutable_charging_connector_id();
  inline ::std::string* release_charging_connector_id();
  inline void set_allocated_charging_connector_id(::std::string* charging_connector_id);

  // optional float realtime_charged_energy = 5;
  inline bool has_realtime_charged_energy() const;
  inline void clear_realtime_charged_energy();
  static const int kRealtimeChargedEnergyFieldNumber = 5;
  inline float realtime_charged_energy() const;
  inline void set_realtime_charged_energy(float value);

  // optional .ServiceFinishResult service_finish_result = 6;
  inline bool has_service_finish_result() const;
  inline void clear_service_finish_result();
  static const int kServiceFinishResultFieldNumber = 6;
  inline ::ServiceFinishResult service_finish_result() const;
  inline void set_service_finish_result(::ServiceFinishResult value);

  // optional float charged_energy_total = 7;
  inline bool has_charged_energy_total() const;
  inline void clear_charged_energy_total();
  static const int kChargedEnergyTotalFieldNumber = 7;
  inline float charged_energy_total() const;
  inline void set_charged_energy_total(float value);

  // @@protoc_insertion_point(class_scope:ACPowerCharger.ServiceInfo)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_service_event();
  inline void clear_has_service_event();
  inline void set_has_charging_event_timestamp();
  inline void clear_has_charging_event_timestamp();
  inline void set_has_charging_connector_id();
  inline void clear_has_charging_connector_id();
  inline void set_has_realtime_charged_energy();
  inline void clear_has_realtime_charged_energy();
  inline void set_has_service_finish_result();
  inline void clear_has_service_finish_result();
  inline void set_has_charged_energy_total();
  inline void clear_has_charged_energy_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* service_id_;
  ::google::protobuf::int64 charging_event_timestamp_;
  int service_event_;
  float realtime_charged_energy_;
  ::std::string* charging_connector_id_;
  int service_finish_result_;
  float charged_energy_total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static ACPowerCharger_ServiceInfo* default_instance_;
};
// -------------------------------------------------------------------

class ACPowerCharger : public ::google::protobuf::Message {
 public:
  ACPowerCharger();
  virtual ~ACPowerCharger();

  ACPowerCharger(const ACPowerCharger& from);

  inline ACPowerCharger& operator=(const ACPowerCharger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACPowerCharger& default_instance();

  void Swap(ACPowerCharger* other);

  // implements Message ----------------------------------------------

  ACPowerCharger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACPowerCharger& from);
  void MergeFrom(const ACPowerCharger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ACPowerCharger_BasicInfo BasicInfo;
  typedef ACPowerCharger_RealtimeInfo RealtimeInfo;
  typedef ACPowerCharger_ServiceInfo ServiceInfo;

  typedef ACPowerCharger_DeviceWorkState DeviceWorkState;
  static const DeviceWorkState DWS_FREE = ACPowerCharger_DeviceWorkState_DWS_FREE;
  static const DeviceWorkState DWS_IN_CHARGING = ACPowerCharger_DeviceWorkState_DWS_IN_CHARGING;
  static inline bool DeviceWorkState_IsValid(int value) {
    return ACPowerCharger_DeviceWorkState_IsValid(value);
  }
  static const DeviceWorkState DeviceWorkState_MIN =
    ACPowerCharger_DeviceWorkState_DeviceWorkState_MIN;
  static const DeviceWorkState DeviceWorkState_MAX =
    ACPowerCharger_DeviceWorkState_DeviceWorkState_MAX;
  static const int DeviceWorkState_ARRAYSIZE =
    ACPowerCharger_DeviceWorkState_DeviceWorkState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DeviceWorkState_descriptor() {
    return ACPowerCharger_DeviceWorkState_descriptor();
  }
  static inline const ::std::string& DeviceWorkState_Name(DeviceWorkState value) {
    return ACPowerCharger_DeviceWorkState_Name(value);
  }
  static inline bool DeviceWorkState_Parse(const ::std::string& name,
      DeviceWorkState* value) {
    return ACPowerCharger_DeviceWorkState_Parse(name, value);
  }

  typedef ACPowerCharger_PowerChargerType PowerChargerType;
  static const PowerChargerType PCT_AC_ONLY = ACPowerCharger_PowerChargerType_PCT_AC_ONLY;
  static const PowerChargerType PCT_DC_ONLY = ACPowerCharger_PowerChargerType_PCT_DC_ONLY;
  static const PowerChargerType PCT_AC_DC_HYBRID = ACPowerCharger_PowerChargerType_PCT_AC_DC_HYBRID;
  static const PowerChargerType PCT_OTHER = ACPowerCharger_PowerChargerType_PCT_OTHER;
  static const PowerChargerType PCT_UNKNOWN = ACPowerCharger_PowerChargerType_PCT_UNKNOWN;
  static inline bool PowerChargerType_IsValid(int value) {
    return ACPowerCharger_PowerChargerType_IsValid(value);
  }
  static const PowerChargerType PowerChargerType_MIN =
    ACPowerCharger_PowerChargerType_PowerChargerType_MIN;
  static const PowerChargerType PowerChargerType_MAX =
    ACPowerCharger_PowerChargerType_PowerChargerType_MAX;
  static const int PowerChargerType_ARRAYSIZE =
    ACPowerCharger_PowerChargerType_PowerChargerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PowerChargerType_descriptor() {
    return ACPowerCharger_PowerChargerType_descriptor();
  }
  static inline const ::std::string& PowerChargerType_Name(PowerChargerType value) {
    return ACPowerCharger_PowerChargerType_Name(value);
  }
  static inline bool PowerChargerType_Parse(const ::std::string& name,
      PowerChargerType* value) {
    return ACPowerCharger_PowerChargerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int64 message_timestamp = 2;
  inline bool has_message_timestamp() const;
  inline void clear_message_timestamp();
  static const int kMessageTimestampFieldNumber = 2;
  inline ::google::protobuf::int64 message_timestamp() const;
  inline void set_message_timestamp(::google::protobuf::int64 value);

  // optional .ACPowerCharger.BasicInfo basicInfo = 3;
  inline bool has_basicinfo() const;
  inline void clear_basicinfo();
  static const int kBasicInfoFieldNumber = 3;
  inline const ::ACPowerCharger_BasicInfo& basicinfo() const;
  inline ::ACPowerCharger_BasicInfo* mutable_basicinfo();
  inline ::ACPowerCharger_BasicInfo* release_basicinfo();
  inline void set_allocated_basicinfo(::ACPowerCharger_BasicInfo* basicinfo);

  // optional .ACPowerCharger.RealtimeInfo realtime_info = 4;
  inline bool has_realtime_info() const;
  inline void clear_realtime_info();
  static const int kRealtimeInfoFieldNumber = 4;
  inline const ::ACPowerCharger_RealtimeInfo& realtime_info() const;
  inline ::ACPowerCharger_RealtimeInfo* mutable_realtime_info();
  inline ::ACPowerCharger_RealtimeInfo* release_realtime_info();
  inline void set_allocated_realtime_info(::ACPowerCharger_RealtimeInfo* realtime_info);

  // repeated .Alarm alarms = 5;
  inline int alarms_size() const;
  inline void clear_alarms();
  static const int kAlarmsFieldNumber = 5;
  inline const ::Alarm& alarms(int index) const;
  inline ::Alarm* mutable_alarms(int index);
  inline ::Alarm* add_alarms();
  inline const ::google::protobuf::RepeatedPtrField< ::Alarm >&
      alarms() const;
  inline ::google::protobuf::RepeatedPtrField< ::Alarm >*
      mutable_alarms();

  // repeated .ACPowerCharger.ServiceInfo service_info = 6;
  inline int service_info_size() const;
  inline void clear_service_info();
  static const int kServiceInfoFieldNumber = 6;
  inline const ::ACPowerCharger_ServiceInfo& service_info(int index) const;
  inline ::ACPowerCharger_ServiceInfo* mutable_service_info(int index);
  inline ::ACPowerCharger_ServiceInfo* add_service_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ACPowerCharger_ServiceInfo >&
      service_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ACPowerCharger_ServiceInfo >*
      mutable_service_info();

  // optional .LocalConfiguration local_configuration = 7;
  inline bool has_local_configuration() const;
  inline void clear_local_configuration();
  static const int kLocalConfigurationFieldNumber = 7;
  inline const ::LocalConfiguration& local_configuration() const;
  inline ::LocalConfiguration* mutable_local_configuration();
  inline ::LocalConfiguration* release_local_configuration();
  inline void set_allocated_local_configuration(::LocalConfiguration* local_configuration);

  // @@protoc_insertion_point(class_scope:ACPowerCharger)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_message_timestamp();
  inline void clear_has_message_timestamp();
  inline void set_has_basicinfo();
  inline void clear_has_basicinfo();
  inline void set_has_realtime_info();
  inline void clear_has_realtime_info();
  inline void set_has_local_configuration();
  inline void clear_has_local_configuration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int64 message_timestamp_;
  ::ACPowerCharger_BasicInfo* basicinfo_;
  ::ACPowerCharger_RealtimeInfo* realtime_info_;
  ::google::protobuf::RepeatedPtrField< ::Alarm > alarms_;
  ::google::protobuf::RepeatedPtrField< ::ACPowerCharger_ServiceInfo > service_info_;
  ::LocalConfiguration* local_configuration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static ACPowerCharger* default_instance_;
};
// -------------------------------------------------------------------

class CommonBasicInfo : public ::google::protobuf::Message {
 public:
  CommonBasicInfo();
  virtual ~CommonBasicInfo();

  CommonBasicInfo(const CommonBasicInfo& from);

  inline CommonBasicInfo& operator=(const CommonBasicInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonBasicInfo& default_instance();

  void Swap(CommonBasicInfo* other);

  // implements Message ----------------------------------------------

  CommonBasicInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonBasicInfo& from);
  void MergeFrom(const CommonBasicInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string software_version = 1;
  inline bool has_software_version() const;
  inline void clear_software_version();
  static const int kSoftwareVersionFieldNumber = 1;
  inline const ::std::string& software_version() const;
  inline void set_software_version(const ::std::string& value);
  inline void set_software_version(const char* value);
  inline void set_software_version(const char* value, size_t size);
  inline ::std::string* mutable_software_version();
  inline ::std::string* release_software_version();
  inline void set_allocated_software_version(::std::string* software_version);

  // optional string hardware_version = 2;
  inline bool has_hardware_version() const;
  inline void clear_hardware_version();
  static const int kHardwareVersionFieldNumber = 2;
  inline const ::std::string& hardware_version() const;
  inline void set_hardware_version(const ::std::string& value);
  inline void set_hardware_version(const char* value);
  inline void set_hardware_version(const char* value, size_t size);
  inline ::std::string* mutable_hardware_version();
  inline ::std::string* release_hardware_version();
  inline void set_allocated_hardware_version(::std::string* hardware_version);

  // optional .ServiceStateInfo service_state_info = 3;
  inline bool has_service_state_info() const;
  inline void clear_service_state_info();
  static const int kServiceStateInfoFieldNumber = 3;
  inline const ::ServiceStateInfo& service_state_info() const;
  inline ::ServiceStateInfo* mutable_service_state_info();
  inline ::ServiceStateInfo* release_service_state_info();
  inline void set_allocated_service_state_info(::ServiceStateInfo* service_state_info);

  // @@protoc_insertion_point(class_scope:CommonBasicInfo)
 private:
  inline void set_has_software_version();
  inline void clear_has_software_version();
  inline void set_has_hardware_version();
  inline void clear_has_hardware_version();
  inline void set_has_service_state_info();
  inline void clear_has_service_state_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* software_version_;
  ::std::string* hardware_version_;
  ::ServiceStateInfo* service_state_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static CommonBasicInfo* default_instance_;
};
// -------------------------------------------------------------------

class ServiceStateInfo : public ::google::protobuf::Message {
 public:
  ServiceStateInfo();
  virtual ~ServiceStateInfo();

  ServiceStateInfo(const ServiceStateInfo& from);

  inline ServiceStateInfo& operator=(const ServiceStateInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceStateInfo& default_instance();

  void Swap(ServiceStateInfo* other);

  // implements Message ----------------------------------------------

  ServiceStateInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceStateInfo& from);
  void MergeFrom(const ServiceStateInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ServiceState service_state = 1;
  inline bool has_service_state() const;
  inline void clear_service_state();
  static const int kServiceStateFieldNumber = 1;
  inline ::ServiceState service_state() const;
  inline void set_service_state(::ServiceState value);

  // optional .ServiceStateReason service_state_reason = 2;
  inline bool has_service_state_reason() const;
  inline void clear_service_state_reason();
  static const int kServiceStateReasonFieldNumber = 2;
  inline ::ServiceStateReason service_state_reason() const;
  inline void set_service_state_reason(::ServiceStateReason value);

  // @@protoc_insertion_point(class_scope:ServiceStateInfo)
 private:
  inline void set_has_service_state();
  inline void clear_has_service_state();
  inline void set_has_service_state_reason();
  inline void clear_has_service_state_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int service_state_;
  int service_state_reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static ServiceStateInfo* default_instance_;
};
// -------------------------------------------------------------------

class ConnectivityState : public ::google::protobuf::Message {
 public:
  ConnectivityState();
  virtual ~ConnectivityState();

  ConnectivityState(const ConnectivityState& from);

  inline ConnectivityState& operator=(const ConnectivityState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectivityState& default_instance();

  void Swap(ConnectivityState* other);

  // implements Message ----------------------------------------------

  ConnectivityState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectivityState& from);
  void MergeFrom(const ConnectivityState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .NetworkOperator network_operator = 1;
  inline bool has_network_operator() const;
  inline void clear_network_operator();
  static const int kNetworkOperatorFieldNumber = 1;
  inline ::NetworkOperator network_operator() const;
  inline void set_network_operator(::NetworkOperator value);

  // optional .NetworkType network_type = 2;
  inline bool has_network_type() const;
  inline void clear_network_type();
  static const int kNetworkTypeFieldNumber = 2;
  inline ::NetworkType network_type() const;
  inline void set_network_type(::NetworkType value);

  // @@protoc_insertion_point(class_scope:ConnectivityState)
 private:
  inline void set_has_network_operator();
  inline void clear_has_network_operator();
  inline void set_has_network_type();
  inline void clear_has_network_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int network_operator_;
  int network_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static ConnectivityState* default_instance_;
};
// -------------------------------------------------------------------

class ChargingConnector : public ::google::protobuf::Message {
 public:
  ChargingConnector();
  virtual ~ChargingConnector();

  ChargingConnector(const ChargingConnector& from);

  inline ChargingConnector& operator=(const ChargingConnector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChargingConnector& default_instance();

  void Swap(ChargingConnector* other);

  // implements Message ----------------------------------------------

  ChargingConnector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChargingConnector& from);
  void MergeFrom(const ChargingConnector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string charging_connector_id = 1;
  inline bool has_charging_connector_id() const;
  inline void clear_charging_connector_id();
  static const int kChargingConnectorIdFieldNumber = 1;
  inline const ::std::string& charging_connector_id() const;
  inline void set_charging_connector_id(const ::std::string& value);
  inline void set_charging_connector_id(const char* value);
  inline void set_charging_connector_id(const char* value, size_t size);
  inline ::std::string* mutable_charging_connector_id();
  inline ::std::string* release_charging_connector_id();
  inline void set_allocated_charging_connector_id(::std::string* charging_connector_id);

  // optional .ChargingConnectorWorkState charging_connector_work_state = 2;
  inline bool has_charging_connector_work_state() const;
  inline void clear_charging_connector_work_state();
  static const int kChargingConnectorWorkStateFieldNumber = 2;
  inline ::ChargingConnectorWorkState charging_connector_work_state() const;
  inline void set_charging_connector_work_state(::ChargingConnectorWorkState value);

  // optional .ChargingConnectorConnectionState charging_connector_connection_state = 3;
  inline bool has_charging_connector_connection_state() const;
  inline void clear_charging_connector_connection_state();
  static const int kChargingConnectorConnectionStateFieldNumber = 3;
  inline ::ChargingConnectorConnectionState charging_connector_connection_state() const;
  inline void set_charging_connector_connection_state(::ChargingConnectorConnectionState value);

  // optional .ChargingConnectorFaultState charging_connector_fault_state = 4;
  inline bool has_charging_connector_fault_state() const;
  inline void clear_charging_connector_fault_state();
  static const int kChargingConnectorFaultStateFieldNumber = 4;
  inline ::ChargingConnectorFaultState charging_connector_fault_state() const;
  inline void set_charging_connector_fault_state(::ChargingConnectorFaultState value);

  // optional .PowerChargerConnectorOutputType power_charger_connector_output_type = 5;
  inline bool has_power_charger_connector_output_type() const;
  inline void clear_power_charger_connector_output_type();
  static const int kPowerChargerConnectorOutputTypeFieldNumber = 5;
  inline ::PowerChargerConnectorOutputType power_charger_connector_output_type() const;
  inline void set_power_charger_connector_output_type(::PowerChargerConnectorOutputType value);

  // optional .PowerChargerConnectorOutputVoltage power_charger_connector_rated_output_voltage = 6;
  inline bool has_power_charger_connector_rated_output_voltage() const;
  inline void clear_power_charger_connector_rated_output_voltage();
  static const int kPowerChargerConnectorRatedOutputVoltageFieldNumber = 6;
  inline ::PowerChargerConnectorOutputVoltage power_charger_connector_rated_output_voltage() const;
  inline void set_power_charger_connector_rated_output_voltage(::PowerChargerConnectorOutputVoltage value);

  // optional float power_charger_connector_rated_output_power = 7;
  inline bool has_power_charger_connector_rated_output_power() const;
  inline void clear_power_charger_connector_rated_output_power();
  static const int kPowerChargerConnectorRatedOutputPowerFieldNumber = 7;
  inline float power_charger_connector_rated_output_power() const;
  inline void set_power_charger_connector_rated_output_power(float value);

  // optional float realtime_output_voltage = 8;
  inline bool has_realtime_output_voltage() const;
  inline void clear_realtime_output_voltage();
  static const int kRealtimeOutputVoltageFieldNumber = 8;
  inline float realtime_output_voltage() const;
  inline void set_realtime_output_voltage(float value);

  // optional float realtime_output_current = 9;
  inline bool has_realtime_output_current() const;
  inline void clear_realtime_output_current();
  static const int kRealtimeOutputCurrentFieldNumber = 9;
  inline float realtime_output_current() const;
  inline void set_realtime_output_current(float value);

  // @@protoc_insertion_point(class_scope:ChargingConnector)
 private:
  inline void set_has_charging_connector_id();
  inline void clear_has_charging_connector_id();
  inline void set_has_charging_connector_work_state();
  inline void clear_has_charging_connector_work_state();
  inline void set_has_charging_connector_connection_state();
  inline void clear_has_charging_connector_connection_state();
  inline void set_has_charging_connector_fault_state();
  inline void clear_has_charging_connector_fault_state();
  inline void set_has_power_charger_connector_output_type();
  inline void clear_has_power_charger_connector_output_type();
  inline void set_has_power_charger_connector_rated_output_voltage();
  inline void clear_has_power_charger_connector_rated_output_voltage();
  inline void set_has_power_charger_connector_rated_output_power();
  inline void clear_has_power_charger_connector_rated_output_power();
  inline void set_has_realtime_output_voltage();
  inline void clear_has_realtime_output_voltage();
  inline void set_has_realtime_output_current();
  inline void clear_has_realtime_output_current();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* charging_connector_id_;
  int charging_connector_work_state_;
  int charging_connector_connection_state_;
  int charging_connector_fault_state_;
  int power_charger_connector_output_type_;
  int power_charger_connector_rated_output_voltage_;
  float power_charger_connector_rated_output_power_;
  float realtime_output_voltage_;
  float realtime_output_current_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static ChargingConnector* default_instance_;
};
// -------------------------------------------------------------------

class Alarm : public ::google::protobuf::Message {
 public:
  Alarm();
  virtual ~Alarm();

  Alarm(const Alarm& from);

  inline Alarm& operator=(const Alarm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Alarm& default_instance();

  void Swap(Alarm* other);

  // implements Message ----------------------------------------------

  Alarm* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Alarm& from);
  void MergeFrom(const Alarm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 alarm_type_id = 1;
  inline bool has_alarm_type_id() const;
  inline void clear_alarm_type_id();
  static const int kAlarmTypeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 alarm_type_id() const;
  inline void set_alarm_type_id(::google::protobuf::uint32 value);

  // optional int64 alarm_timestamp = 2;
  inline bool has_alarm_timestamp() const;
  inline void clear_alarm_timestamp();
  static const int kAlarmTimestampFieldNumber = 2;
  inline ::google::protobuf::int64 alarm_timestamp() const;
  inline void set_alarm_timestamp(::google::protobuf::int64 value);

  // optional .AlarmState alarm_state = 3;
  inline bool has_alarm_state() const;
  inline void clear_alarm_state();
  static const int kAlarmStateFieldNumber = 3;
  inline ::AlarmState alarm_state() const;
  inline void set_alarm_state(::AlarmState value);

  // @@protoc_insertion_point(class_scope:Alarm)
 private:
  inline void set_has_alarm_type_id();
  inline void clear_has_alarm_type_id();
  inline void set_has_alarm_timestamp();
  inline void clear_has_alarm_timestamp();
  inline void set_has_alarm_state();
  inline void clear_has_alarm_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 alarm_timestamp_;
  ::google::protobuf::uint32 alarm_type_id_;
  int alarm_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static Alarm* default_instance_;
};
// -------------------------------------------------------------------

class LocalConfiguration : public ::google::protobuf::Message {
 public:
  LocalConfiguration();
  virtual ~LocalConfiguration();

  LocalConfiguration(const LocalConfiguration& from);

  inline LocalConfiguration& operator=(const LocalConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalConfiguration& default_instance();

  void Swap(LocalConfiguration* other);

  // implements Message ----------------------------------------------

  LocalConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalConfiguration& from);
  void MergeFrom(const LocalConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool full = 1;
  inline bool has_full() const;
  inline void clear_full();
  static const int kFullFieldNumber = 1;
  inline bool full() const;
  inline void set_full(bool value);

  // repeated .LocalConfigurationInfo configuration_info = 2;
  inline int configuration_info_size() const;
  inline void clear_configuration_info();
  static const int kConfigurationInfoFieldNumber = 2;
  inline const ::LocalConfigurationInfo& configuration_info(int index) const;
  inline ::LocalConfigurationInfo* mutable_configuration_info(int index);
  inline ::LocalConfigurationInfo* add_configuration_info();
  inline const ::google::protobuf::RepeatedPtrField< ::LocalConfigurationInfo >&
      configuration_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::LocalConfigurationInfo >*
      mutable_configuration_info();

  // @@protoc_insertion_point(class_scope:LocalConfiguration)
 private:
  inline void set_has_full();
  inline void clear_has_full();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::LocalConfigurationInfo > configuration_info_;
  bool full_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static LocalConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class LocalConfigurationInfo : public ::google::protobuf::Message {
 public:
  LocalConfigurationInfo();
  virtual ~LocalConfigurationInfo();

  LocalConfigurationInfo(const LocalConfigurationInfo& from);

  inline LocalConfigurationInfo& operator=(const LocalConfigurationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalConfigurationInfo& default_instance();

  void Swap(LocalConfigurationInfo* other);

  // implements Message ----------------------------------------------

  LocalConfigurationInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalConfigurationInfo& from);
  void MergeFrom(const LocalConfigurationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string configuration_key = 1;
  inline bool has_configuration_key() const;
  inline void clear_configuration_key();
  static const int kConfigurationKeyFieldNumber = 1;
  inline const ::std::string& configuration_key() const;
  inline void set_configuration_key(const ::std::string& value);
  inline void set_configuration_key(const char* value);
  inline void set_configuration_key(const char* value, size_t size);
  inline ::std::string* mutable_configuration_key();
  inline ::std::string* release_configuration_key();
  inline void set_allocated_configuration_key(::std::string* configuration_key);

  // optional bytes configuration_value = 2;
  inline bool has_configuration_value() const;
  inline void clear_configuration_value();
  static const int kConfigurationValueFieldNumber = 2;
  inline const ::std::string& configuration_value() const;
  inline void set_configuration_value(const ::std::string& value);
  inline void set_configuration_value(const char* value);
  inline void set_configuration_value(const void* value, size_t size);
  inline ::std::string* mutable_configuration_value();
  inline ::std::string* release_configuration_value();
  inline void set_allocated_configuration_value(::std::string* configuration_value);

  // optional .LocalConfigurationInfoAccessType local_configuration_info_access_type = 3;
  inline bool has_local_configuration_info_access_type() const;
  inline void clear_local_configuration_info_access_type();
  static const int kLocalConfigurationInfoAccessTypeFieldNumber = 3;
  inline ::LocalConfigurationInfoAccessType local_configuration_info_access_type() const;
  inline void set_local_configuration_info_access_type(::LocalConfigurationInfoAccessType value);

  // optional bool has_been_updated = 4;
  inline bool has_has_been_updated() const;
  inline void clear_has_been_updated();
  static const int kHasBeenUpdatedFieldNumber = 4;
  inline bool has_been_updated() const;
  inline void set_has_been_updated(bool value);

  // optional string failureReason = 5;
  inline bool has_failurereason() const;
  inline void clear_failurereason();
  static const int kFailureReasonFieldNumber = 5;
  inline const ::std::string& failurereason() const;
  inline void set_failurereason(const ::std::string& value);
  inline void set_failurereason(const char* value);
  inline void set_failurereason(const char* value, size_t size);
  inline ::std::string* mutable_failurereason();
  inline ::std::string* release_failurereason();
  inline void set_allocated_failurereason(::std::string* failurereason);

  // @@protoc_insertion_point(class_scope:LocalConfigurationInfo)
 private:
  inline void set_has_configuration_key();
  inline void clear_has_configuration_key();
  inline void set_has_configuration_value();
  inline void clear_has_configuration_value();
  inline void set_has_local_configuration_info_access_type();
  inline void clear_has_local_configuration_info_access_type();
  inline void set_has_has_been_updated();
  inline void clear_has_has_been_updated();
  inline void set_has_failurereason();
  inline void clear_has_failurereason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* configuration_key_;
  ::std::string* configuration_value_;
  int local_configuration_info_access_type_;
  bool has_been_updated_;
  ::std::string* failurereason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static LocalConfigurationInfo* default_instance_;
};
// -------------------------------------------------------------------

class RemoteOperation : public ::google::protobuf::Message {
 public:
  RemoteOperation();
  virtual ~RemoteOperation();

  RemoteOperation(const RemoteOperation& from);

  inline RemoteOperation& operator=(const RemoteOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteOperation& default_instance();

  void Swap(RemoteOperation* other);

  // implements Message ----------------------------------------------

  RemoteOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteOperation& from);
  void MergeFrom(const RemoteOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 message_timestamp = 1;
  inline bool has_message_timestamp() const;
  inline void clear_message_timestamp();
  static const int kMessageTimestampFieldNumber = 1;
  inline ::google::protobuf::int64 message_timestamp() const;
  inline void set_message_timestamp(::google::protobuf::int64 value);

  // optional .RemoteConfiguration remote_configuration = 2;
  inline bool has_remote_configuration() const;
  inline void clear_remote_configuration();
  static const int kRemoteConfigurationFieldNumber = 2;
  inline const ::RemoteConfiguration& remote_configuration() const;
  inline ::RemoteConfiguration* mutable_remote_configuration();
  inline ::RemoteConfiguration* release_remote_configuration();
  inline void set_allocated_remote_configuration(::RemoteConfiguration* remote_configuration);

  // optional .RemoteControl remote_control = 3;
  inline bool has_remote_control() const;
  inline void clear_remote_control();
  static const int kRemoteControlFieldNumber = 3;
  inline const ::RemoteControl& remote_control() const;
  inline ::RemoteControl* mutable_remote_control();
  inline ::RemoteControl* release_remote_control();
  inline void set_allocated_remote_control(::RemoteControl* remote_control);

  // optional .RemoteUpgrade remote_upgrade = 4;
  inline bool has_remote_upgrade() const;
  inline void clear_remote_upgrade();
  static const int kRemoteUpgradeFieldNumber = 4;
  inline const ::RemoteUpgrade& remote_upgrade() const;
  inline ::RemoteUpgrade* mutable_remote_upgrade();
  inline ::RemoteUpgrade* release_remote_upgrade();
  inline void set_allocated_remote_upgrade(::RemoteUpgrade* remote_upgrade);

  // @@protoc_insertion_point(class_scope:RemoteOperation)
 private:
  inline void set_has_message_timestamp();
  inline void clear_has_message_timestamp();
  inline void set_has_remote_configuration();
  inline void clear_has_remote_configuration();
  inline void set_has_remote_control();
  inline void clear_has_remote_control();
  inline void set_has_remote_upgrade();
  inline void clear_has_remote_upgrade();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 message_timestamp_;
  ::RemoteConfiguration* remote_configuration_;
  ::RemoteControl* remote_control_;
  ::RemoteUpgrade* remote_upgrade_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static RemoteOperation* default_instance_;
};
// -------------------------------------------------------------------

class RemoteConfiguration : public ::google::protobuf::Message {
 public:
  RemoteConfiguration();
  virtual ~RemoteConfiguration();

  RemoteConfiguration(const RemoteConfiguration& from);

  inline RemoteConfiguration& operator=(const RemoteConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteConfiguration& default_instance();

  void Swap(RemoteConfiguration* other);

  // implements Message ----------------------------------------------

  RemoteConfiguration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteConfiguration& from);
  void MergeFrom(const RemoteConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  inline void set_allocated_request_id(::std::string* request_id);

  // repeated .RemoteConfigurationInfo remote_configuration_info = 2;
  inline int remote_configuration_info_size() const;
  inline void clear_remote_configuration_info();
  static const int kRemoteConfigurationInfoFieldNumber = 2;
  inline const ::RemoteConfigurationInfo& remote_configuration_info(int index) const;
  inline ::RemoteConfigurationInfo* mutable_remote_configuration_info(int index);
  inline ::RemoteConfigurationInfo* add_remote_configuration_info();
  inline const ::google::protobuf::RepeatedPtrField< ::RemoteConfigurationInfo >&
      remote_configuration_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::RemoteConfigurationInfo >*
      mutable_remote_configuration_info();

  // @@protoc_insertion_point(class_scope:RemoteConfiguration)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* request_id_;
  ::google::protobuf::RepeatedPtrField< ::RemoteConfigurationInfo > remote_configuration_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static RemoteConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class RemoteConfigurationInfo : public ::google::protobuf::Message {
 public:
  RemoteConfigurationInfo();
  virtual ~RemoteConfigurationInfo();

  RemoteConfigurationInfo(const RemoteConfigurationInfo& from);

  inline RemoteConfigurationInfo& operator=(const RemoteConfigurationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteConfigurationInfo& default_instance();

  void Swap(RemoteConfigurationInfo* other);

  // implements Message ----------------------------------------------

  RemoteConfigurationInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteConfigurationInfo& from);
  void MergeFrom(const RemoteConfigurationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string configuration_key = 1;
  inline bool has_configuration_key() const;
  inline void clear_configuration_key();
  static const int kConfigurationKeyFieldNumber = 1;
  inline const ::std::string& configuration_key() const;
  inline void set_configuration_key(const ::std::string& value);
  inline void set_configuration_key(const char* value);
  inline void set_configuration_key(const char* value, size_t size);
  inline ::std::string* mutable_configuration_key();
  inline ::std::string* release_configuration_key();
  inline void set_allocated_configuration_key(::std::string* configuration_key);

  // optional bytes configuration_value = 2;
  inline bool has_configuration_value() const;
  inline void clear_configuration_value();
  static const int kConfigurationValueFieldNumber = 2;
  inline const ::std::string& configuration_value() const;
  inline void set_configuration_value(const ::std::string& value);
  inline void set_configuration_value(const char* value);
  inline void set_configuration_value(const void* value, size_t size);
  inline ::std::string* mutable_configuration_value();
  inline ::std::string* release_configuration_value();
  inline void set_allocated_configuration_value(::std::string* configuration_value);

  // @@protoc_insertion_point(class_scope:RemoteConfigurationInfo)
 private:
  inline void set_has_configuration_key();
  inline void clear_has_configuration_key();
  inline void set_has_configuration_value();
  inline void clear_has_configuration_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* configuration_key_;
  ::std::string* configuration_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static RemoteConfigurationInfo* default_instance_;
};
// -------------------------------------------------------------------

class RemoteControl : public ::google::protobuf::Message {
 public:
  RemoteControl();
  virtual ~RemoteControl();

  RemoteControl(const RemoteControl& from);

  inline RemoteControl& operator=(const RemoteControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteControl& default_instance();

  void Swap(RemoteControl* other);

  // implements Message ----------------------------------------------

  RemoteControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteControl& from);
  void MergeFrom(const RemoteControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  inline void set_allocated_request_id(::std::string* request_id);

  // optional .RemoteControlCommand remote_control_command = 2;
  inline bool has_remote_control_command() const;
  inline void clear_remote_control_command();
  static const int kRemoteControlCommandFieldNumber = 2;
  inline ::RemoteControlCommand remote_control_command() const;
  inline void set_remote_control_command(::RemoteControlCommand value);

  // repeated .RemoteControlParam remote_control_param = 3;
  inline int remote_control_param_size() const;
  inline void clear_remote_control_param();
  static const int kRemoteControlParamFieldNumber = 3;
  inline const ::RemoteControlParam& remote_control_param(int index) const;
  inline ::RemoteControlParam* mutable_remote_control_param(int index);
  inline ::RemoteControlParam* add_remote_control_param();
  inline const ::google::protobuf::RepeatedPtrField< ::RemoteControlParam >&
      remote_control_param() const;
  inline ::google::protobuf::RepeatedPtrField< ::RemoteControlParam >*
      mutable_remote_control_param();

  // @@protoc_insertion_point(class_scope:RemoteControl)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_remote_control_command();
  inline void clear_has_remote_control_command();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* request_id_;
  ::google::protobuf::RepeatedPtrField< ::RemoteControlParam > remote_control_param_;
  int remote_control_command_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static RemoteControl* default_instance_;
};
// -------------------------------------------------------------------

class RemoteControlParam : public ::google::protobuf::Message {
 public:
  RemoteControlParam();
  virtual ~RemoteControlParam();

  RemoteControlParam(const RemoteControlParam& from);

  inline RemoteControlParam& operator=(const RemoteControlParam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteControlParam& default_instance();

  void Swap(RemoteControlParam* other);

  // implements Message ----------------------------------------------

  RemoteControlParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteControlParam& from);
  void MergeFrom(const RemoteControlParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:RemoteControlParam)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static RemoteControlParam* default_instance_;
};
// -------------------------------------------------------------------

class RemoteUpgrade : public ::google::protobuf::Message {
 public:
  RemoteUpgrade();
  virtual ~RemoteUpgrade();

  RemoteUpgrade(const RemoteUpgrade& from);

  inline RemoteUpgrade& operator=(const RemoteUpgrade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteUpgrade& default_instance();

  void Swap(RemoteUpgrade* other);

  // implements Message ----------------------------------------------

  RemoteUpgrade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteUpgrade& from);
  void MergeFrom(const RemoteUpgrade& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  inline void set_allocated_request_id(::std::string* request_id);

  // optional string software_version = 2;
  inline bool has_software_version() const;
  inline void clear_software_version();
  static const int kSoftwareVersionFieldNumber = 2;
  inline const ::std::string& software_version() const;
  inline void set_software_version(const ::std::string& value);
  inline void set_software_version(const char* value);
  inline void set_software_version(const char* value, size_t size);
  inline ::std::string* mutable_software_version();
  inline ::std::string* release_software_version();
  inline void set_allocated_software_version(::std::string* software_version);

  // optional string ftp_address = 3;
  inline bool has_ftp_address() const;
  inline void clear_ftp_address();
  static const int kFtpAddressFieldNumber = 3;
  inline const ::std::string& ftp_address() const;
  inline void set_ftp_address(const ::std::string& value);
  inline void set_ftp_address(const char* value);
  inline void set_ftp_address(const char* value, size_t size);
  inline ::std::string* mutable_ftp_address();
  inline ::std::string* release_ftp_address();
  inline void set_allocated_ftp_address(::std::string* ftp_address);

  // @@protoc_insertion_point(class_scope:RemoteUpgrade)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_software_version();
  inline void clear_has_software_version();
  inline void set_has_ftp_address();
  inline void clear_has_ftp_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* request_id_;
  ::std::string* software_version_;
  ::std::string* ftp_address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static RemoteUpgrade* default_instance_;
};
// -------------------------------------------------------------------

class RemoteOperationResponse : public ::google::protobuf::Message {
 public:
  RemoteOperationResponse();
  virtual ~RemoteOperationResponse();

  RemoteOperationResponse(const RemoteOperationResponse& from);

  inline RemoteOperationResponse& operator=(const RemoteOperationResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteOperationResponse& default_instance();

  void Swap(RemoteOperationResponse* other);

  // implements Message ----------------------------------------------

  RemoteOperationResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteOperationResponse& from);
  void MergeFrom(const RemoteOperationResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .RemoteConfigurationResponse remote_configuration_response = 1;
  inline bool has_remote_configuration_response() const;
  inline void clear_remote_configuration_response();
  static const int kRemoteConfigurationResponseFieldNumber = 1;
  inline const ::RemoteConfigurationResponse& remote_configuration_response() const;
  inline ::RemoteConfigurationResponse* mutable_remote_configuration_response();
  inline ::RemoteConfigurationResponse* release_remote_configuration_response();
  inline void set_allocated_remote_configuration_response(::RemoteConfigurationResponse* remote_configuration_response);

  // optional .RemoteControlResponse remote_control_response = 2;
  inline bool has_remote_control_response() const;
  inline void clear_remote_control_response();
  static const int kRemoteControlResponseFieldNumber = 2;
  inline const ::RemoteControlResponse& remote_control_response() const;
  inline ::RemoteControlResponse* mutable_remote_control_response();
  inline ::RemoteControlResponse* release_remote_control_response();
  inline void set_allocated_remote_control_response(::RemoteControlResponse* remote_control_response);

  // optional .RemoteUpgradeResponse remote_upgrade_response = 3;
  inline bool has_remote_upgrade_response() const;
  inline void clear_remote_upgrade_response();
  static const int kRemoteUpgradeResponseFieldNumber = 3;
  inline const ::RemoteUpgradeResponse& remote_upgrade_response() const;
  inline ::RemoteUpgradeResponse* mutable_remote_upgrade_response();
  inline ::RemoteUpgradeResponse* release_remote_upgrade_response();
  inline void set_allocated_remote_upgrade_response(::RemoteUpgradeResponse* remote_upgrade_response);

  // @@protoc_insertion_point(class_scope:RemoteOperationResponse)
 private:
  inline void set_has_remote_configuration_response();
  inline void clear_has_remote_configuration_response();
  inline void set_has_remote_control_response();
  inline void clear_has_remote_control_response();
  inline void set_has_remote_upgrade_response();
  inline void clear_has_remote_upgrade_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::RemoteConfigurationResponse* remote_configuration_response_;
  ::RemoteControlResponse* remote_control_response_;
  ::RemoteUpgradeResponse* remote_upgrade_response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static RemoteOperationResponse* default_instance_;
};
// -------------------------------------------------------------------

class RemoteConfigurationResponse : public ::google::protobuf::Message {
 public:
  RemoteConfigurationResponse();
  virtual ~RemoteConfigurationResponse();

  RemoteConfigurationResponse(const RemoteConfigurationResponse& from);

  inline RemoteConfigurationResponse& operator=(const RemoteConfigurationResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteConfigurationResponse& default_instance();

  void Swap(RemoteConfigurationResponse* other);

  // implements Message ----------------------------------------------

  RemoteConfigurationResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteConfigurationResponse& from);
  void MergeFrom(const RemoteConfigurationResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  inline void set_allocated_request_id(::std::string* request_id);

  // optional string device_id = 2;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 2;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional .RemoteConfigurationResponseType remote_configuration_response_type = 3;
  inline bool has_remote_configuration_response_type() const;
  inline void clear_remote_configuration_response_type();
  static const int kRemoteConfigurationResponseTypeFieldNumber = 3;
  inline ::RemoteConfigurationResponseType remote_configuration_response_type() const;
  inline void set_remote_configuration_response_type(::RemoteConfigurationResponseType value);

  // optional string failureReason = 4;
  inline bool has_failurereason() const;
  inline void clear_failurereason();
  static const int kFailureReasonFieldNumber = 4;
  inline const ::std::string& failurereason() const;
  inline void set_failurereason(const ::std::string& value);
  inline void set_failurereason(const char* value);
  inline void set_failurereason(const char* value, size_t size);
  inline ::std::string* mutable_failurereason();
  inline ::std::string* release_failurereason();
  inline void set_allocated_failurereason(::std::string* failurereason);

  // repeated .LocalConfigurationInfo configuration_info = 5;
  inline int configuration_info_size() const;
  inline void clear_configuration_info();
  static const int kConfigurationInfoFieldNumber = 5;
  inline const ::LocalConfigurationInfo& configuration_info(int index) const;
  inline ::LocalConfigurationInfo* mutable_configuration_info(int index);
  inline ::LocalConfigurationInfo* add_configuration_info();
  inline const ::google::protobuf::RepeatedPtrField< ::LocalConfigurationInfo >&
      configuration_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::LocalConfigurationInfo >*
      mutable_configuration_info();

  // @@protoc_insertion_point(class_scope:RemoteConfigurationResponse)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_remote_configuration_response_type();
  inline void clear_has_remote_configuration_response_type();
  inline void set_has_failurereason();
  inline void clear_has_failurereason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* request_id_;
  ::std::string* device_id_;
  ::std::string* failurereason_;
  ::google::protobuf::RepeatedPtrField< ::LocalConfigurationInfo > configuration_info_;
  int remote_configuration_response_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static RemoteConfigurationResponse* default_instance_;
};
// -------------------------------------------------------------------

class RemoteControlResponse : public ::google::protobuf::Message {
 public:
  RemoteControlResponse();
  virtual ~RemoteControlResponse();

  RemoteControlResponse(const RemoteControlResponse& from);

  inline RemoteControlResponse& operator=(const RemoteControlResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteControlResponse& default_instance();

  void Swap(RemoteControlResponse* other);

  // implements Message ----------------------------------------------

  RemoteControlResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteControlResponse& from);
  void MergeFrom(const RemoteControlResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  inline void set_allocated_request_id(::std::string* request_id);

  // optional string device_id = 2;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 2;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional .RemoteControlResponseType remote_control_response_type = 3;
  inline bool has_remote_control_response_type() const;
  inline void clear_remote_control_response_type();
  static const int kRemoteControlResponseTypeFieldNumber = 3;
  inline ::RemoteControlResponseType remote_control_response_type() const;
  inline void set_remote_control_response_type(::RemoteControlResponseType value);

  // optional string failureReason = 4;
  inline bool has_failurereason() const;
  inline void clear_failurereason();
  static const int kFailureReasonFieldNumber = 4;
  inline const ::std::string& failurereason() const;
  inline void set_failurereason(const ::std::string& value);
  inline void set_failurereason(const char* value);
  inline void set_failurereason(const char* value, size_t size);
  inline ::std::string* mutable_failurereason();
  inline ::std::string* release_failurereason();
  inline void set_allocated_failurereason(::std::string* failurereason);

  // @@protoc_insertion_point(class_scope:RemoteControlResponse)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_remote_control_response_type();
  inline void clear_has_remote_control_response_type();
  inline void set_has_failurereason();
  inline void clear_has_failurereason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* request_id_;
  ::std::string* device_id_;
  ::std::string* failurereason_;
  int remote_control_response_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static RemoteControlResponse* default_instance_;
};
// -------------------------------------------------------------------

class RemoteUpgradeResponse : public ::google::protobuf::Message {
 public:
  RemoteUpgradeResponse();
  virtual ~RemoteUpgradeResponse();

  RemoteUpgradeResponse(const RemoteUpgradeResponse& from);

  inline RemoteUpgradeResponse& operator=(const RemoteUpgradeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteUpgradeResponse& default_instance();

  void Swap(RemoteUpgradeResponse* other);

  // implements Message ----------------------------------------------

  RemoteUpgradeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteUpgradeResponse& from);
  void MergeFrom(const RemoteUpgradeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  inline void set_allocated_request_id(::std::string* request_id);

  // optional string device_id = 2;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 2;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // @@protoc_insertion_point(class_scope:RemoteUpgradeResponse)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_device_id();
  inline void clear_has_device_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* request_id_;
  ::std::string* device_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messageall_2eproto();
  friend void protobuf_AssignDesc_messageall_2eproto();
  friend void protobuf_ShutdownFile_messageall_2eproto();

  void InitAsDefaultInstance();
  static RemoteUpgradeResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Message_ParamType

// optional string key = 1;
inline bool Message_ParamType::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_ParamType::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_ParamType::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_ParamType::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Message_ParamType::key() const {
  return *key_;
}
inline void Message_ParamType::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Message_ParamType::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Message_ParamType::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_ParamType::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Message_ParamType::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message_ParamType::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes value = 2;
inline bool Message_ParamType::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_ParamType::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_ParamType::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_ParamType::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Message_ParamType::value() const {
  return *value_;
}
inline void Message_ParamType::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Message_ParamType::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Message_ParamType::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_ParamType::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Message_ParamType::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message_ParamType::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Message

// optional int32 version = 1;
inline bool Message::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 Message::version() const {
  return version_;
}
inline void Message::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional string id = 2;
inline bool Message::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Message::id() const {
  return *id_;
}
inline void Message::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Message::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Message::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Message::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 publish_ts = 3;
inline bool Message::has_publish_ts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_publish_ts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_publish_ts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_publish_ts() {
  publish_ts_ = GOOGLE_LONGLONG(0);
  clear_has_publish_ts();
}
inline ::google::protobuf::int64 Message::publish_ts() const {
  return publish_ts_;
}
inline void Message::set_publish_ts(::google::protobuf::int64 value) {
  set_has_publish_ts();
  publish_ts_ = value;
}

// optional int64 ttl = 4;
inline bool Message::has_ttl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_ttl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_ttl() {
  ttl_ = GOOGLE_LONGLONG(0);
  clear_has_ttl();
}
inline ::google::protobuf::int64 Message::ttl() const {
  return ttl_;
}
inline void Message::set_ttl(::google::protobuf::int64 value) {
  set_has_ttl();
  ttl_ = value;
}

// optional .Message.MessageType type = 5;
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Message_MessageType Message::type() const {
  return static_cast< ::Message_MessageType >(type_);
}
inline void Message::set_type(::Message_MessageType value) {
  assert(::Message_MessageType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string sub_type = 6;
inline bool Message::has_sub_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_sub_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_sub_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_sub_type() {
  if (sub_type_ != &::google::protobuf::internal::kEmptyString) {
    sub_type_->clear();
  }
  clear_has_sub_type();
}
inline const ::std::string& Message::sub_type() const {
  return *sub_type_;
}
inline void Message::set_sub_type(const ::std::string& value) {
  set_has_sub_type();
  if (sub_type_ == &::google::protobuf::internal::kEmptyString) {
    sub_type_ = new ::std::string;
  }
  sub_type_->assign(value);
}
inline void Message::set_sub_type(const char* value) {
  set_has_sub_type();
  if (sub_type_ == &::google::protobuf::internal::kEmptyString) {
    sub_type_ = new ::std::string;
  }
  sub_type_->assign(value);
}
inline void Message::set_sub_type(const char* value, size_t size) {
  set_has_sub_type();
  if (sub_type_ == &::google::protobuf::internal::kEmptyString) {
    sub_type_ = new ::std::string;
  }
  sub_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_sub_type() {
  set_has_sub_type();
  if (sub_type_ == &::google::protobuf::internal::kEmptyString) {
    sub_type_ = new ::std::string;
  }
  return sub_type_;
}
inline ::std::string* Message::release_sub_type() {
  clear_has_sub_type();
  if (sub_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sub_type_;
    sub_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_sub_type(::std::string* sub_type) {
  if (sub_type_ != &::google::protobuf::internal::kEmptyString) {
    delete sub_type_;
  }
  if (sub_type) {
    set_has_sub_type();
    sub_type_ = sub_type;
  } else {
    clear_has_sub_type();
    sub_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Message.ParamType params = 7;
inline int Message::params_size() const {
  return params_.size();
}
inline void Message::clear_params() {
  params_.Clear();
}
inline const ::Message_ParamType& Message::params(int index) const {
  return params_.Get(index);
}
inline ::Message_ParamType* Message::mutable_params(int index) {
  return params_.Mutable(index);
}
inline ::Message_ParamType* Message::add_params() {
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Message_ParamType >&
Message::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::Message_ParamType >*
Message::mutable_params() {
  return &params_;
}

// -------------------------------------------------------------------

// ACPowerCharger_BasicInfo

// optional .CommonBasicInfo common_basic_info = 1;
inline bool ACPowerCharger_BasicInfo::has_common_basic_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACPowerCharger_BasicInfo::set_has_common_basic_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACPowerCharger_BasicInfo::clear_has_common_basic_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACPowerCharger_BasicInfo::clear_common_basic_info() {
  if (common_basic_info_ != NULL) common_basic_info_->::CommonBasicInfo::Clear();
  clear_has_common_basic_info();
}
inline const ::CommonBasicInfo& ACPowerCharger_BasicInfo::common_basic_info() const {
  return common_basic_info_ != NULL ? *common_basic_info_ : *default_instance_->common_basic_info_;
}
inline ::CommonBasicInfo* ACPowerCharger_BasicInfo::mutable_common_basic_info() {
  set_has_common_basic_info();
  if (common_basic_info_ == NULL) common_basic_info_ = new ::CommonBasicInfo;
  return common_basic_info_;
}
inline ::CommonBasicInfo* ACPowerCharger_BasicInfo::release_common_basic_info() {
  clear_has_common_basic_info();
  ::CommonBasicInfo* temp = common_basic_info_;
  common_basic_info_ = NULL;
  return temp;
}
inline void ACPowerCharger_BasicInfo::set_allocated_common_basic_info(::CommonBasicInfo* common_basic_info) {
  delete common_basic_info_;
  common_basic_info_ = common_basic_info;
  if (common_basic_info) {
    set_has_common_basic_info();
  } else {
    clear_has_common_basic_info();
  }
}

// optional .ACPowerCharger.PowerChargerType power_charger_type = 2;
inline bool ACPowerCharger_BasicInfo::has_power_charger_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACPowerCharger_BasicInfo::set_has_power_charger_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACPowerCharger_BasicInfo::clear_has_power_charger_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACPowerCharger_BasicInfo::clear_power_charger_type() {
  power_charger_type_ = 0;
  clear_has_power_charger_type();
}
inline ::ACPowerCharger_PowerChargerType ACPowerCharger_BasicInfo::power_charger_type() const {
  return static_cast< ::ACPowerCharger_PowerChargerType >(power_charger_type_);
}
inline void ACPowerCharger_BasicInfo::set_power_charger_type(::ACPowerCharger_PowerChargerType value) {
  assert(::ACPowerCharger_PowerChargerType_IsValid(value));
  set_has_power_charger_type();
  power_charger_type_ = value;
}

// optional int32 charging_connector_quantity = 3;
inline bool ACPowerCharger_BasicInfo::has_charging_connector_quantity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACPowerCharger_BasicInfo::set_has_charging_connector_quantity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACPowerCharger_BasicInfo::clear_has_charging_connector_quantity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACPowerCharger_BasicInfo::clear_charging_connector_quantity() {
  charging_connector_quantity_ = 0;
  clear_has_charging_connector_quantity();
}
inline ::google::protobuf::int32 ACPowerCharger_BasicInfo::charging_connector_quantity() const {
  return charging_connector_quantity_;
}
inline void ACPowerCharger_BasicInfo::set_charging_connector_quantity(::google::protobuf::int32 value) {
  set_has_charging_connector_quantity();
  charging_connector_quantity_ = value;
}

// optional float power = 4;
inline bool ACPowerCharger_BasicInfo::has_power() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACPowerCharger_BasicInfo::set_has_power() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACPowerCharger_BasicInfo::clear_has_power() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACPowerCharger_BasicInfo::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline float ACPowerCharger_BasicInfo::power() const {
  return power_;
}
inline void ACPowerCharger_BasicInfo::set_power(float value) {
  set_has_power();
  power_ = value;
}

// -------------------------------------------------------------------

// ACPowerCharger_RealtimeInfo

// optional .ConnectivityState connectivity_state = 1;
inline bool ACPowerCharger_RealtimeInfo::has_connectivity_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACPowerCharger_RealtimeInfo::set_has_connectivity_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACPowerCharger_RealtimeInfo::clear_has_connectivity_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACPowerCharger_RealtimeInfo::clear_connectivity_state() {
  if (connectivity_state_ != NULL) connectivity_state_->::ConnectivityState::Clear();
  clear_has_connectivity_state();
}
inline const ::ConnectivityState& ACPowerCharger_RealtimeInfo::connectivity_state() const {
  return connectivity_state_ != NULL ? *connectivity_state_ : *default_instance_->connectivity_state_;
}
inline ::ConnectivityState* ACPowerCharger_RealtimeInfo::mutable_connectivity_state() {
  set_has_connectivity_state();
  if (connectivity_state_ == NULL) connectivity_state_ = new ::ConnectivityState;
  return connectivity_state_;
}
inline ::ConnectivityState* ACPowerCharger_RealtimeInfo::release_connectivity_state() {
  clear_has_connectivity_state();
  ::ConnectivityState* temp = connectivity_state_;
  connectivity_state_ = NULL;
  return temp;
}
inline void ACPowerCharger_RealtimeInfo::set_allocated_connectivity_state(::ConnectivityState* connectivity_state) {
  delete connectivity_state_;
  connectivity_state_ = connectivity_state;
  if (connectivity_state) {
    set_has_connectivity_state();
  } else {
    clear_has_connectivity_state();
  }
}

// optional .ACPowerCharger.DeviceWorkState device_work_state = 2;
inline bool ACPowerCharger_RealtimeInfo::has_device_work_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACPowerCharger_RealtimeInfo::set_has_device_work_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACPowerCharger_RealtimeInfo::clear_has_device_work_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACPowerCharger_RealtimeInfo::clear_device_work_state() {
  device_work_state_ = 0;
  clear_has_device_work_state();
}
inline ::ACPowerCharger_DeviceWorkState ACPowerCharger_RealtimeInfo::device_work_state() const {
  return static_cast< ::ACPowerCharger_DeviceWorkState >(device_work_state_);
}
inline void ACPowerCharger_RealtimeInfo::set_device_work_state(::ACPowerCharger_DeviceWorkState value) {
  assert(::ACPowerCharger_DeviceWorkState_IsValid(value));
  set_has_device_work_state();
  device_work_state_ = value;
}

// repeated .ChargingConnector charging_connector = 4;
inline int ACPowerCharger_RealtimeInfo::charging_connector_size() const {
  return charging_connector_.size();
}
inline void ACPowerCharger_RealtimeInfo::clear_charging_connector() {
  charging_connector_.Clear();
}
inline const ::ChargingConnector& ACPowerCharger_RealtimeInfo::charging_connector(int index) const {
  return charging_connector_.Get(index);
}
inline ::ChargingConnector* ACPowerCharger_RealtimeInfo::mutable_charging_connector(int index) {
  return charging_connector_.Mutable(index);
}
inline ::ChargingConnector* ACPowerCharger_RealtimeInfo::add_charging_connector() {
  return charging_connector_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ChargingConnector >&
ACPowerCharger_RealtimeInfo::charging_connector() const {
  return charging_connector_;
}
inline ::google::protobuf::RepeatedPtrField< ::ChargingConnector >*
ACPowerCharger_RealtimeInfo::mutable_charging_connector() {
  return &charging_connector_;
}

// -------------------------------------------------------------------

// ACPowerCharger_ServiceInfo

// optional string service_id = 1;
inline bool ACPowerCharger_ServiceInfo::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACPowerCharger_ServiceInfo::clear_service_id() {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    service_id_->clear();
  }
  clear_has_service_id();
}
inline const ::std::string& ACPowerCharger_ServiceInfo::service_id() const {
  return *service_id_;
}
inline void ACPowerCharger_ServiceInfo::set_service_id(const ::std::string& value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void ACPowerCharger_ServiceInfo::set_service_id(const char* value) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(value);
}
inline void ACPowerCharger_ServiceInfo::set_service_id(const char* value, size_t size) {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  service_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACPowerCharger_ServiceInfo::mutable_service_id() {
  set_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    service_id_ = new ::std::string;
  }
  return service_id_;
}
inline ::std::string* ACPowerCharger_ServiceInfo::release_service_id() {
  clear_has_service_id();
  if (service_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = service_id_;
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACPowerCharger_ServiceInfo::set_allocated_service_id(::std::string* service_id) {
  if (service_id_ != &::google::protobuf::internal::kEmptyString) {
    delete service_id_;
  }
  if (service_id) {
    set_has_service_id();
    service_id_ = service_id;
  } else {
    clear_has_service_id();
    service_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .ServiceEvent service_event = 2;
inline bool ACPowerCharger_ServiceInfo::has_service_event() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_service_event() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_service_event() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACPowerCharger_ServiceInfo::clear_service_event() {
  service_event_ = 0;
  clear_has_service_event();
}
inline ::ServiceEvent ACPowerCharger_ServiceInfo::service_event() const {
  return static_cast< ::ServiceEvent >(service_event_);
}
inline void ACPowerCharger_ServiceInfo::set_service_event(::ServiceEvent value) {
  assert(::ServiceEvent_IsValid(value));
  set_has_service_event();
  service_event_ = value;
}

// optional int64 charging_event_timestamp = 3;
inline bool ACPowerCharger_ServiceInfo::has_charging_event_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_charging_event_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_charging_event_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACPowerCharger_ServiceInfo::clear_charging_event_timestamp() {
  charging_event_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_charging_event_timestamp();
}
inline ::google::protobuf::int64 ACPowerCharger_ServiceInfo::charging_event_timestamp() const {
  return charging_event_timestamp_;
}
inline void ACPowerCharger_ServiceInfo::set_charging_event_timestamp(::google::protobuf::int64 value) {
  set_has_charging_event_timestamp();
  charging_event_timestamp_ = value;
}

// optional string charging_connector_id = 4;
inline bool ACPowerCharger_ServiceInfo::has_charging_connector_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_charging_connector_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_charging_connector_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACPowerCharger_ServiceInfo::clear_charging_connector_id() {
  if (charging_connector_id_ != &::google::protobuf::internal::kEmptyString) {
    charging_connector_id_->clear();
  }
  clear_has_charging_connector_id();
}
inline const ::std::string& ACPowerCharger_ServiceInfo::charging_connector_id() const {
  return *charging_connector_id_;
}
inline void ACPowerCharger_ServiceInfo::set_charging_connector_id(const ::std::string& value) {
  set_has_charging_connector_id();
  if (charging_connector_id_ == &::google::protobuf::internal::kEmptyString) {
    charging_connector_id_ = new ::std::string;
  }
  charging_connector_id_->assign(value);
}
inline void ACPowerCharger_ServiceInfo::set_charging_connector_id(const char* value) {
  set_has_charging_connector_id();
  if (charging_connector_id_ == &::google::protobuf::internal::kEmptyString) {
    charging_connector_id_ = new ::std::string;
  }
  charging_connector_id_->assign(value);
}
inline void ACPowerCharger_ServiceInfo::set_charging_connector_id(const char* value, size_t size) {
  set_has_charging_connector_id();
  if (charging_connector_id_ == &::google::protobuf::internal::kEmptyString) {
    charging_connector_id_ = new ::std::string;
  }
  charging_connector_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACPowerCharger_ServiceInfo::mutable_charging_connector_id() {
  set_has_charging_connector_id();
  if (charging_connector_id_ == &::google::protobuf::internal::kEmptyString) {
    charging_connector_id_ = new ::std::string;
  }
  return charging_connector_id_;
}
inline ::std::string* ACPowerCharger_ServiceInfo::release_charging_connector_id() {
  clear_has_charging_connector_id();
  if (charging_connector_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charging_connector_id_;
    charging_connector_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACPowerCharger_ServiceInfo::set_allocated_charging_connector_id(::std::string* charging_connector_id) {
  if (charging_connector_id_ != &::google::protobuf::internal::kEmptyString) {
    delete charging_connector_id_;
  }
  if (charging_connector_id) {
    set_has_charging_connector_id();
    charging_connector_id_ = charging_connector_id;
  } else {
    clear_has_charging_connector_id();
    charging_connector_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float realtime_charged_energy = 5;
inline bool ACPowerCharger_ServiceInfo::has_realtime_charged_energy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_realtime_charged_energy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_realtime_charged_energy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACPowerCharger_ServiceInfo::clear_realtime_charged_energy() {
  realtime_charged_energy_ = 0;
  clear_has_realtime_charged_energy();
}
inline float ACPowerCharger_ServiceInfo::realtime_charged_energy() const {
  return realtime_charged_energy_;
}
inline void ACPowerCharger_ServiceInfo::set_realtime_charged_energy(float value) {
  set_has_realtime_charged_energy();
  realtime_charged_energy_ = value;
}

// optional .ServiceFinishResult service_finish_result = 6;
inline bool ACPowerCharger_ServiceInfo::has_service_finish_result() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_service_finish_result() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_service_finish_result() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ACPowerCharger_ServiceInfo::clear_service_finish_result() {
  service_finish_result_ = 0;
  clear_has_service_finish_result();
}
inline ::ServiceFinishResult ACPowerCharger_ServiceInfo::service_finish_result() const {
  return static_cast< ::ServiceFinishResult >(service_finish_result_);
}
inline void ACPowerCharger_ServiceInfo::set_service_finish_result(::ServiceFinishResult value) {
  assert(::ServiceFinishResult_IsValid(value));
  set_has_service_finish_result();
  service_finish_result_ = value;
}

// optional float charged_energy_total = 7;
inline bool ACPowerCharger_ServiceInfo::has_charged_energy_total() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_charged_energy_total() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_charged_energy_total() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ACPowerCharger_ServiceInfo::clear_charged_energy_total() {
  charged_energy_total_ = 0;
  clear_has_charged_energy_total();
}
inline float ACPowerCharger_ServiceInfo::charged_energy_total() const {
  return charged_energy_total_;
}
inline void ACPowerCharger_ServiceInfo::set_charged_energy_total(float value) {
  set_has_charged_energy_total();
  charged_energy_total_ = value;
}

// -------------------------------------------------------------------

// ACPowerCharger

// optional string device_id = 1;
inline bool ACPowerCharger::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACPowerCharger::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACPowerCharger::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACPowerCharger::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ACPowerCharger::device_id() const {
  return *device_id_;
}
inline void ACPowerCharger::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ACPowerCharger::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ACPowerCharger::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACPowerCharger::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ACPowerCharger::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACPowerCharger::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 message_timestamp = 2;
inline bool ACPowerCharger::has_message_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACPowerCharger::set_has_message_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACPowerCharger::clear_has_message_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACPowerCharger::clear_message_timestamp() {
  message_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_message_timestamp();
}
inline ::google::protobuf::int64 ACPowerCharger::message_timestamp() const {
  return message_timestamp_;
}
inline void ACPowerCharger::set_message_timestamp(::google::protobuf::int64 value) {
  set_has_message_timestamp();
  message_timestamp_ = value;
}

// optional .ACPowerCharger.BasicInfo basicInfo = 3;
inline bool ACPowerCharger::has_basicinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACPowerCharger::set_has_basicinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACPowerCharger::clear_has_basicinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACPowerCharger::clear_basicinfo() {
  if (basicinfo_ != NULL) basicinfo_->::ACPowerCharger_BasicInfo::Clear();
  clear_has_basicinfo();
}
inline const ::ACPowerCharger_BasicInfo& ACPowerCharger::basicinfo() const {
  return basicinfo_ != NULL ? *basicinfo_ : *default_instance_->basicinfo_;
}
inline ::ACPowerCharger_BasicInfo* ACPowerCharger::mutable_basicinfo() {
  set_has_basicinfo();
  if (basicinfo_ == NULL) basicinfo_ = new ::ACPowerCharger_BasicInfo;
  return basicinfo_;
}
inline ::ACPowerCharger_BasicInfo* ACPowerCharger::release_basicinfo() {
  clear_has_basicinfo();
  ::ACPowerCharger_BasicInfo* temp = basicinfo_;
  basicinfo_ = NULL;
  return temp;
}
inline void ACPowerCharger::set_allocated_basicinfo(::ACPowerCharger_BasicInfo* basicinfo) {
  delete basicinfo_;
  basicinfo_ = basicinfo;
  if (basicinfo) {
    set_has_basicinfo();
  } else {
    clear_has_basicinfo();
  }
}

// optional .ACPowerCharger.RealtimeInfo realtime_info = 4;
inline bool ACPowerCharger::has_realtime_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACPowerCharger::set_has_realtime_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACPowerCharger::clear_has_realtime_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACPowerCharger::clear_realtime_info() {
  if (realtime_info_ != NULL) realtime_info_->::ACPowerCharger_RealtimeInfo::Clear();
  clear_has_realtime_info();
}
inline const ::ACPowerCharger_RealtimeInfo& ACPowerCharger::realtime_info() const {
  return realtime_info_ != NULL ? *realtime_info_ : *default_instance_->realtime_info_;
}
inline ::ACPowerCharger_RealtimeInfo* ACPowerCharger::mutable_realtime_info() {
  set_has_realtime_info();
  if (realtime_info_ == NULL) realtime_info_ = new ::ACPowerCharger_RealtimeInfo;
  return realtime_info_;
}
inline ::ACPowerCharger_RealtimeInfo* ACPowerCharger::release_realtime_info() {
  clear_has_realtime_info();
  ::ACPowerCharger_RealtimeInfo* temp = realtime_info_;
  realtime_info_ = NULL;
  return temp;
}
inline void ACPowerCharger::set_allocated_realtime_info(::ACPowerCharger_RealtimeInfo* realtime_info) {
  delete realtime_info_;
  realtime_info_ = realtime_info;
  if (realtime_info) {
    set_has_realtime_info();
  } else {
    clear_has_realtime_info();
  }
}

// repeated .Alarm alarms = 5;
inline int ACPowerCharger::alarms_size() const {
  return alarms_.size();
}
inline void ACPowerCharger::clear_alarms() {
  alarms_.Clear();
}
inline const ::Alarm& ACPowerCharger::alarms(int index) const {
  return alarms_.Get(index);
}
inline ::Alarm* ACPowerCharger::mutable_alarms(int index) {
  return alarms_.Mutable(index);
}
inline ::Alarm* ACPowerCharger::add_alarms() {
  return alarms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Alarm >&
ACPowerCharger::alarms() const {
  return alarms_;
}
inline ::google::protobuf::RepeatedPtrField< ::Alarm >*
ACPowerCharger::mutable_alarms() {
  return &alarms_;
}

// repeated .ACPowerCharger.ServiceInfo service_info = 6;
inline int ACPowerCharger::service_info_size() const {
  return service_info_.size();
}
inline void ACPowerCharger::clear_service_info() {
  service_info_.Clear();
}
inline const ::ACPowerCharger_ServiceInfo& ACPowerCharger::service_info(int index) const {
  return service_info_.Get(index);
}
inline ::ACPowerCharger_ServiceInfo* ACPowerCharger::mutable_service_info(int index) {
  return service_info_.Mutable(index);
}
inline ::ACPowerCharger_ServiceInfo* ACPowerCharger::add_service_info() {
  return service_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ACPowerCharger_ServiceInfo >&
ACPowerCharger::service_info() const {
  return service_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ACPowerCharger_ServiceInfo >*
ACPowerCharger::mutable_service_info() {
  return &service_info_;
}

// optional .LocalConfiguration local_configuration = 7;
inline bool ACPowerCharger::has_local_configuration() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ACPowerCharger::set_has_local_configuration() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ACPowerCharger::clear_has_local_configuration() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ACPowerCharger::clear_local_configuration() {
  if (local_configuration_ != NULL) local_configuration_->::LocalConfiguration::Clear();
  clear_has_local_configuration();
}
inline const ::LocalConfiguration& ACPowerCharger::local_configuration() const {
  return local_configuration_ != NULL ? *local_configuration_ : *default_instance_->local_configuration_;
}
inline ::LocalConfiguration* ACPowerCharger::mutable_local_configuration() {
  set_has_local_configuration();
  if (local_configuration_ == NULL) local_configuration_ = new ::LocalConfiguration;
  return local_configuration_;
}
inline ::LocalConfiguration* ACPowerCharger::release_local_configuration() {
  clear_has_local_configuration();
  ::LocalConfiguration* temp = local_configuration_;
  local_configuration_ = NULL;
  return temp;
}
inline void ACPowerCharger::set_allocated_local_configuration(::LocalConfiguration* local_configuration) {
  delete local_configuration_;
  local_configuration_ = local_configuration;
  if (local_configuration) {
    set_has_local_configuration();
  } else {
    clear_has_local_configuration();
  }
}

// -------------------------------------------------------------------

// CommonBasicInfo

// optional string software_version = 1;
inline bool CommonBasicInfo::has_software_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonBasicInfo::set_has_software_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonBasicInfo::clear_has_software_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonBasicInfo::clear_software_version() {
  if (software_version_ != &::google::protobuf::internal::kEmptyString) {
    software_version_->clear();
  }
  clear_has_software_version();
}
inline const ::std::string& CommonBasicInfo::software_version() const {
  return *software_version_;
}
inline void CommonBasicInfo::set_software_version(const ::std::string& value) {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::kEmptyString) {
    software_version_ = new ::std::string;
  }
  software_version_->assign(value);
}
inline void CommonBasicInfo::set_software_version(const char* value) {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::kEmptyString) {
    software_version_ = new ::std::string;
  }
  software_version_->assign(value);
}
inline void CommonBasicInfo::set_software_version(const char* value, size_t size) {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::kEmptyString) {
    software_version_ = new ::std::string;
  }
  software_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonBasicInfo::mutable_software_version() {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::kEmptyString) {
    software_version_ = new ::std::string;
  }
  return software_version_;
}
inline ::std::string* CommonBasicInfo::release_software_version() {
  clear_has_software_version();
  if (software_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = software_version_;
    software_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonBasicInfo::set_allocated_software_version(::std::string* software_version) {
  if (software_version_ != &::google::protobuf::internal::kEmptyString) {
    delete software_version_;
  }
  if (software_version) {
    set_has_software_version();
    software_version_ = software_version;
  } else {
    clear_has_software_version();
    software_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string hardware_version = 2;
inline bool CommonBasicInfo::has_hardware_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonBasicInfo::set_has_hardware_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonBasicInfo::clear_has_hardware_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonBasicInfo::clear_hardware_version() {
  if (hardware_version_ != &::google::protobuf::internal::kEmptyString) {
    hardware_version_->clear();
  }
  clear_has_hardware_version();
}
inline const ::std::string& CommonBasicInfo::hardware_version() const {
  return *hardware_version_;
}
inline void CommonBasicInfo::set_hardware_version(const ::std::string& value) {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::kEmptyString) {
    hardware_version_ = new ::std::string;
  }
  hardware_version_->assign(value);
}
inline void CommonBasicInfo::set_hardware_version(const char* value) {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::kEmptyString) {
    hardware_version_ = new ::std::string;
  }
  hardware_version_->assign(value);
}
inline void CommonBasicInfo::set_hardware_version(const char* value, size_t size) {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::kEmptyString) {
    hardware_version_ = new ::std::string;
  }
  hardware_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonBasicInfo::mutable_hardware_version() {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::kEmptyString) {
    hardware_version_ = new ::std::string;
  }
  return hardware_version_;
}
inline ::std::string* CommonBasicInfo::release_hardware_version() {
  clear_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hardware_version_;
    hardware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonBasicInfo::set_allocated_hardware_version(::std::string* hardware_version) {
  if (hardware_version_ != &::google::protobuf::internal::kEmptyString) {
    delete hardware_version_;
  }
  if (hardware_version) {
    set_has_hardware_version();
    hardware_version_ = hardware_version;
  } else {
    clear_has_hardware_version();
    hardware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .ServiceStateInfo service_state_info = 3;
inline bool CommonBasicInfo::has_service_state_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonBasicInfo::set_has_service_state_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonBasicInfo::clear_has_service_state_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonBasicInfo::clear_service_state_info() {
  if (service_state_info_ != NULL) service_state_info_->::ServiceStateInfo::Clear();
  clear_has_service_state_info();
}
inline const ::ServiceStateInfo& CommonBasicInfo::service_state_info() const {
  return service_state_info_ != NULL ? *service_state_info_ : *default_instance_->service_state_info_;
}
inline ::ServiceStateInfo* CommonBasicInfo::mutable_service_state_info() {
  set_has_service_state_info();
  if (service_state_info_ == NULL) service_state_info_ = new ::ServiceStateInfo;
  return service_state_info_;
}
inline ::ServiceStateInfo* CommonBasicInfo::release_service_state_info() {
  clear_has_service_state_info();
  ::ServiceStateInfo* temp = service_state_info_;
  service_state_info_ = NULL;
  return temp;
}
inline void CommonBasicInfo::set_allocated_service_state_info(::ServiceStateInfo* service_state_info) {
  delete service_state_info_;
  service_state_info_ = service_state_info;
  if (service_state_info) {
    set_has_service_state_info();
  } else {
    clear_has_service_state_info();
  }
}

// -------------------------------------------------------------------

// ServiceStateInfo

// optional .ServiceState service_state = 1;
inline bool ServiceStateInfo::has_service_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceStateInfo::set_has_service_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceStateInfo::clear_has_service_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceStateInfo::clear_service_state() {
  service_state_ = 0;
  clear_has_service_state();
}
inline ::ServiceState ServiceStateInfo::service_state() const {
  return static_cast< ::ServiceState >(service_state_);
}
inline void ServiceStateInfo::set_service_state(::ServiceState value) {
  assert(::ServiceState_IsValid(value));
  set_has_service_state();
  service_state_ = value;
}

// optional .ServiceStateReason service_state_reason = 2;
inline bool ServiceStateInfo::has_service_state_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceStateInfo::set_has_service_state_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceStateInfo::clear_has_service_state_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceStateInfo::clear_service_state_reason() {
  service_state_reason_ = 0;
  clear_has_service_state_reason();
}
inline ::ServiceStateReason ServiceStateInfo::service_state_reason() const {
  return static_cast< ::ServiceStateReason >(service_state_reason_);
}
inline void ServiceStateInfo::set_service_state_reason(::ServiceStateReason value) {
  assert(::ServiceStateReason_IsValid(value));
  set_has_service_state_reason();
  service_state_reason_ = value;
}

// -------------------------------------------------------------------

// ConnectivityState

// optional .NetworkOperator network_operator = 1;
inline bool ConnectivityState::has_network_operator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectivityState::set_has_network_operator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectivityState::clear_has_network_operator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectivityState::clear_network_operator() {
  network_operator_ = 0;
  clear_has_network_operator();
}
inline ::NetworkOperator ConnectivityState::network_operator() const {
  return static_cast< ::NetworkOperator >(network_operator_);
}
inline void ConnectivityState::set_network_operator(::NetworkOperator value) {
  assert(::NetworkOperator_IsValid(value));
  set_has_network_operator();
  network_operator_ = value;
}

// optional .NetworkType network_type = 2;
inline bool ConnectivityState::has_network_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectivityState::set_has_network_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectivityState::clear_has_network_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectivityState::clear_network_type() {
  network_type_ = 0;
  clear_has_network_type();
}
inline ::NetworkType ConnectivityState::network_type() const {
  return static_cast< ::NetworkType >(network_type_);
}
inline void ConnectivityState::set_network_type(::NetworkType value) {
  assert(::NetworkType_IsValid(value));
  set_has_network_type();
  network_type_ = value;
}

// -------------------------------------------------------------------

// ChargingConnector

// optional string charging_connector_id = 1;
inline bool ChargingConnector::has_charging_connector_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChargingConnector::set_has_charging_connector_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChargingConnector::clear_has_charging_connector_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChargingConnector::clear_charging_connector_id() {
  if (charging_connector_id_ != &::google::protobuf::internal::kEmptyString) {
    charging_connector_id_->clear();
  }
  clear_has_charging_connector_id();
}
inline const ::std::string& ChargingConnector::charging_connector_id() const {
  return *charging_connector_id_;
}
inline void ChargingConnector::set_charging_connector_id(const ::std::string& value) {
  set_has_charging_connector_id();
  if (charging_connector_id_ == &::google::protobuf::internal::kEmptyString) {
    charging_connector_id_ = new ::std::string;
  }
  charging_connector_id_->assign(value);
}
inline void ChargingConnector::set_charging_connector_id(const char* value) {
  set_has_charging_connector_id();
  if (charging_connector_id_ == &::google::protobuf::internal::kEmptyString) {
    charging_connector_id_ = new ::std::string;
  }
  charging_connector_id_->assign(value);
}
inline void ChargingConnector::set_charging_connector_id(const char* value, size_t size) {
  set_has_charging_connector_id();
  if (charging_connector_id_ == &::google::protobuf::internal::kEmptyString) {
    charging_connector_id_ = new ::std::string;
  }
  charging_connector_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChargingConnector::mutable_charging_connector_id() {
  set_has_charging_connector_id();
  if (charging_connector_id_ == &::google::protobuf::internal::kEmptyString) {
    charging_connector_id_ = new ::std::string;
  }
  return charging_connector_id_;
}
inline ::std::string* ChargingConnector::release_charging_connector_id() {
  clear_has_charging_connector_id();
  if (charging_connector_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charging_connector_id_;
    charging_connector_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChargingConnector::set_allocated_charging_connector_id(::std::string* charging_connector_id) {
  if (charging_connector_id_ != &::google::protobuf::internal::kEmptyString) {
    delete charging_connector_id_;
  }
  if (charging_connector_id) {
    set_has_charging_connector_id();
    charging_connector_id_ = charging_connector_id;
  } else {
    clear_has_charging_connector_id();
    charging_connector_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .ChargingConnectorWorkState charging_connector_work_state = 2;
inline bool ChargingConnector::has_charging_connector_work_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChargingConnector::set_has_charging_connector_work_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChargingConnector::clear_has_charging_connector_work_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChargingConnector::clear_charging_connector_work_state() {
  charging_connector_work_state_ = 0;
  clear_has_charging_connector_work_state();
}
inline ::ChargingConnectorWorkState ChargingConnector::charging_connector_work_state() const {
  return static_cast< ::ChargingConnectorWorkState >(charging_connector_work_state_);
}
inline void ChargingConnector::set_charging_connector_work_state(::ChargingConnectorWorkState value) {
  assert(::ChargingConnectorWorkState_IsValid(value));
  set_has_charging_connector_work_state();
  charging_connector_work_state_ = value;
}

// optional .ChargingConnectorConnectionState charging_connector_connection_state = 3;
inline bool ChargingConnector::has_charging_connector_connection_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChargingConnector::set_has_charging_connector_connection_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChargingConnector::clear_has_charging_connector_connection_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChargingConnector::clear_charging_connector_connection_state() {
  charging_connector_connection_state_ = 0;
  clear_has_charging_connector_connection_state();
}
inline ::ChargingConnectorConnectionState ChargingConnector::charging_connector_connection_state() const {
  return static_cast< ::ChargingConnectorConnectionState >(charging_connector_connection_state_);
}
inline void ChargingConnector::set_charging_connector_connection_state(::ChargingConnectorConnectionState value) {
  assert(::ChargingConnectorConnectionState_IsValid(value));
  set_has_charging_connector_connection_state();
  charging_connector_connection_state_ = value;
}

// optional .ChargingConnectorFaultState charging_connector_fault_state = 4;
inline bool ChargingConnector::has_charging_connector_fault_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChargingConnector::set_has_charging_connector_fault_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChargingConnector::clear_has_charging_connector_fault_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChargingConnector::clear_charging_connector_fault_state() {
  charging_connector_fault_state_ = 0;
  clear_has_charging_connector_fault_state();
}
inline ::ChargingConnectorFaultState ChargingConnector::charging_connector_fault_state() const {
  return static_cast< ::ChargingConnectorFaultState >(charging_connector_fault_state_);
}
inline void ChargingConnector::set_charging_connector_fault_state(::ChargingConnectorFaultState value) {
  assert(::ChargingConnectorFaultState_IsValid(value));
  set_has_charging_connector_fault_state();
  charging_connector_fault_state_ = value;
}

// optional .PowerChargerConnectorOutputType power_charger_connector_output_type = 5;
inline bool ChargingConnector::has_power_charger_connector_output_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChargingConnector::set_has_power_charger_connector_output_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChargingConnector::clear_has_power_charger_connector_output_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChargingConnector::clear_power_charger_connector_output_type() {
  power_charger_connector_output_type_ = 0;
  clear_has_power_charger_connector_output_type();
}
inline ::PowerChargerConnectorOutputType ChargingConnector::power_charger_connector_output_type() const {
  return static_cast< ::PowerChargerConnectorOutputType >(power_charger_connector_output_type_);
}
inline void ChargingConnector::set_power_charger_connector_output_type(::PowerChargerConnectorOutputType value) {
  assert(::PowerChargerConnectorOutputType_IsValid(value));
  set_has_power_charger_connector_output_type();
  power_charger_connector_output_type_ = value;
}

// optional .PowerChargerConnectorOutputVoltage power_charger_connector_rated_output_voltage = 6;
inline bool ChargingConnector::has_power_charger_connector_rated_output_voltage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChargingConnector::set_has_power_charger_connector_rated_output_voltage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChargingConnector::clear_has_power_charger_connector_rated_output_voltage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChargingConnector::clear_power_charger_connector_rated_output_voltage() {
  power_charger_connector_rated_output_voltage_ = 0;
  clear_has_power_charger_connector_rated_output_voltage();
}
inline ::PowerChargerConnectorOutputVoltage ChargingConnector::power_charger_connector_rated_output_voltage() const {
  return static_cast< ::PowerChargerConnectorOutputVoltage >(power_charger_connector_rated_output_voltage_);
}
inline void ChargingConnector::set_power_charger_connector_rated_output_voltage(::PowerChargerConnectorOutputVoltage value) {
  assert(::PowerChargerConnectorOutputVoltage_IsValid(value));
  set_has_power_charger_connector_rated_output_voltage();
  power_charger_connector_rated_output_voltage_ = value;
}

// optional float power_charger_connector_rated_output_power = 7;
inline bool ChargingConnector::has_power_charger_connector_rated_output_power() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChargingConnector::set_has_power_charger_connector_rated_output_power() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChargingConnector::clear_has_power_charger_connector_rated_output_power() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChargingConnector::clear_power_charger_connector_rated_output_power() {
  power_charger_connector_rated_output_power_ = 0;
  clear_has_power_charger_connector_rated_output_power();
}
inline float ChargingConnector::power_charger_connector_rated_output_power() const {
  return power_charger_connector_rated_output_power_;
}
inline void ChargingConnector::set_power_charger_connector_rated_output_power(float value) {
  set_has_power_charger_connector_rated_output_power();
  power_charger_connector_rated_output_power_ = value;
}

// optional float realtime_output_voltage = 8;
inline bool ChargingConnector::has_realtime_output_voltage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChargingConnector::set_has_realtime_output_voltage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChargingConnector::clear_has_realtime_output_voltage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChargingConnector::clear_realtime_output_voltage() {
  realtime_output_voltage_ = 0;
  clear_has_realtime_output_voltage();
}
inline float ChargingConnector::realtime_output_voltage() const {
  return realtime_output_voltage_;
}
inline void ChargingConnector::set_realtime_output_voltage(float value) {
  set_has_realtime_output_voltage();
  realtime_output_voltage_ = value;
}

// optional float realtime_output_current = 9;
inline bool ChargingConnector::has_realtime_output_current() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ChargingConnector::set_has_realtime_output_current() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ChargingConnector::clear_has_realtime_output_current() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ChargingConnector::clear_realtime_output_current() {
  realtime_output_current_ = 0;
  clear_has_realtime_output_current();
}
inline float ChargingConnector::realtime_output_current() const {
  return realtime_output_current_;
}
inline void ChargingConnector::set_realtime_output_current(float value) {
  set_has_realtime_output_current();
  realtime_output_current_ = value;
}

// -------------------------------------------------------------------

// Alarm

// optional uint32 alarm_type_id = 1;
inline bool Alarm::has_alarm_type_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Alarm::set_has_alarm_type_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Alarm::clear_has_alarm_type_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Alarm::clear_alarm_type_id() {
  alarm_type_id_ = 0u;
  clear_has_alarm_type_id();
}
inline ::google::protobuf::uint32 Alarm::alarm_type_id() const {
  return alarm_type_id_;
}
inline void Alarm::set_alarm_type_id(::google::protobuf::uint32 value) {
  set_has_alarm_type_id();
  alarm_type_id_ = value;
}

// optional int64 alarm_timestamp = 2;
inline bool Alarm::has_alarm_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Alarm::set_has_alarm_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Alarm::clear_has_alarm_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Alarm::clear_alarm_timestamp() {
  alarm_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_alarm_timestamp();
}
inline ::google::protobuf::int64 Alarm::alarm_timestamp() const {
  return alarm_timestamp_;
}
inline void Alarm::set_alarm_timestamp(::google::protobuf::int64 value) {
  set_has_alarm_timestamp();
  alarm_timestamp_ = value;
}

// optional .AlarmState alarm_state = 3;
inline bool Alarm::has_alarm_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Alarm::set_has_alarm_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Alarm::clear_has_alarm_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Alarm::clear_alarm_state() {
  alarm_state_ = 0;
  clear_has_alarm_state();
}
inline ::AlarmState Alarm::alarm_state() const {
  return static_cast< ::AlarmState >(alarm_state_);
}
inline void Alarm::set_alarm_state(::AlarmState value) {
  assert(::AlarmState_IsValid(value));
  set_has_alarm_state();
  alarm_state_ = value;
}

// -------------------------------------------------------------------

// LocalConfiguration

// optional bool full = 1;
inline bool LocalConfiguration::has_full() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalConfiguration::set_has_full() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalConfiguration::clear_has_full() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalConfiguration::clear_full() {
  full_ = false;
  clear_has_full();
}
inline bool LocalConfiguration::full() const {
  return full_;
}
inline void LocalConfiguration::set_full(bool value) {
  set_has_full();
  full_ = value;
}

// repeated .LocalConfigurationInfo configuration_info = 2;
inline int LocalConfiguration::configuration_info_size() const {
  return configuration_info_.size();
}
inline void LocalConfiguration::clear_configuration_info() {
  configuration_info_.Clear();
}
inline const ::LocalConfigurationInfo& LocalConfiguration::configuration_info(int index) const {
  return configuration_info_.Get(index);
}
inline ::LocalConfigurationInfo* LocalConfiguration::mutable_configuration_info(int index) {
  return configuration_info_.Mutable(index);
}
inline ::LocalConfigurationInfo* LocalConfiguration::add_configuration_info() {
  return configuration_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::LocalConfigurationInfo >&
LocalConfiguration::configuration_info() const {
  return configuration_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::LocalConfigurationInfo >*
LocalConfiguration::mutable_configuration_info() {
  return &configuration_info_;
}

// -------------------------------------------------------------------

// LocalConfigurationInfo

// optional string configuration_key = 1;
inline bool LocalConfigurationInfo::has_configuration_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalConfigurationInfo::set_has_configuration_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalConfigurationInfo::clear_has_configuration_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalConfigurationInfo::clear_configuration_key() {
  if (configuration_key_ != &::google::protobuf::internal::kEmptyString) {
    configuration_key_->clear();
  }
  clear_has_configuration_key();
}
inline const ::std::string& LocalConfigurationInfo::configuration_key() const {
  return *configuration_key_;
}
inline void LocalConfigurationInfo::set_configuration_key(const ::std::string& value) {
  set_has_configuration_key();
  if (configuration_key_ == &::google::protobuf::internal::kEmptyString) {
    configuration_key_ = new ::std::string;
  }
  configuration_key_->assign(value);
}
inline void LocalConfigurationInfo::set_configuration_key(const char* value) {
  set_has_configuration_key();
  if (configuration_key_ == &::google::protobuf::internal::kEmptyString) {
    configuration_key_ = new ::std::string;
  }
  configuration_key_->assign(value);
}
inline void LocalConfigurationInfo::set_configuration_key(const char* value, size_t size) {
  set_has_configuration_key();
  if (configuration_key_ == &::google::protobuf::internal::kEmptyString) {
    configuration_key_ = new ::std::string;
  }
  configuration_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalConfigurationInfo::mutable_configuration_key() {
  set_has_configuration_key();
  if (configuration_key_ == &::google::protobuf::internal::kEmptyString) {
    configuration_key_ = new ::std::string;
  }
  return configuration_key_;
}
inline ::std::string* LocalConfigurationInfo::release_configuration_key() {
  clear_has_configuration_key();
  if (configuration_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = configuration_key_;
    configuration_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocalConfigurationInfo::set_allocated_configuration_key(::std::string* configuration_key) {
  if (configuration_key_ != &::google::protobuf::internal::kEmptyString) {
    delete configuration_key_;
  }
  if (configuration_key) {
    set_has_configuration_key();
    configuration_key_ = configuration_key;
  } else {
    clear_has_configuration_key();
    configuration_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes configuration_value = 2;
inline bool LocalConfigurationInfo::has_configuration_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalConfigurationInfo::set_has_configuration_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalConfigurationInfo::clear_has_configuration_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalConfigurationInfo::clear_configuration_value() {
  if (configuration_value_ != &::google::protobuf::internal::kEmptyString) {
    configuration_value_->clear();
  }
  clear_has_configuration_value();
}
inline const ::std::string& LocalConfigurationInfo::configuration_value() const {
  return *configuration_value_;
}
inline void LocalConfigurationInfo::set_configuration_value(const ::std::string& value) {
  set_has_configuration_value();
  if (configuration_value_ == &::google::protobuf::internal::kEmptyString) {
    configuration_value_ = new ::std::string;
  }
  configuration_value_->assign(value);
}
inline void LocalConfigurationInfo::set_configuration_value(const char* value) {
  set_has_configuration_value();
  if (configuration_value_ == &::google::protobuf::internal::kEmptyString) {
    configuration_value_ = new ::std::string;
  }
  configuration_value_->assign(value);
}
inline void LocalConfigurationInfo::set_configuration_value(const void* value, size_t size) {
  set_has_configuration_value();
  if (configuration_value_ == &::google::protobuf::internal::kEmptyString) {
    configuration_value_ = new ::std::string;
  }
  configuration_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalConfigurationInfo::mutable_configuration_value() {
  set_has_configuration_value();
  if (configuration_value_ == &::google::protobuf::internal::kEmptyString) {
    configuration_value_ = new ::std::string;
  }
  return configuration_value_;
}
inline ::std::string* LocalConfigurationInfo::release_configuration_value() {
  clear_has_configuration_value();
  if (configuration_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = configuration_value_;
    configuration_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocalConfigurationInfo::set_allocated_configuration_value(::std::string* configuration_value) {
  if (configuration_value_ != &::google::protobuf::internal::kEmptyString) {
    delete configuration_value_;
  }
  if (configuration_value) {
    set_has_configuration_value();
    configuration_value_ = configuration_value;
  } else {
    clear_has_configuration_value();
    configuration_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .LocalConfigurationInfoAccessType local_configuration_info_access_type = 3;
inline bool LocalConfigurationInfo::has_local_configuration_info_access_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalConfigurationInfo::set_has_local_configuration_info_access_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalConfigurationInfo::clear_has_local_configuration_info_access_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocalConfigurationInfo::clear_local_configuration_info_access_type() {
  local_configuration_info_access_type_ = 0;
  clear_has_local_configuration_info_access_type();
}
inline ::LocalConfigurationInfoAccessType LocalConfigurationInfo::local_configuration_info_access_type() const {
  return static_cast< ::LocalConfigurationInfoAccessType >(local_configuration_info_access_type_);
}
inline void LocalConfigurationInfo::set_local_configuration_info_access_type(::LocalConfigurationInfoAccessType value) {
  assert(::LocalConfigurationInfoAccessType_IsValid(value));
  set_has_local_configuration_info_access_type();
  local_configuration_info_access_type_ = value;
}

// optional bool has_been_updated = 4;
inline bool LocalConfigurationInfo::has_has_been_updated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocalConfigurationInfo::set_has_has_been_updated() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocalConfigurationInfo::clear_has_has_been_updated() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocalConfigurationInfo::clear_has_been_updated() {
  has_been_updated_ = false;
  clear_has_has_been_updated();
}
inline bool LocalConfigurationInfo::has_been_updated() const {
  return has_been_updated_;
}
inline void LocalConfigurationInfo::set_has_been_updated(bool value) {
  set_has_has_been_updated();
  has_been_updated_ = value;
}

// optional string failureReason = 5;
inline bool LocalConfigurationInfo::has_failurereason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocalConfigurationInfo::set_has_failurereason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocalConfigurationInfo::clear_has_failurereason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocalConfigurationInfo::clear_failurereason() {
  if (failurereason_ != &::google::protobuf::internal::kEmptyString) {
    failurereason_->clear();
  }
  clear_has_failurereason();
}
inline const ::std::string& LocalConfigurationInfo::failurereason() const {
  return *failurereason_;
}
inline void LocalConfigurationInfo::set_failurereason(const ::std::string& value) {
  set_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    failurereason_ = new ::std::string;
  }
  failurereason_->assign(value);
}
inline void LocalConfigurationInfo::set_failurereason(const char* value) {
  set_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    failurereason_ = new ::std::string;
  }
  failurereason_->assign(value);
}
inline void LocalConfigurationInfo::set_failurereason(const char* value, size_t size) {
  set_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    failurereason_ = new ::std::string;
  }
  failurereason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalConfigurationInfo::mutable_failurereason() {
  set_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    failurereason_ = new ::std::string;
  }
  return failurereason_;
}
inline ::std::string* LocalConfigurationInfo::release_failurereason() {
  clear_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = failurereason_;
    failurereason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocalConfigurationInfo::set_allocated_failurereason(::std::string* failurereason) {
  if (failurereason_ != &::google::protobuf::internal::kEmptyString) {
    delete failurereason_;
  }
  if (failurereason) {
    set_has_failurereason();
    failurereason_ = failurereason;
  } else {
    clear_has_failurereason();
    failurereason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RemoteOperation

// optional int64 message_timestamp = 1;
inline bool RemoteOperation::has_message_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteOperation::set_has_message_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteOperation::clear_has_message_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteOperation::clear_message_timestamp() {
  message_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_message_timestamp();
}
inline ::google::protobuf::int64 RemoteOperation::message_timestamp() const {
  return message_timestamp_;
}
inline void RemoteOperation::set_message_timestamp(::google::protobuf::int64 value) {
  set_has_message_timestamp();
  message_timestamp_ = value;
}

// optional .RemoteConfiguration remote_configuration = 2;
inline bool RemoteOperation::has_remote_configuration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteOperation::set_has_remote_configuration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteOperation::clear_has_remote_configuration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteOperation::clear_remote_configuration() {
  if (remote_configuration_ != NULL) remote_configuration_->::RemoteConfiguration::Clear();
  clear_has_remote_configuration();
}
inline const ::RemoteConfiguration& RemoteOperation::remote_configuration() const {
  return remote_configuration_ != NULL ? *remote_configuration_ : *default_instance_->remote_configuration_;
}
inline ::RemoteConfiguration* RemoteOperation::mutable_remote_configuration() {
  set_has_remote_configuration();
  if (remote_configuration_ == NULL) remote_configuration_ = new ::RemoteConfiguration;
  return remote_configuration_;
}
inline ::RemoteConfiguration* RemoteOperation::release_remote_configuration() {
  clear_has_remote_configuration();
  ::RemoteConfiguration* temp = remote_configuration_;
  remote_configuration_ = NULL;
  return temp;
}
inline void RemoteOperation::set_allocated_remote_configuration(::RemoteConfiguration* remote_configuration) {
  delete remote_configuration_;
  remote_configuration_ = remote_configuration;
  if (remote_configuration) {
    set_has_remote_configuration();
  } else {
    clear_has_remote_configuration();
  }
}

// optional .RemoteControl remote_control = 3;
inline bool RemoteOperation::has_remote_control() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteOperation::set_has_remote_control() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoteOperation::clear_has_remote_control() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoteOperation::clear_remote_control() {
  if (remote_control_ != NULL) remote_control_->::RemoteControl::Clear();
  clear_has_remote_control();
}
inline const ::RemoteControl& RemoteOperation::remote_control() const {
  return remote_control_ != NULL ? *remote_control_ : *default_instance_->remote_control_;
}
inline ::RemoteControl* RemoteOperation::mutable_remote_control() {
  set_has_remote_control();
  if (remote_control_ == NULL) remote_control_ = new ::RemoteControl;
  return remote_control_;
}
inline ::RemoteControl* RemoteOperation::release_remote_control() {
  clear_has_remote_control();
  ::RemoteControl* temp = remote_control_;
  remote_control_ = NULL;
  return temp;
}
inline void RemoteOperation::set_allocated_remote_control(::RemoteControl* remote_control) {
  delete remote_control_;
  remote_control_ = remote_control;
  if (remote_control) {
    set_has_remote_control();
  } else {
    clear_has_remote_control();
  }
}

// optional .RemoteUpgrade remote_upgrade = 4;
inline bool RemoteOperation::has_remote_upgrade() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoteOperation::set_has_remote_upgrade() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RemoteOperation::clear_has_remote_upgrade() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RemoteOperation::clear_remote_upgrade() {
  if (remote_upgrade_ != NULL) remote_upgrade_->::RemoteUpgrade::Clear();
  clear_has_remote_upgrade();
}
inline const ::RemoteUpgrade& RemoteOperation::remote_upgrade() const {
  return remote_upgrade_ != NULL ? *remote_upgrade_ : *default_instance_->remote_upgrade_;
}
inline ::RemoteUpgrade* RemoteOperation::mutable_remote_upgrade() {
  set_has_remote_upgrade();
  if (remote_upgrade_ == NULL) remote_upgrade_ = new ::RemoteUpgrade;
  return remote_upgrade_;
}
inline ::RemoteUpgrade* RemoteOperation::release_remote_upgrade() {
  clear_has_remote_upgrade();
  ::RemoteUpgrade* temp = remote_upgrade_;
  remote_upgrade_ = NULL;
  return temp;
}
inline void RemoteOperation::set_allocated_remote_upgrade(::RemoteUpgrade* remote_upgrade) {
  delete remote_upgrade_;
  remote_upgrade_ = remote_upgrade;
  if (remote_upgrade) {
    set_has_remote_upgrade();
  } else {
    clear_has_remote_upgrade();
  }
}

// -------------------------------------------------------------------

// RemoteConfiguration

// optional string request_id = 1;
inline bool RemoteConfiguration::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteConfiguration::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteConfiguration::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteConfiguration::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& RemoteConfiguration::request_id() const {
  return *request_id_;
}
inline void RemoteConfiguration::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void RemoteConfiguration::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void RemoteConfiguration::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteConfiguration::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* RemoteConfiguration::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteConfiguration::set_allocated_request_id(::std::string* request_id) {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    delete request_id_;
  }
  if (request_id) {
    set_has_request_id();
    request_id_ = request_id;
  } else {
    clear_has_request_id();
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .RemoteConfigurationInfo remote_configuration_info = 2;
inline int RemoteConfiguration::remote_configuration_info_size() const {
  return remote_configuration_info_.size();
}
inline void RemoteConfiguration::clear_remote_configuration_info() {
  remote_configuration_info_.Clear();
}
inline const ::RemoteConfigurationInfo& RemoteConfiguration::remote_configuration_info(int index) const {
  return remote_configuration_info_.Get(index);
}
inline ::RemoteConfigurationInfo* RemoteConfiguration::mutable_remote_configuration_info(int index) {
  return remote_configuration_info_.Mutable(index);
}
inline ::RemoteConfigurationInfo* RemoteConfiguration::add_remote_configuration_info() {
  return remote_configuration_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RemoteConfigurationInfo >&
RemoteConfiguration::remote_configuration_info() const {
  return remote_configuration_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::RemoteConfigurationInfo >*
RemoteConfiguration::mutable_remote_configuration_info() {
  return &remote_configuration_info_;
}

// -------------------------------------------------------------------

// RemoteConfigurationInfo

// optional string configuration_key = 1;
inline bool RemoteConfigurationInfo::has_configuration_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteConfigurationInfo::set_has_configuration_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteConfigurationInfo::clear_has_configuration_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteConfigurationInfo::clear_configuration_key() {
  if (configuration_key_ != &::google::protobuf::internal::kEmptyString) {
    configuration_key_->clear();
  }
  clear_has_configuration_key();
}
inline const ::std::string& RemoteConfigurationInfo::configuration_key() const {
  return *configuration_key_;
}
inline void RemoteConfigurationInfo::set_configuration_key(const ::std::string& value) {
  set_has_configuration_key();
  if (configuration_key_ == &::google::protobuf::internal::kEmptyString) {
    configuration_key_ = new ::std::string;
  }
  configuration_key_->assign(value);
}
inline void RemoteConfigurationInfo::set_configuration_key(const char* value) {
  set_has_configuration_key();
  if (configuration_key_ == &::google::protobuf::internal::kEmptyString) {
    configuration_key_ = new ::std::string;
  }
  configuration_key_->assign(value);
}
inline void RemoteConfigurationInfo::set_configuration_key(const char* value, size_t size) {
  set_has_configuration_key();
  if (configuration_key_ == &::google::protobuf::internal::kEmptyString) {
    configuration_key_ = new ::std::string;
  }
  configuration_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteConfigurationInfo::mutable_configuration_key() {
  set_has_configuration_key();
  if (configuration_key_ == &::google::protobuf::internal::kEmptyString) {
    configuration_key_ = new ::std::string;
  }
  return configuration_key_;
}
inline ::std::string* RemoteConfigurationInfo::release_configuration_key() {
  clear_has_configuration_key();
  if (configuration_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = configuration_key_;
    configuration_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteConfigurationInfo::set_allocated_configuration_key(::std::string* configuration_key) {
  if (configuration_key_ != &::google::protobuf::internal::kEmptyString) {
    delete configuration_key_;
  }
  if (configuration_key) {
    set_has_configuration_key();
    configuration_key_ = configuration_key;
  } else {
    clear_has_configuration_key();
    configuration_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes configuration_value = 2;
inline bool RemoteConfigurationInfo::has_configuration_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteConfigurationInfo::set_has_configuration_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteConfigurationInfo::clear_has_configuration_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteConfigurationInfo::clear_configuration_value() {
  if (configuration_value_ != &::google::protobuf::internal::kEmptyString) {
    configuration_value_->clear();
  }
  clear_has_configuration_value();
}
inline const ::std::string& RemoteConfigurationInfo::configuration_value() const {
  return *configuration_value_;
}
inline void RemoteConfigurationInfo::set_configuration_value(const ::std::string& value) {
  set_has_configuration_value();
  if (configuration_value_ == &::google::protobuf::internal::kEmptyString) {
    configuration_value_ = new ::std::string;
  }
  configuration_value_->assign(value);
}
inline void RemoteConfigurationInfo::set_configuration_value(const char* value) {
  set_has_configuration_value();
  if (configuration_value_ == &::google::protobuf::internal::kEmptyString) {
    configuration_value_ = new ::std::string;
  }
  configuration_value_->assign(value);
}
inline void RemoteConfigurationInfo::set_configuration_value(const void* value, size_t size) {
  set_has_configuration_value();
  if (configuration_value_ == &::google::protobuf::internal::kEmptyString) {
    configuration_value_ = new ::std::string;
  }
  configuration_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteConfigurationInfo::mutable_configuration_value() {
  set_has_configuration_value();
  if (configuration_value_ == &::google::protobuf::internal::kEmptyString) {
    configuration_value_ = new ::std::string;
  }
  return configuration_value_;
}
inline ::std::string* RemoteConfigurationInfo::release_configuration_value() {
  clear_has_configuration_value();
  if (configuration_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = configuration_value_;
    configuration_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteConfigurationInfo::set_allocated_configuration_value(::std::string* configuration_value) {
  if (configuration_value_ != &::google::protobuf::internal::kEmptyString) {
    delete configuration_value_;
  }
  if (configuration_value) {
    set_has_configuration_value();
    configuration_value_ = configuration_value;
  } else {
    clear_has_configuration_value();
    configuration_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RemoteControl

// optional string request_id = 1;
inline bool RemoteControl::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteControl::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteControl::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteControl::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& RemoteControl::request_id() const {
  return *request_id_;
}
inline void RemoteControl::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void RemoteControl::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void RemoteControl::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteControl::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* RemoteControl::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteControl::set_allocated_request_id(::std::string* request_id) {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    delete request_id_;
  }
  if (request_id) {
    set_has_request_id();
    request_id_ = request_id;
  } else {
    clear_has_request_id();
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .RemoteControlCommand remote_control_command = 2;
inline bool RemoteControl::has_remote_control_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteControl::set_has_remote_control_command() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteControl::clear_has_remote_control_command() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteControl::clear_remote_control_command() {
  remote_control_command_ = 0;
  clear_has_remote_control_command();
}
inline ::RemoteControlCommand RemoteControl::remote_control_command() const {
  return static_cast< ::RemoteControlCommand >(remote_control_command_);
}
inline void RemoteControl::set_remote_control_command(::RemoteControlCommand value) {
  assert(::RemoteControlCommand_IsValid(value));
  set_has_remote_control_command();
  remote_control_command_ = value;
}

// repeated .RemoteControlParam remote_control_param = 3;
inline int RemoteControl::remote_control_param_size() const {
  return remote_control_param_.size();
}
inline void RemoteControl::clear_remote_control_param() {
  remote_control_param_.Clear();
}
inline const ::RemoteControlParam& RemoteControl::remote_control_param(int index) const {
  return remote_control_param_.Get(index);
}
inline ::RemoteControlParam* RemoteControl::mutable_remote_control_param(int index) {
  return remote_control_param_.Mutable(index);
}
inline ::RemoteControlParam* RemoteControl::add_remote_control_param() {
  return remote_control_param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RemoteControlParam >&
RemoteControl::remote_control_param() const {
  return remote_control_param_;
}
inline ::google::protobuf::RepeatedPtrField< ::RemoteControlParam >*
RemoteControl::mutable_remote_control_param() {
  return &remote_control_param_;
}

// -------------------------------------------------------------------

// RemoteControlParam

// optional string key = 1;
inline bool RemoteControlParam::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteControlParam::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteControlParam::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteControlParam::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RemoteControlParam::key() const {
  return *key_;
}
inline void RemoteControlParam::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RemoteControlParam::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RemoteControlParam::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteControlParam::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RemoteControlParam::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteControlParam::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes value = 2;
inline bool RemoteControlParam::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteControlParam::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteControlParam::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteControlParam::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& RemoteControlParam::value() const {
  return *value_;
}
inline void RemoteControlParam::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RemoteControlParam::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void RemoteControlParam::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteControlParam::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* RemoteControlParam::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteControlParam::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RemoteUpgrade

// optional string request_id = 1;
inline bool RemoteUpgrade::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteUpgrade::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteUpgrade::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteUpgrade::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& RemoteUpgrade::request_id() const {
  return *request_id_;
}
inline void RemoteUpgrade::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void RemoteUpgrade::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void RemoteUpgrade::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteUpgrade::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* RemoteUpgrade::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteUpgrade::set_allocated_request_id(::std::string* request_id) {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    delete request_id_;
  }
  if (request_id) {
    set_has_request_id();
    request_id_ = request_id;
  } else {
    clear_has_request_id();
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string software_version = 2;
inline bool RemoteUpgrade::has_software_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteUpgrade::set_has_software_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteUpgrade::clear_has_software_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteUpgrade::clear_software_version() {
  if (software_version_ != &::google::protobuf::internal::kEmptyString) {
    software_version_->clear();
  }
  clear_has_software_version();
}
inline const ::std::string& RemoteUpgrade::software_version() const {
  return *software_version_;
}
inline void RemoteUpgrade::set_software_version(const ::std::string& value) {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::kEmptyString) {
    software_version_ = new ::std::string;
  }
  software_version_->assign(value);
}
inline void RemoteUpgrade::set_software_version(const char* value) {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::kEmptyString) {
    software_version_ = new ::std::string;
  }
  software_version_->assign(value);
}
inline void RemoteUpgrade::set_software_version(const char* value, size_t size) {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::kEmptyString) {
    software_version_ = new ::std::string;
  }
  software_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteUpgrade::mutable_software_version() {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::kEmptyString) {
    software_version_ = new ::std::string;
  }
  return software_version_;
}
inline ::std::string* RemoteUpgrade::release_software_version() {
  clear_has_software_version();
  if (software_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = software_version_;
    software_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteUpgrade::set_allocated_software_version(::std::string* software_version) {
  if (software_version_ != &::google::protobuf::internal::kEmptyString) {
    delete software_version_;
  }
  if (software_version) {
    set_has_software_version();
    software_version_ = software_version;
  } else {
    clear_has_software_version();
    software_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ftp_address = 3;
inline bool RemoteUpgrade::has_ftp_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteUpgrade::set_has_ftp_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoteUpgrade::clear_has_ftp_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoteUpgrade::clear_ftp_address() {
  if (ftp_address_ != &::google::protobuf::internal::kEmptyString) {
    ftp_address_->clear();
  }
  clear_has_ftp_address();
}
inline const ::std::string& RemoteUpgrade::ftp_address() const {
  return *ftp_address_;
}
inline void RemoteUpgrade::set_ftp_address(const ::std::string& value) {
  set_has_ftp_address();
  if (ftp_address_ == &::google::protobuf::internal::kEmptyString) {
    ftp_address_ = new ::std::string;
  }
  ftp_address_->assign(value);
}
inline void RemoteUpgrade::set_ftp_address(const char* value) {
  set_has_ftp_address();
  if (ftp_address_ == &::google::protobuf::internal::kEmptyString) {
    ftp_address_ = new ::std::string;
  }
  ftp_address_->assign(value);
}
inline void RemoteUpgrade::set_ftp_address(const char* value, size_t size) {
  set_has_ftp_address();
  if (ftp_address_ == &::google::protobuf::internal::kEmptyString) {
    ftp_address_ = new ::std::string;
  }
  ftp_address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteUpgrade::mutable_ftp_address() {
  set_has_ftp_address();
  if (ftp_address_ == &::google::protobuf::internal::kEmptyString) {
    ftp_address_ = new ::std::string;
  }
  return ftp_address_;
}
inline ::std::string* RemoteUpgrade::release_ftp_address() {
  clear_has_ftp_address();
  if (ftp_address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ftp_address_;
    ftp_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteUpgrade::set_allocated_ftp_address(::std::string* ftp_address) {
  if (ftp_address_ != &::google::protobuf::internal::kEmptyString) {
    delete ftp_address_;
  }
  if (ftp_address) {
    set_has_ftp_address();
    ftp_address_ = ftp_address;
  } else {
    clear_has_ftp_address();
    ftp_address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RemoteOperationResponse

// optional .RemoteConfigurationResponse remote_configuration_response = 1;
inline bool RemoteOperationResponse::has_remote_configuration_response() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteOperationResponse::set_has_remote_configuration_response() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteOperationResponse::clear_has_remote_configuration_response() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteOperationResponse::clear_remote_configuration_response() {
  if (remote_configuration_response_ != NULL) remote_configuration_response_->::RemoteConfigurationResponse::Clear();
  clear_has_remote_configuration_response();
}
inline const ::RemoteConfigurationResponse& RemoteOperationResponse::remote_configuration_response() const {
  return remote_configuration_response_ != NULL ? *remote_configuration_response_ : *default_instance_->remote_configuration_response_;
}
inline ::RemoteConfigurationResponse* RemoteOperationResponse::mutable_remote_configuration_response() {
  set_has_remote_configuration_response();
  if (remote_configuration_response_ == NULL) remote_configuration_response_ = new ::RemoteConfigurationResponse;
  return remote_configuration_response_;
}
inline ::RemoteConfigurationResponse* RemoteOperationResponse::release_remote_configuration_response() {
  clear_has_remote_configuration_response();
  ::RemoteConfigurationResponse* temp = remote_configuration_response_;
  remote_configuration_response_ = NULL;
  return temp;
}
inline void RemoteOperationResponse::set_allocated_remote_configuration_response(::RemoteConfigurationResponse* remote_configuration_response) {
  delete remote_configuration_response_;
  remote_configuration_response_ = remote_configuration_response;
  if (remote_configuration_response) {
    set_has_remote_configuration_response();
  } else {
    clear_has_remote_configuration_response();
  }
}

// optional .RemoteControlResponse remote_control_response = 2;
inline bool RemoteOperationResponse::has_remote_control_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteOperationResponse::set_has_remote_control_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteOperationResponse::clear_has_remote_control_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteOperationResponse::clear_remote_control_response() {
  if (remote_control_response_ != NULL) remote_control_response_->::RemoteControlResponse::Clear();
  clear_has_remote_control_response();
}
inline const ::RemoteControlResponse& RemoteOperationResponse::remote_control_response() const {
  return remote_control_response_ != NULL ? *remote_control_response_ : *default_instance_->remote_control_response_;
}
inline ::RemoteControlResponse* RemoteOperationResponse::mutable_remote_control_response() {
  set_has_remote_control_response();
  if (remote_control_response_ == NULL) remote_control_response_ = new ::RemoteControlResponse;
  return remote_control_response_;
}
inline ::RemoteControlResponse* RemoteOperationResponse::release_remote_control_response() {
  clear_has_remote_control_response();
  ::RemoteControlResponse* temp = remote_control_response_;
  remote_control_response_ = NULL;
  return temp;
}
inline void RemoteOperationResponse::set_allocated_remote_control_response(::RemoteControlResponse* remote_control_response) {
  delete remote_control_response_;
  remote_control_response_ = remote_control_response;
  if (remote_control_response) {
    set_has_remote_control_response();
  } else {
    clear_has_remote_control_response();
  }
}

// optional .RemoteUpgradeResponse remote_upgrade_response = 3;
inline bool RemoteOperationResponse::has_remote_upgrade_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteOperationResponse::set_has_remote_upgrade_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoteOperationResponse::clear_has_remote_upgrade_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoteOperationResponse::clear_remote_upgrade_response() {
  if (remote_upgrade_response_ != NULL) remote_upgrade_response_->::RemoteUpgradeResponse::Clear();
  clear_has_remote_upgrade_response();
}
inline const ::RemoteUpgradeResponse& RemoteOperationResponse::remote_upgrade_response() const {
  return remote_upgrade_response_ != NULL ? *remote_upgrade_response_ : *default_instance_->remote_upgrade_response_;
}
inline ::RemoteUpgradeResponse* RemoteOperationResponse::mutable_remote_upgrade_response() {
  set_has_remote_upgrade_response();
  if (remote_upgrade_response_ == NULL) remote_upgrade_response_ = new ::RemoteUpgradeResponse;
  return remote_upgrade_response_;
}
inline ::RemoteUpgradeResponse* RemoteOperationResponse::release_remote_upgrade_response() {
  clear_has_remote_upgrade_response();
  ::RemoteUpgradeResponse* temp = remote_upgrade_response_;
  remote_upgrade_response_ = NULL;
  return temp;
}
inline void RemoteOperationResponse::set_allocated_remote_upgrade_response(::RemoteUpgradeResponse* remote_upgrade_response) {
  delete remote_upgrade_response_;
  remote_upgrade_response_ = remote_upgrade_response;
  if (remote_upgrade_response) {
    set_has_remote_upgrade_response();
  } else {
    clear_has_remote_upgrade_response();
  }
}

// -------------------------------------------------------------------

// RemoteConfigurationResponse

// optional string request_id = 1;
inline bool RemoteConfigurationResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteConfigurationResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteConfigurationResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteConfigurationResponse::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& RemoteConfigurationResponse::request_id() const {
  return *request_id_;
}
inline void RemoteConfigurationResponse::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void RemoteConfigurationResponse::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void RemoteConfigurationResponse::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteConfigurationResponse::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* RemoteConfigurationResponse::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteConfigurationResponse::set_allocated_request_id(::std::string* request_id) {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    delete request_id_;
  }
  if (request_id) {
    set_has_request_id();
    request_id_ = request_id;
  } else {
    clear_has_request_id();
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_id = 2;
inline bool RemoteConfigurationResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteConfigurationResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteConfigurationResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteConfigurationResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& RemoteConfigurationResponse::device_id() const {
  return *device_id_;
}
inline void RemoteConfigurationResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void RemoteConfigurationResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void RemoteConfigurationResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteConfigurationResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* RemoteConfigurationResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteConfigurationResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .RemoteConfigurationResponseType remote_configuration_response_type = 3;
inline bool RemoteConfigurationResponse::has_remote_configuration_response_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteConfigurationResponse::set_has_remote_configuration_response_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoteConfigurationResponse::clear_has_remote_configuration_response_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoteConfigurationResponse::clear_remote_configuration_response_type() {
  remote_configuration_response_type_ = 0;
  clear_has_remote_configuration_response_type();
}
inline ::RemoteConfigurationResponseType RemoteConfigurationResponse::remote_configuration_response_type() const {
  return static_cast< ::RemoteConfigurationResponseType >(remote_configuration_response_type_);
}
inline void RemoteConfigurationResponse::set_remote_configuration_response_type(::RemoteConfigurationResponseType value) {
  assert(::RemoteConfigurationResponseType_IsValid(value));
  set_has_remote_configuration_response_type();
  remote_configuration_response_type_ = value;
}

// optional string failureReason = 4;
inline bool RemoteConfigurationResponse::has_failurereason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoteConfigurationResponse::set_has_failurereason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RemoteConfigurationResponse::clear_has_failurereason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RemoteConfigurationResponse::clear_failurereason() {
  if (failurereason_ != &::google::protobuf::internal::kEmptyString) {
    failurereason_->clear();
  }
  clear_has_failurereason();
}
inline const ::std::string& RemoteConfigurationResponse::failurereason() const {
  return *failurereason_;
}
inline void RemoteConfigurationResponse::set_failurereason(const ::std::string& value) {
  set_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    failurereason_ = new ::std::string;
  }
  failurereason_->assign(value);
}
inline void RemoteConfigurationResponse::set_failurereason(const char* value) {
  set_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    failurereason_ = new ::std::string;
  }
  failurereason_->assign(value);
}
inline void RemoteConfigurationResponse::set_failurereason(const char* value, size_t size) {
  set_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    failurereason_ = new ::std::string;
  }
  failurereason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteConfigurationResponse::mutable_failurereason() {
  set_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    failurereason_ = new ::std::string;
  }
  return failurereason_;
}
inline ::std::string* RemoteConfigurationResponse::release_failurereason() {
  clear_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = failurereason_;
    failurereason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteConfigurationResponse::set_allocated_failurereason(::std::string* failurereason) {
  if (failurereason_ != &::google::protobuf::internal::kEmptyString) {
    delete failurereason_;
  }
  if (failurereason) {
    set_has_failurereason();
    failurereason_ = failurereason;
  } else {
    clear_has_failurereason();
    failurereason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .LocalConfigurationInfo configuration_info = 5;
inline int RemoteConfigurationResponse::configuration_info_size() const {
  return configuration_info_.size();
}
inline void RemoteConfigurationResponse::clear_configuration_info() {
  configuration_info_.Clear();
}
inline const ::LocalConfigurationInfo& RemoteConfigurationResponse::configuration_info(int index) const {
  return configuration_info_.Get(index);
}
inline ::LocalConfigurationInfo* RemoteConfigurationResponse::mutable_configuration_info(int index) {
  return configuration_info_.Mutable(index);
}
inline ::LocalConfigurationInfo* RemoteConfigurationResponse::add_configuration_info() {
  return configuration_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::LocalConfigurationInfo >&
RemoteConfigurationResponse::configuration_info() const {
  return configuration_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::LocalConfigurationInfo >*
RemoteConfigurationResponse::mutable_configuration_info() {
  return &configuration_info_;
}

// -------------------------------------------------------------------

// RemoteControlResponse

// optional string request_id = 1;
inline bool RemoteControlResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteControlResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteControlResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteControlResponse::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& RemoteControlResponse::request_id() const {
  return *request_id_;
}
inline void RemoteControlResponse::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void RemoteControlResponse::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void RemoteControlResponse::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteControlResponse::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* RemoteControlResponse::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteControlResponse::set_allocated_request_id(::std::string* request_id) {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    delete request_id_;
  }
  if (request_id) {
    set_has_request_id();
    request_id_ = request_id;
  } else {
    clear_has_request_id();
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_id = 2;
inline bool RemoteControlResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteControlResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteControlResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteControlResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& RemoteControlResponse::device_id() const {
  return *device_id_;
}
inline void RemoteControlResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void RemoteControlResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void RemoteControlResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteControlResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* RemoteControlResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteControlResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .RemoteControlResponseType remote_control_response_type = 3;
inline bool RemoteControlResponse::has_remote_control_response_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteControlResponse::set_has_remote_control_response_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoteControlResponse::clear_has_remote_control_response_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoteControlResponse::clear_remote_control_response_type() {
  remote_control_response_type_ = 0;
  clear_has_remote_control_response_type();
}
inline ::RemoteControlResponseType RemoteControlResponse::remote_control_response_type() const {
  return static_cast< ::RemoteControlResponseType >(remote_control_response_type_);
}
inline void RemoteControlResponse::set_remote_control_response_type(::RemoteControlResponseType value) {
  assert(::RemoteControlResponseType_IsValid(value));
  set_has_remote_control_response_type();
  remote_control_response_type_ = value;
}

// optional string failureReason = 4;
inline bool RemoteControlResponse::has_failurereason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoteControlResponse::set_has_failurereason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RemoteControlResponse::clear_has_failurereason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RemoteControlResponse::clear_failurereason() {
  if (failurereason_ != &::google::protobuf::internal::kEmptyString) {
    failurereason_->clear();
  }
  clear_has_failurereason();
}
inline const ::std::string& RemoteControlResponse::failurereason() const {
  return *failurereason_;
}
inline void RemoteControlResponse::set_failurereason(const ::std::string& value) {
  set_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    failurereason_ = new ::std::string;
  }
  failurereason_->assign(value);
}
inline void RemoteControlResponse::set_failurereason(const char* value) {
  set_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    failurereason_ = new ::std::string;
  }
  failurereason_->assign(value);
}
inline void RemoteControlResponse::set_failurereason(const char* value, size_t size) {
  set_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    failurereason_ = new ::std::string;
  }
  failurereason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteControlResponse::mutable_failurereason() {
  set_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    failurereason_ = new ::std::string;
  }
  return failurereason_;
}
inline ::std::string* RemoteControlResponse::release_failurereason() {
  clear_has_failurereason();
  if (failurereason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = failurereason_;
    failurereason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteControlResponse::set_allocated_failurereason(::std::string* failurereason) {
  if (failurereason_ != &::google::protobuf::internal::kEmptyString) {
    delete failurereason_;
  }
  if (failurereason) {
    set_has_failurereason();
    failurereason_ = failurereason;
  } else {
    clear_has_failurereason();
    failurereason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RemoteUpgradeResponse

// optional string request_id = 1;
inline bool RemoteUpgradeResponse::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteUpgradeResponse::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteUpgradeResponse::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteUpgradeResponse::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& RemoteUpgradeResponse::request_id() const {
  return *request_id_;
}
inline void RemoteUpgradeResponse::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void RemoteUpgradeResponse::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void RemoteUpgradeResponse::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteUpgradeResponse::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* RemoteUpgradeResponse::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteUpgradeResponse::set_allocated_request_id(::std::string* request_id) {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    delete request_id_;
  }
  if (request_id) {
    set_has_request_id();
    request_id_ = request_id;
  } else {
    clear_has_request_id();
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device_id = 2;
inline bool RemoteUpgradeResponse::has_device_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteUpgradeResponse::set_has_device_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteUpgradeResponse::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteUpgradeResponse::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& RemoteUpgradeResponse::device_id() const {
  return *device_id_;
}
inline void RemoteUpgradeResponse::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void RemoteUpgradeResponse::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void RemoteUpgradeResponse::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoteUpgradeResponse::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* RemoteUpgradeResponse::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RemoteUpgradeResponse::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Message_MessageType>() {
  return ::Message_MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ACPowerCharger_DeviceWorkState>() {
  return ::ACPowerCharger_DeviceWorkState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ACPowerCharger_PowerChargerType>() {
  return ::ACPowerCharger_PowerChargerType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServiceState>() {
  return ::ServiceState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServiceStateReason>() {
  return ::ServiceStateReason_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NetworkOperator>() {
  return ::NetworkOperator_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NetworkType>() {
  return ::NetworkType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChargingConnectorWorkState>() {
  return ::ChargingConnectorWorkState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChargingConnectorConnectionState>() {
  return ::ChargingConnectorConnectionState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChargingConnectorFaultState>() {
  return ::ChargingConnectorFaultState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PowerChargerConnectorOutputType>() {
  return ::PowerChargerConnectorOutputType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PowerChargerConnectorOutputVoltage>() {
  return ::PowerChargerConnectorOutputVoltage_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServiceEvent>() {
  return ::ServiceEvent_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServiceFinishResult>() {
  return ::ServiceFinishResult_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AlarmState>() {
  return ::AlarmState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LocalConfigurationInfoAccessType>() {
  return ::LocalConfigurationInfoAccessType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RemoteControlCommand>() {
  return ::RemoteControlCommand_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RemoteConfigurationResponseType>() {
  return ::RemoteConfigurationResponseType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RemoteControlResponseType>() {
  return ::RemoteControlResponseType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messageall_2eproto__INCLUDED
