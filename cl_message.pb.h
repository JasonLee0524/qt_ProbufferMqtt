// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cl_message.proto

#ifndef PROTOBUF_cl_5fmessage_2eproto__INCLUDED
#define PROTOBUF_cl_5fmessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace cl_message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cl_5fmessage_2eproto();
void protobuf_AssignDesc_cl_5fmessage_2eproto();
void protobuf_ShutdownFile_cl_5fmessage_2eproto();

class Base;
class CallError;
class IdToken;
class IdTagInfo;
class Transactions;
class Tariff;
class PriceScheme;
class ConfigOption;
class ConfigSection;
class RequestStart;
class RequestStart_Request;
class RequestStart_Confirm;
class RequestStop;
class RequestStop_Request;
class RequestStop_Confirm;
class GetTransactions;
class GetTransactions_Request;
class GetTransactions_Confirm;
class UpgradeFirmware;
class UpgradeFirmware_Request;
class UpgradeFirmware_Confirm;
class SetConfiguration;
class SetConfiguration_Request;
class SetConfiguration_Confirm;
class SetPricing;
class SetPricing_Request;
class SetPricing_Confirm;
class Reset;
class Reset_Request;
class Reset_Confirm;
class ParkLock;
class ParkLock_Request;
class ParkLock_Confirm;
class Authorize;
class Authorize_Request;
class Authorize_Confirm;
class TransactionStarted;
class TransactionStarted_Request;
class TransactionStarted_Confirm;
class TransactionStopped;
class TransactionStopped_Request;
class TransactionStopped_Confirm;
class TransactionRecords;
class TransactionRecords_Request;
class TransactionRecords_Confirm;
class MeasureValue;
class Measure;
class Measure_Request;
class Measure_Confirm;
class BootNotification;
class BootNotification_Request;
class BootNotification_Confirm;
class StatusNotification;
class FirmwareStatusNotifcation;
class SensorStatusNotification;
class Consumption;
class GetCost;
class GetCost_Request;
class GetCost_Confirm;
class LoginGW;
class LoginGW_Request;
class LoginGW_Confirm;
class HeartbeatGW;
class HeartbeatGW_Request;
class HeartbeatGW_Confirm;
class NetstatGW;

enum CallError_ErrorCode {
  CallError_ErrorCode_NOT_IMPLEMENTED = 0,
  CallError_ErrorCode_NOT_SUPPORTED = 1,
  CallError_ErrorCode_INTERNAL_ERROR = 2,
  CallError_ErrorCode_PROTOCOL_ERROR = 3,
  CallError_ErrorCode_SECURITY_ERROR = 4,
  CallError_ErrorCode_FORMATION_VIOLATION = 5,
  CallError_ErrorCode_PROPERTY_CONSTRAINT_VIOLATION = 6,
  CallError_ErrorCode_OCCURENCE_CONSTRAINT_VIOLATION = 7,
  CallError_ErrorCode_TYPE_CONSTRAINT_VIOLATION = 8,
  CallError_ErrorCode_GENERIC_ERROR = 9
};
bool CallError_ErrorCode_IsValid(int value);
const CallError_ErrorCode CallError_ErrorCode_ErrorCode_MIN = CallError_ErrorCode_NOT_IMPLEMENTED;
const CallError_ErrorCode CallError_ErrorCode_ErrorCode_MAX = CallError_ErrorCode_GENERIC_ERROR;
const int CallError_ErrorCode_ErrorCode_ARRAYSIZE = CallError_ErrorCode_ErrorCode_MAX + 1;

enum MSG {
  MSG_RequestStart = 1,
  MSG_RequestStop = 2,
  MSG_GetTransactions = 3,
  MSG_UpgradeFirmware = 4,
  MSG_SetConfiguration = 5,
  MSG_SetPricing = 6,
  MSG_Reset = 7,
  MSG_ParkLock = 8,
  MSG_Authorize = 32,
  MSG_TransactionStarted = 33,
  MSG_TransactionStopped = 34,
  MSG_TransactionRecords = 35,
  MSG_Measure = 36,
  MSG_BootNotification = 37,
  MSG_StatusNotification = 38,
  MSG_FirmwareStatusNotifcation = 39,
  MSG_SensorStatusNotification = 40,
  MSG_GetCost = 41,
  MSG_LoginGW = 257,
  MSG_HeartbeatGW = 258,
  MSG_NetstatGW = 259,
  MSG_UpgradeGW = 260
};
bool MSG_IsValid(int value);
const MSG MSG_MIN = MSG_RequestStart;
const MSG MSG_MAX = MSG_UpgradeGW;
const int MSG_ARRAYSIZE = MSG_MAX + 1;

enum IdType {
  ID_CHONGDIANKA = 1,
  ID_CARD_TX = 2,
  ID_PHONE_NUMBER = 3,
  ID_APP = 4,
  ID_WECHAT = 5,
  ID_BLUETOOTH = 6,
  ID_DIRECT = 7
};
bool IdType_IsValid(int value);
const IdType IdType_MIN = ID_CHONGDIANKA;
const IdType IdType_MAX = ID_DIRECT;
const int IdType_ARRAYSIZE = IdType_MAX + 1;

enum ChargerStatus {
  CSTU_Available = 1,
  CSTU_Occupied = 2,
  CSTU_Unavailable = 0
};
bool ChargerStatus_IsValid(int value);
const ChargerStatus ChargerStatus_MIN = CSTU_Unavailable;
const ChargerStatus ChargerStatus_MAX = CSTU_Occupied;
const int ChargerStatus_ARRAYSIZE = ChargerStatus_MAX + 1;

enum FirmwareStatus {
  FS_Cancelled = 1,
  FS_DownloadScheduled = 2,
  FS_DownloadStarted = 3,
  FS_DownloadPaused = 4,
  FS_DownloadResumed = 5,
  FS_DownloadFinished = 6,
  FS_DownloadAccessFailed = 7,
  FS_InstallScheduled = 8,
  FS_InstallVerificationFailed = 9,
  FS_InstallStarting = 10,
  FS_InstallRebooting = 11,
  FS_InstallFinished = 12,
  FS_InstallFailed = 13
};
bool FirmwareStatus_IsValid(int value);
const FirmwareStatus FirmwareStatus_MIN = FS_Cancelled;
const FirmwareStatus FirmwareStatus_MAX = FS_InstallFailed;
const int FirmwareStatus_ARRAYSIZE = FirmwareStatus_MAX + 1;

enum AuthorizationStatus {
  ATH_Accepted = 0,
  ATH_Blocked = 1,
  ATH_ConcurrentTx = 2,
  ATH_Expired = 3,
  ATH_Invalid = 4
};
bool AuthorizationStatus_IsValid(int value);
const AuthorizationStatus AuthorizationStatus_MIN = ATH_Accepted;
const AuthorizationStatus AuthorizationStatus_MAX = ATH_Invalid;
const int AuthorizationStatus_ARRAYSIZE = AuthorizationStatus_MAX + 1;

enum PricingUnit {
  PU_ChargingHours = 0,
  PU_OccupancyHours = 1,
  PU_Kwh = 2,
  PU_Session = 3
};
bool PricingUnit_IsValid(int value);
const PricingUnit PricingUnit_MIN = PU_ChargingHours;
const PricingUnit PricingUnit_MAX = PU_Session;
const int PricingUnit_ARRAYSIZE = PricingUnit_MAX + 1;

// ===================================================================

class Base : public ::google::protobuf::MessageLite {
 public:
  Base();
  virtual ~Base();

  Base(const Base& from);

  inline Base& operator=(const Base& from) {
    CopyFrom(from);
    return *this;
  }

  static const Base& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Base* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Base* other);

  // implements Message ----------------------------------------------

  Base* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Base& from);
  void MergeFrom(const Base& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 length = 1;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 1;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // required fixed32 cmd = 2;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 2;
  inline ::google::protobuf::uint32 cmd() const;
  inline void set_cmd(::google::protobuf::uint32 value);

  // required fixed32 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // optional bytes payload = 4;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 4;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:cl_message.Base)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::google::protobuf::int32 length_;
  ::google::protobuf::uint32 cmd_;
  ::std::string* payload_;
  ::google::protobuf::uint32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Base* default_instance_;
};
// -------------------------------------------------------------------

class CallError : public ::google::protobuf::MessageLite {
 public:
  CallError();
  virtual ~CallError();

  CallError(const CallError& from);

  inline CallError& operator=(const CallError& from) {
    CopyFrom(from);
    return *this;
  }

  static const CallError& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CallError* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CallError* other);

  // implements Message ----------------------------------------------

  CallError* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CallError& from);
  void MergeFrom(const CallError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CallError_ErrorCode ErrorCode;
  static const ErrorCode NOT_IMPLEMENTED = CallError_ErrorCode_NOT_IMPLEMENTED;
  static const ErrorCode NOT_SUPPORTED = CallError_ErrorCode_NOT_SUPPORTED;
  static const ErrorCode INTERNAL_ERROR = CallError_ErrorCode_INTERNAL_ERROR;
  static const ErrorCode PROTOCOL_ERROR = CallError_ErrorCode_PROTOCOL_ERROR;
  static const ErrorCode SECURITY_ERROR = CallError_ErrorCode_SECURITY_ERROR;
  static const ErrorCode FORMATION_VIOLATION = CallError_ErrorCode_FORMATION_VIOLATION;
  static const ErrorCode PROPERTY_CONSTRAINT_VIOLATION = CallError_ErrorCode_PROPERTY_CONSTRAINT_VIOLATION;
  static const ErrorCode OCCURENCE_CONSTRAINT_VIOLATION = CallError_ErrorCode_OCCURENCE_CONSTRAINT_VIOLATION;
  static const ErrorCode TYPE_CONSTRAINT_VIOLATION = CallError_ErrorCode_TYPE_CONSTRAINT_VIOLATION;
  static const ErrorCode GENERIC_ERROR = CallError_ErrorCode_GENERIC_ERROR;
  static inline bool ErrorCode_IsValid(int value) {
    return CallError_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    CallError_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    CallError_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    CallError_ErrorCode_ErrorCode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .cl_message.CallError.ErrorCode error_code = 2;
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  inline ::cl_message::CallError_ErrorCode error_code() const;
  inline void set_error_code(::cl_message::CallError_ErrorCode value);

  // optional string error_desc = 3;
  inline bool has_error_desc() const;
  inline void clear_error_desc();
  static const int kErrorDescFieldNumber = 3;
  inline const ::std::string& error_desc() const;
  inline void set_error_desc(const ::std::string& value);
  inline void set_error_desc(const char* value);
  inline void set_error_desc(const char* value, size_t size);
  inline ::std::string* mutable_error_desc();
  inline ::std::string* release_error_desc();
  inline void set_allocated_error_desc(::std::string* error_desc);

  // optional string error_details = 4;
  inline bool has_error_details() const;
  inline void clear_error_details();
  static const int kErrorDetailsFieldNumber = 4;
  inline const ::std::string& error_details() const;
  inline void set_error_details(const ::std::string& value);
  inline void set_error_details(const char* value);
  inline void set_error_details(const char* value, size_t size);
  inline ::std::string* mutable_error_details();
  inline ::std::string* release_error_details();
  inline void set_allocated_error_details(::std::string* error_details);

  // @@protoc_insertion_point(class_scope:cl_message.CallError)
 private:
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_error_desc();
  inline void clear_has_error_desc();
  inline void set_has_error_details();
  inline void clear_has_error_details();

  ::std::string* error_desc_;
  ::std::string* error_details_;
  int error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static CallError* default_instance_;
};
// -------------------------------------------------------------------

class IdToken : public ::google::protobuf::MessageLite {
 public:
  IdToken();
  virtual ~IdToken();

  IdToken(const IdToken& from);

  inline IdToken& operator=(const IdToken& from) {
    CopyFrom(from);
    return *this;
  }

  static const IdToken& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IdToken* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IdToken* other);

  // implements Message ----------------------------------------------

  IdToken* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IdToken& from);
  void MergeFrom(const IdToken& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional .cl_message.IdType id_type = 2;
  inline bool has_id_type() const;
  inline void clear_id_type();
  static const int kIdTypeFieldNumber = 2;
  inline ::cl_message::IdType id_type() const;
  inline void set_id_type(::cl_message::IdType value);

  // @@protoc_insertion_point(class_scope:cl_message.IdToken)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_id_type();
  inline void clear_has_id_type();

  ::std::string* id_;
  int id_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static IdToken* default_instance_;
};
// -------------------------------------------------------------------

class IdTagInfo : public ::google::protobuf::MessageLite {
 public:
  IdTagInfo();
  virtual ~IdTagInfo();

  IdTagInfo(const IdTagInfo& from);

  inline IdTagInfo& operator=(const IdTagInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const IdTagInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IdTagInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IdTagInfo* other);

  // implements Message ----------------------------------------------

  IdTagInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IdTagInfo& from);
  void MergeFrom(const IdTagInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 expiry_date = 1;
  inline bool has_expiry_date() const;
  inline void clear_expiry_date();
  static const int kExpiryDateFieldNumber = 1;
  inline ::google::protobuf::int32 expiry_date() const;
  inline void set_expiry_date(::google::protobuf::int32 value);

  // optional string group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline const ::std::string& group_id() const;
  inline void set_group_id(const ::std::string& value);
  inline void set_group_id(const char* value);
  inline void set_group_id(const char* value, size_t size);
  inline ::std::string* mutable_group_id();
  inline ::std::string* release_group_id();
  inline void set_allocated_group_id(::std::string* group_id);

  // required .cl_message.AuthorizationStatus status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::cl_message::AuthorizationStatus status() const;
  inline void set_status(::cl_message::AuthorizationStatus value);

  // @@protoc_insertion_point(class_scope:cl_message.IdTagInfo)
 private:
  inline void set_has_expiry_date();
  inline void clear_has_expiry_date();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::std::string* group_id_;
  ::google::protobuf::int32 expiry_date_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static IdTagInfo* default_instance_;
};
// -------------------------------------------------------------------

class Transactions : public ::google::protobuf::MessageLite {
 public:
  Transactions();
  virtual ~Transactions();

  Transactions(const Transactions& from);

  inline Transactions& operator=(const Transactions& from) {
    CopyFrom(from);
    return *this;
  }

  static const Transactions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Transactions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Transactions* other);

  // implements Message ----------------------------------------------

  Transactions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Transactions& from);
  void MergeFrom(const Transactions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 transaction_id = 1;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 transaction_id() const;
  inline void set_transaction_id(::google::protobuf::uint64 value);

  // optional int32 connector_id = 2;
  inline bool has_connector_id() const;
  inline void clear_connector_id();
  static const int kConnectorIdFieldNumber = 2;
  inline ::google::protobuf::int32 connector_id() const;
  inline void set_connector_id(::google::protobuf::int32 value);

  // required .cl_message.IdToken id_tag = 3;
  inline bool has_id_tag() const;
  inline void clear_id_tag();
  static const int kIdTagFieldNumber = 3;
  inline const ::cl_message::IdToken& id_tag() const;
  inline ::cl_message::IdToken* mutable_id_tag();
  inline ::cl_message::IdToken* release_id_tag();
  inline void set_allocated_id_tag(::cl_message::IdToken* id_tag);

  // required int32 meter_start = 4;
  inline bool has_meter_start() const;
  inline void clear_meter_start();
  static const int kMeterStartFieldNumber = 4;
  inline ::google::protobuf::int32 meter_start() const;
  inline void set_meter_start(::google::protobuf::int32 value);

  // required int32 meter_stop = 5;
  inline bool has_meter_stop() const;
  inline void clear_meter_stop();
  static const int kMeterStopFieldNumber = 5;
  inline ::google::protobuf::int32 meter_stop() const;
  inline void set_meter_stop(::google::protobuf::int32 value);

  // required int32 time_start = 6;
  inline bool has_time_start() const;
  inline void clear_time_start();
  static const int kTimeStartFieldNumber = 6;
  inline ::google::protobuf::int32 time_start() const;
  inline void set_time_start(::google::protobuf::int32 value);

  // required int32 time_stop = 7;
  inline bool has_time_stop() const;
  inline void clear_time_stop();
  static const int kTimeStopFieldNumber = 7;
  inline ::google::protobuf::int32 time_stop() const;
  inline void set_time_stop(::google::protobuf::int32 value);

  // optional .cl_message.PriceScheme price_scheme = 8;
  inline bool has_price_scheme() const;
  inline void clear_price_scheme();
  static const int kPriceSchemeFieldNumber = 8;
  inline const ::cl_message::PriceScheme& price_scheme() const;
  inline ::cl_message::PriceScheme* mutable_price_scheme();
  inline ::cl_message::PriceScheme* release_price_scheme();
  inline void set_allocated_price_scheme(::cl_message::PriceScheme* price_scheme);

  // required int32 stop_reason = 9;
  inline bool has_stop_reason() const;
  inline void clear_stop_reason();
  static const int kStopReasonFieldNumber = 9;
  inline ::google::protobuf::int32 stop_reason() const;
  inline void set_stop_reason(::google::protobuf::int32 value);

  // optional int32 time_spent_charging = 10;
  inline bool has_time_spent_charging() const;
  inline void clear_time_spent_charging();
  static const int kTimeSpentChargingFieldNumber = 10;
  inline ::google::protobuf::int32 time_spent_charging() const;
  inline void set_time_spent_charging(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.Transactions)
 private:
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_connector_id();
  inline void clear_has_connector_id();
  inline void set_has_id_tag();
  inline void clear_has_id_tag();
  inline void set_has_meter_start();
  inline void clear_has_meter_start();
  inline void set_has_meter_stop();
  inline void clear_has_meter_stop();
  inline void set_has_time_start();
  inline void clear_has_time_start();
  inline void set_has_time_stop();
  inline void clear_has_time_stop();
  inline void set_has_price_scheme();
  inline void clear_has_price_scheme();
  inline void set_has_stop_reason();
  inline void clear_has_stop_reason();
  inline void set_has_time_spent_charging();
  inline void clear_has_time_spent_charging();

  ::google::protobuf::uint64 transaction_id_;
  ::cl_message::IdToken* id_tag_;
  ::google::protobuf::int32 connector_id_;
  ::google::protobuf::int32 meter_start_;
  ::google::protobuf::int32 meter_stop_;
  ::google::protobuf::int32 time_start_;
  ::cl_message::PriceScheme* price_scheme_;
  ::google::protobuf::int32 time_stop_;
  ::google::protobuf::int32 stop_reason_;
  ::google::protobuf::int32 time_spent_charging_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Transactions* default_instance_;
};
// -------------------------------------------------------------------

class Tariff : public ::google::protobuf::MessageLite {
 public:
  Tariff();
  virtual ~Tariff();

  Tariff(const Tariff& from);

  inline Tariff& operator=(const Tariff& from) {
    CopyFrom(from);
    return *this;
  }

  static const Tariff& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Tariff* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Tariff* other);

  // implements Message ----------------------------------------------

  Tariff* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Tariff& from);
  void MergeFrom(const Tariff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tariffid = 1;
  inline bool has_tariffid() const;
  inline void clear_tariffid();
  static const int kTariffidFieldNumber = 1;
  inline ::google::protobuf::int32 tariffid() const;
  inline void set_tariffid(::google::protobuf::int32 value);

  // optional string display_text = 2;
  inline bool has_display_text() const;
  inline void clear_display_text();
  static const int kDisplayTextFieldNumber = 2;
  inline const ::std::string& display_text() const;
  inline void set_display_text(const ::std::string& value);
  inline void set_display_text(const char* value);
  inline void set_display_text(const char* value, size_t size);
  inline ::std::string* mutable_display_text();
  inline ::std::string* release_display_text();
  inline void set_allocated_display_text(::std::string* display_text);

  // optional .cl_message.PricingUnit price_unit = 3;
  inline bool has_price_unit() const;
  inline void clear_price_unit();
  static const int kPriceUnitFieldNumber = 3;
  inline ::cl_message::PricingUnit price_unit() const;
  inline void set_price_unit(::cl_message::PricingUnit value);

  // required int32 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.Tariff)
 private:
  inline void set_has_tariffid();
  inline void clear_has_tariffid();
  inline void set_has_display_text();
  inline void clear_has_display_text();
  inline void set_has_price_unit();
  inline void clear_has_price_unit();
  inline void set_has_price();
  inline void clear_has_price();

  ::std::string* display_text_;
  ::google::protobuf::int32 tariffid_;
  int price_unit_;
  ::google::protobuf::int32 price_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Tariff* default_instance_;
};
// -------------------------------------------------------------------

class PriceScheme : public ::google::protobuf::MessageLite {
 public:
  PriceScheme();
  virtual ~PriceScheme();

  PriceScheme(const PriceScheme& from);

  inline PriceScheme& operator=(const PriceScheme& from) {
    CopyFrom(from);
    return *this;
  }

  static const PriceScheme& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PriceScheme* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PriceScheme* other);

  // implements Message ----------------------------------------------

  PriceScheme* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PriceScheme& from);
  void MergeFrom(const PriceScheme& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 price_scheme_id = 1;
  inline bool has_price_scheme_id() const;
  inline void clear_price_scheme_id();
  static const int kPriceSchemeIdFieldNumber = 1;
  inline ::google::protobuf::int32 price_scheme_id() const;
  inline void set_price_scheme_id(::google::protobuf::int32 value);

  // optional string display_text = 2;
  inline bool has_display_text() const;
  inline void clear_display_text();
  static const int kDisplayTextFieldNumber = 2;
  inline const ::std::string& display_text() const;
  inline void set_display_text(const ::std::string& value);
  inline void set_display_text(const char* value);
  inline void set_display_text(const char* value, size_t size);
  inline ::std::string* mutable_display_text();
  inline ::std::string* release_display_text();
  inline void set_allocated_display_text(::std::string* display_text);

  // optional int32 expiry_date = 3;
  inline bool has_expiry_date() const;
  inline void clear_expiry_date();
  static const int kExpiryDateFieldNumber = 3;
  inline ::google::protobuf::int32 expiry_date() const;
  inline void set_expiry_date(::google::protobuf::int32 value);

  // repeated .cl_message.Tariff tariff = 4;
  inline int tariff_size() const;
  inline void clear_tariff();
  static const int kTariffFieldNumber = 4;
  inline const ::cl_message::Tariff& tariff(int index) const;
  inline ::cl_message::Tariff* mutable_tariff(int index);
  inline ::cl_message::Tariff* add_tariff();
  inline const ::google::protobuf::RepeatedPtrField< ::cl_message::Tariff >&
      tariff() const;
  inline ::google::protobuf::RepeatedPtrField< ::cl_message::Tariff >*
      mutable_tariff();

  // @@protoc_insertion_point(class_scope:cl_message.PriceScheme)
 private:
  inline void set_has_price_scheme_id();
  inline void clear_has_price_scheme_id();
  inline void set_has_display_text();
  inline void clear_has_display_text();
  inline void set_has_expiry_date();
  inline void clear_has_expiry_date();

  ::std::string* display_text_;
  ::google::protobuf::int32 price_scheme_id_;
  ::google::protobuf::int32 expiry_date_;
  ::google::protobuf::RepeatedPtrField< ::cl_message::Tariff > tariff_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static PriceScheme* default_instance_;
};
// -------------------------------------------------------------------

class ConfigOption : public ::google::protobuf::MessageLite {
 public:
  ConfigOption();
  virtual ~ConfigOption();

  ConfigOption(const ConfigOption& from);

  inline ConfigOption& operator=(const ConfigOption& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConfigOption& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfigOption* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConfigOption* other);

  // implements Message ----------------------------------------------

  ConfigOption* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfigOption& from);
  void MergeFrom(const ConfigOption& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:cl_message.ConfigOption)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ConfigOption* default_instance_;
};
// -------------------------------------------------------------------

class ConfigSection : public ::google::protobuf::MessageLite {
 public:
  ConfigSection();
  virtual ~ConfigSection();

  ConfigSection(const ConfigSection& from);

  inline ConfigSection& operator=(const ConfigSection& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConfigSection& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ConfigSection* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ConfigSection* other);

  // implements Message ----------------------------------------------

  ConfigSection* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ConfigSection& from);
  void MergeFrom(const ConfigSection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string section = 1;
  inline bool has_section() const;
  inline void clear_section();
  static const int kSectionFieldNumber = 1;
  inline const ::std::string& section() const;
  inline void set_section(const ::std::string& value);
  inline void set_section(const char* value);
  inline void set_section(const char* value, size_t size);
  inline ::std::string* mutable_section();
  inline ::std::string* release_section();
  inline void set_allocated_section(::std::string* section);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // repeated .cl_message.ConfigOption options = 4;
  inline int options_size() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 4;
  inline const ::cl_message::ConfigOption& options(int index) const;
  inline ::cl_message::ConfigOption* mutable_options(int index);
  inline ::cl_message::ConfigOption* add_options();
  inline const ::google::protobuf::RepeatedPtrField< ::cl_message::ConfigOption >&
      options() const;
  inline ::google::protobuf::RepeatedPtrField< ::cl_message::ConfigOption >*
      mutable_options();

  // @@protoc_insertion_point(class_scope:cl_message.ConfigSection)
 private:
  inline void set_has_section();
  inline void clear_has_section();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* section_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::cl_message::ConfigOption > options_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ConfigSection* default_instance_;
};
// -------------------------------------------------------------------

class RequestStart_Request : public ::google::protobuf::MessageLite {
 public:
  RequestStart_Request();
  virtual ~RequestStart_Request();

  RequestStart_Request(const RequestStart_Request& from);

  inline RequestStart_Request& operator=(const RequestStart_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestStart_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestStart_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestStart_Request* other);

  // implements Message ----------------------------------------------

  RequestStart_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestStart_Request& from);
  void MergeFrom(const RequestStart_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 connector_id = 1;
  inline bool has_connector_id() const;
  inline void clear_connector_id();
  static const int kConnectorIdFieldNumber = 1;
  inline ::google::protobuf::int32 connector_id() const;
  inline void set_connector_id(::google::protobuf::int32 value);

  // required .cl_message.IdToken id_tag = 2;
  inline bool has_id_tag() const;
  inline void clear_id_tag();
  static const int kIdTagFieldNumber = 2;
  inline const ::cl_message::IdToken& id_tag() const;
  inline ::cl_message::IdToken* mutable_id_tag();
  inline ::cl_message::IdToken* release_id_tag();
  inline void set_allocated_id_tag(::cl_message::IdToken* id_tag);

  // optional string pin_code = 3;
  inline bool has_pin_code() const;
  inline void clear_pin_code();
  static const int kPinCodeFieldNumber = 3;
  inline const ::std::string& pin_code() const;
  inline void set_pin_code(const ::std::string& value);
  inline void set_pin_code(const char* value);
  inline void set_pin_code(const char* value, size_t size);
  inline ::std::string* mutable_pin_code();
  inline ::std::string* release_pin_code();
  inline void set_allocated_pin_code(::std::string* pin_code);

  // optional string transparent = 4;
  inline bool has_transparent() const;
  inline void clear_transparent();
  static const int kTransparentFieldNumber = 4;
  inline const ::std::string& transparent() const;
  inline void set_transparent(const ::std::string& value);
  inline void set_transparent(const char* value);
  inline void set_transparent(const char* value, size_t size);
  inline ::std::string* mutable_transparent();
  inline ::std::string* release_transparent();
  inline void set_allocated_transparent(::std::string* transparent);

  // @@protoc_insertion_point(class_scope:cl_message.RequestStart.Request)
 private:
  inline void set_has_connector_id();
  inline void clear_has_connector_id();
  inline void set_has_id_tag();
  inline void clear_has_id_tag();
  inline void set_has_pin_code();
  inline void clear_has_pin_code();
  inline void set_has_transparent();
  inline void clear_has_transparent();

  ::cl_message::IdToken* id_tag_;
  ::std::string* pin_code_;
  ::std::string* transparent_;
  ::google::protobuf::int32 connector_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RequestStart_Request* default_instance_;
};
// -------------------------------------------------------------------

class RequestStart_Confirm : public ::google::protobuf::MessageLite {
 public:
  RequestStart_Confirm();
  virtual ~RequestStart_Confirm();

  RequestStart_Confirm(const RequestStart_Confirm& from);

  inline RequestStart_Confirm& operator=(const RequestStart_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestStart_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestStart_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestStart_Confirm* other);

  // implements Message ----------------------------------------------

  RequestStart_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestStart_Confirm& from);
  void MergeFrom(const RequestStart_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.RequestStart.Confirm)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RequestStart_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class RequestStart : public ::google::protobuf::MessageLite {
 public:
  RequestStart();
  virtual ~RequestStart();

  RequestStart(const RequestStart& from);

  inline RequestStart& operator=(const RequestStart& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestStart& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestStart* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestStart* other);

  // implements Message ----------------------------------------------

  RequestStart* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestStart& from);
  void MergeFrom(const RequestStart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef RequestStart_Request Request;
  typedef RequestStart_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.RequestStart.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::RequestStart_Request& req() const;
  inline ::cl_message::RequestStart_Request* mutable_req();
  inline ::cl_message::RequestStart_Request* release_req();
  inline void set_allocated_req(::cl_message::RequestStart_Request* req);

  // optional .cl_message.RequestStart.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::RequestStart_Confirm& conf() const;
  inline ::cl_message::RequestStart_Confirm* mutable_conf();
  inline ::cl_message::RequestStart_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::RequestStart_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.RequestStart)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::RequestStart_Request* req_;
  ::cl_message::RequestStart_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RequestStart* default_instance_;
};
// -------------------------------------------------------------------

class RequestStop_Request : public ::google::protobuf::MessageLite {
 public:
  RequestStop_Request();
  virtual ~RequestStop_Request();

  RequestStop_Request(const RequestStop_Request& from);

  inline RequestStop_Request& operator=(const RequestStop_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestStop_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestStop_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestStop_Request* other);

  // implements Message ----------------------------------------------

  RequestStop_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestStop_Request& from);
  void MergeFrom(const RequestStop_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 transaction_id = 1;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 transaction_id() const;
  inline void set_transaction_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cl_message.RequestStop.Request)
 private:
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();

  ::google::protobuf::uint64 transaction_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RequestStop_Request* default_instance_;
};
// -------------------------------------------------------------------

class RequestStop_Confirm : public ::google::protobuf::MessageLite {
 public:
  RequestStop_Confirm();
  virtual ~RequestStop_Confirm();

  RequestStop_Confirm(const RequestStop_Confirm& from);

  inline RequestStop_Confirm& operator=(const RequestStop_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestStop_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestStop_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestStop_Confirm* other);

  // implements Message ----------------------------------------------

  RequestStop_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestStop_Confirm& from);
  void MergeFrom(const RequestStop_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.RequestStop.Confirm)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RequestStop_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class RequestStop : public ::google::protobuf::MessageLite {
 public:
  RequestStop();
  virtual ~RequestStop();

  RequestStop(const RequestStop& from);

  inline RequestStop& operator=(const RequestStop& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestStop& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestStop* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestStop* other);

  // implements Message ----------------------------------------------

  RequestStop* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestStop& from);
  void MergeFrom(const RequestStop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef RequestStop_Request Request;
  typedef RequestStop_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.RequestStop.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::RequestStop_Request& req() const;
  inline ::cl_message::RequestStop_Request* mutable_req();
  inline ::cl_message::RequestStop_Request* release_req();
  inline void set_allocated_req(::cl_message::RequestStop_Request* req);

  // optional .cl_message.RequestStop.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::RequestStop_Confirm& conf() const;
  inline ::cl_message::RequestStop_Confirm* mutable_conf();
  inline ::cl_message::RequestStop_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::RequestStop_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.RequestStop)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::RequestStop_Request* req_;
  ::cl_message::RequestStop_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RequestStop* default_instance_;
};
// -------------------------------------------------------------------

class GetTransactions_Request : public ::google::protobuf::MessageLite {
 public:
  GetTransactions_Request();
  virtual ~GetTransactions_Request();

  GetTransactions_Request(const GetTransactions_Request& from);

  inline GetTransactions_Request& operator=(const GetTransactions_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetTransactions_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTransactions_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTransactions_Request* other);

  // implements Message ----------------------------------------------

  GetTransactions_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTransactions_Request& from);
  void MergeFrom(const GetTransactions_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 start_time = 1;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::int32 start_time() const;
  inline void set_start_time(::google::protobuf::int32 value);

  // optional int32 end_time = 2;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::int32 end_time() const;
  inline void set_end_time(::google::protobuf::int32 value);

  // optional int32 pos = 3;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 3;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // optional int32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.GetTransactions.Request)
 private:
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_end_time();
  inline void clear_has_end_time();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::int32 start_time_;
  ::google::protobuf::int32 end_time_;
  ::google::protobuf::int32 pos_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static GetTransactions_Request* default_instance_;
};
// -------------------------------------------------------------------

class GetTransactions_Confirm : public ::google::protobuf::MessageLite {
 public:
  GetTransactions_Confirm();
  virtual ~GetTransactions_Confirm();

  GetTransactions_Confirm(const GetTransactions_Confirm& from);

  inline GetTransactions_Confirm& operator=(const GetTransactions_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetTransactions_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTransactions_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTransactions_Confirm* other);

  // implements Message ----------------------------------------------

  GetTransactions_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTransactions_Confirm& from);
  void MergeFrom(const GetTransactions_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.GetTransactions.Confirm)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static GetTransactions_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class GetTransactions : public ::google::protobuf::MessageLite {
 public:
  GetTransactions();
  virtual ~GetTransactions();

  GetTransactions(const GetTransactions& from);

  inline GetTransactions& operator=(const GetTransactions& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetTransactions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTransactions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTransactions* other);

  // implements Message ----------------------------------------------

  GetTransactions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTransactions& from);
  void MergeFrom(const GetTransactions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GetTransactions_Request Request;
  typedef GetTransactions_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.GetTransactions.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::GetTransactions_Request& req() const;
  inline ::cl_message::GetTransactions_Request* mutable_req();
  inline ::cl_message::GetTransactions_Request* release_req();
  inline void set_allocated_req(::cl_message::GetTransactions_Request* req);

  // optional .cl_message.GetTransactions.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::GetTransactions_Confirm& conf() const;
  inline ::cl_message::GetTransactions_Confirm* mutable_conf();
  inline ::cl_message::GetTransactions_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::GetTransactions_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.GetTransactions)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::GetTransactions_Request* req_;
  ::cl_message::GetTransactions_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static GetTransactions* default_instance_;
};
// -------------------------------------------------------------------

class UpgradeFirmware_Request : public ::google::protobuf::MessageLite {
 public:
  UpgradeFirmware_Request();
  virtual ~UpgradeFirmware_Request();

  UpgradeFirmware_Request(const UpgradeFirmware_Request& from);

  inline UpgradeFirmware_Request& operator=(const UpgradeFirmware_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpgradeFirmware_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpgradeFirmware_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpgradeFirmware_Request* other);

  // implements Message ----------------------------------------------

  UpgradeFirmware_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpgradeFirmware_Request& from);
  void MergeFrom(const UpgradeFirmware_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string location = 1;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 1;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // required string md5 = 2;
  inline bool has_md5() const;
  inline void clear_md5();
  static const int kMd5FieldNumber = 2;
  inline const ::std::string& md5() const;
  inline void set_md5(const ::std::string& value);
  inline void set_md5(const char* value);
  inline void set_md5(const char* value, size_t size);
  inline ::std::string* mutable_md5();
  inline ::std::string* release_md5();
  inline void set_allocated_md5(::std::string* md5);

  // optional int32 retries = 3;
  inline bool has_retries() const;
  inline void clear_retries();
  static const int kRetriesFieldNumber = 3;
  inline ::google::protobuf::int32 retries() const;
  inline void set_retries(::google::protobuf::int32 value);

  // optional string retrieve_date = 4;
  inline bool has_retrieve_date() const;
  inline void clear_retrieve_date();
  static const int kRetrieveDateFieldNumber = 4;
  inline const ::std::string& retrieve_date() const;
  inline void set_retrieve_date(const ::std::string& value);
  inline void set_retrieve_date(const char* value);
  inline void set_retrieve_date(const char* value, size_t size);
  inline ::std::string* mutable_retrieve_date();
  inline ::std::string* release_retrieve_date();
  inline void set_allocated_retrieve_date(::std::string* retrieve_date);

  // optional int32 retry_interval = 5;
  inline bool has_retry_interval() const;
  inline void clear_retry_interval();
  static const int kRetryIntervalFieldNumber = 5;
  inline ::google::protobuf::int32 retry_interval() const;
  inline void set_retry_interval(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.UpgradeFirmware.Request)
 private:
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_md5();
  inline void clear_has_md5();
  inline void set_has_retries();
  inline void clear_has_retries();
  inline void set_has_retrieve_date();
  inline void clear_has_retrieve_date();
  inline void set_has_retry_interval();
  inline void clear_has_retry_interval();

  ::std::string* location_;
  ::std::string* md5_;
  ::std::string* retrieve_date_;
  ::google::protobuf::int32 retries_;
  ::google::protobuf::int32 retry_interval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static UpgradeFirmware_Request* default_instance_;
};
// -------------------------------------------------------------------

class UpgradeFirmware_Confirm : public ::google::protobuf::MessageLite {
 public:
  UpgradeFirmware_Confirm();
  virtual ~UpgradeFirmware_Confirm();

  UpgradeFirmware_Confirm(const UpgradeFirmware_Confirm& from);

  inline UpgradeFirmware_Confirm& operator=(const UpgradeFirmware_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpgradeFirmware_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpgradeFirmware_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpgradeFirmware_Confirm* other);

  // implements Message ----------------------------------------------

  UpgradeFirmware_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpgradeFirmware_Confirm& from);
  void MergeFrom(const UpgradeFirmware_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.UpgradeFirmware.Confirm)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static UpgradeFirmware_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class UpgradeFirmware : public ::google::protobuf::MessageLite {
 public:
  UpgradeFirmware();
  virtual ~UpgradeFirmware();

  UpgradeFirmware(const UpgradeFirmware& from);

  inline UpgradeFirmware& operator=(const UpgradeFirmware& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpgradeFirmware& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpgradeFirmware* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpgradeFirmware* other);

  // implements Message ----------------------------------------------

  UpgradeFirmware* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpgradeFirmware& from);
  void MergeFrom(const UpgradeFirmware& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UpgradeFirmware_Request Request;
  typedef UpgradeFirmware_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.UpgradeFirmware.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::UpgradeFirmware_Request& req() const;
  inline ::cl_message::UpgradeFirmware_Request* mutable_req();
  inline ::cl_message::UpgradeFirmware_Request* release_req();
  inline void set_allocated_req(::cl_message::UpgradeFirmware_Request* req);

  // optional .cl_message.UpgradeFirmware.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::UpgradeFirmware_Confirm& conf() const;
  inline ::cl_message::UpgradeFirmware_Confirm* mutable_conf();
  inline ::cl_message::UpgradeFirmware_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::UpgradeFirmware_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.UpgradeFirmware)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::UpgradeFirmware_Request* req_;
  ::cl_message::UpgradeFirmware_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static UpgradeFirmware* default_instance_;
};
// -------------------------------------------------------------------

class SetConfiguration_Request : public ::google::protobuf::MessageLite {
 public:
  SetConfiguration_Request();
  virtual ~SetConfiguration_Request();

  SetConfiguration_Request(const SetConfiguration_Request& from);

  inline SetConfiguration_Request& operator=(const SetConfiguration_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const SetConfiguration_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetConfiguration_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SetConfiguration_Request* other);

  // implements Message ----------------------------------------------

  SetConfiguration_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetConfiguration_Request& from);
  void MergeFrom(const SetConfiguration_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // repeated .cl_message.ConfigSection sections = 2;
  inline int sections_size() const;
  inline void clear_sections();
  static const int kSectionsFieldNumber = 2;
  inline const ::cl_message::ConfigSection& sections(int index) const;
  inline ::cl_message::ConfigSection* mutable_sections(int index);
  inline ::cl_message::ConfigSection* add_sections();
  inline const ::google::protobuf::RepeatedPtrField< ::cl_message::ConfigSection >&
      sections() const;
  inline ::google::protobuf::RepeatedPtrField< ::cl_message::ConfigSection >*
      mutable_sections();

  // @@protoc_insertion_point(class_scope:cl_message.SetConfiguration.Request)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();

  ::std::string* filename_;
  ::google::protobuf::RepeatedPtrField< ::cl_message::ConfigSection > sections_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SetConfiguration_Request* default_instance_;
};
// -------------------------------------------------------------------

class SetConfiguration_Confirm : public ::google::protobuf::MessageLite {
 public:
  SetConfiguration_Confirm();
  virtual ~SetConfiguration_Confirm();

  SetConfiguration_Confirm(const SetConfiguration_Confirm& from);

  inline SetConfiguration_Confirm& operator=(const SetConfiguration_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const SetConfiguration_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetConfiguration_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SetConfiguration_Confirm* other);

  // implements Message ----------------------------------------------

  SetConfiguration_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetConfiguration_Confirm& from);
  void MergeFrom(const SetConfiguration_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.SetConfiguration.Confirm)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SetConfiguration_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class SetConfiguration : public ::google::protobuf::MessageLite {
 public:
  SetConfiguration();
  virtual ~SetConfiguration();

  SetConfiguration(const SetConfiguration& from);

  inline SetConfiguration& operator=(const SetConfiguration& from) {
    CopyFrom(from);
    return *this;
  }

  static const SetConfiguration& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetConfiguration* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SetConfiguration* other);

  // implements Message ----------------------------------------------

  SetConfiguration* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetConfiguration& from);
  void MergeFrom(const SetConfiguration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SetConfiguration_Request Request;
  typedef SetConfiguration_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.SetConfiguration.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::SetConfiguration_Request& req() const;
  inline ::cl_message::SetConfiguration_Request* mutable_req();
  inline ::cl_message::SetConfiguration_Request* release_req();
  inline void set_allocated_req(::cl_message::SetConfiguration_Request* req);

  // optional .cl_message.SetConfiguration.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::SetConfiguration_Confirm& conf() const;
  inline ::cl_message::SetConfiguration_Confirm* mutable_conf();
  inline ::cl_message::SetConfiguration_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::SetConfiguration_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.SetConfiguration)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::SetConfiguration_Request* req_;
  ::cl_message::SetConfiguration_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SetConfiguration* default_instance_;
};
// -------------------------------------------------------------------

class SetPricing_Request : public ::google::protobuf::MessageLite {
 public:
  SetPricing_Request();
  virtual ~SetPricing_Request();

  SetPricing_Request(const SetPricing_Request& from);

  inline SetPricing_Request& operator=(const SetPricing_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const SetPricing_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetPricing_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SetPricing_Request* other);

  // implements Message ----------------------------------------------

  SetPricing_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetPricing_Request& from);
  void MergeFrom(const SetPricing_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .cl_message.PriceScheme price_scheme = 1;
  inline bool has_price_scheme() const;
  inline void clear_price_scheme();
  static const int kPriceSchemeFieldNumber = 1;
  inline const ::cl_message::PriceScheme& price_scheme() const;
  inline ::cl_message::PriceScheme* mutable_price_scheme();
  inline ::cl_message::PriceScheme* release_price_scheme();
  inline void set_allocated_price_scheme(::cl_message::PriceScheme* price_scheme);

  // @@protoc_insertion_point(class_scope:cl_message.SetPricing.Request)
 private:
  inline void set_has_price_scheme();
  inline void clear_has_price_scheme();

  ::cl_message::PriceScheme* price_scheme_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SetPricing_Request* default_instance_;
};
// -------------------------------------------------------------------

class SetPricing_Confirm : public ::google::protobuf::MessageLite {
 public:
  SetPricing_Confirm();
  virtual ~SetPricing_Confirm();

  SetPricing_Confirm(const SetPricing_Confirm& from);

  inline SetPricing_Confirm& operator=(const SetPricing_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const SetPricing_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetPricing_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SetPricing_Confirm* other);

  // implements Message ----------------------------------------------

  SetPricing_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetPricing_Confirm& from);
  void MergeFrom(const SetPricing_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.SetPricing.Confirm)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SetPricing_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class SetPricing : public ::google::protobuf::MessageLite {
 public:
  SetPricing();
  virtual ~SetPricing();

  SetPricing(const SetPricing& from);

  inline SetPricing& operator=(const SetPricing& from) {
    CopyFrom(from);
    return *this;
  }

  static const SetPricing& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetPricing* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SetPricing* other);

  // implements Message ----------------------------------------------

  SetPricing* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetPricing& from);
  void MergeFrom(const SetPricing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SetPricing_Request Request;
  typedef SetPricing_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.SetPricing.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::SetPricing_Request& req() const;
  inline ::cl_message::SetPricing_Request* mutable_req();
  inline ::cl_message::SetPricing_Request* release_req();
  inline void set_allocated_req(::cl_message::SetPricing_Request* req);

  // optional .cl_message.SetPricing.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::SetPricing_Confirm& conf() const;
  inline ::cl_message::SetPricing_Confirm* mutable_conf();
  inline ::cl_message::SetPricing_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::SetPricing_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.SetPricing)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::SetPricing_Request* req_;
  ::cl_message::SetPricing_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SetPricing* default_instance_;
};
// -------------------------------------------------------------------

class Reset_Request : public ::google::protobuf::MessageLite {
 public:
  Reset_Request();
  virtual ~Reset_Request();

  Reset_Request(const Reset_Request& from);

  inline Reset_Request& operator=(const Reset_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const Reset_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Reset_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Reset_Request* other);

  // implements Message ----------------------------------------------

  Reset_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Reset_Request& from);
  void MergeFrom(const Reset_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 reset_type = 1;
  inline bool has_reset_type() const;
  inline void clear_reset_type();
  static const int kResetTypeFieldNumber = 1;
  inline ::google::protobuf::int32 reset_type() const;
  inline void set_reset_type(::google::protobuf::int32 value);

  // optional int32 connector_id = 2;
  inline bool has_connector_id() const;
  inline void clear_connector_id();
  static const int kConnectorIdFieldNumber = 2;
  inline ::google::protobuf::int32 connector_id() const;
  inline void set_connector_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.Reset.Request)
 private:
  inline void set_has_reset_type();
  inline void clear_has_reset_type();
  inline void set_has_connector_id();
  inline void clear_has_connector_id();

  ::google::protobuf::int32 reset_type_;
  ::google::protobuf::int32 connector_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Reset_Request* default_instance_;
};
// -------------------------------------------------------------------

class Reset_Confirm : public ::google::protobuf::MessageLite {
 public:
  Reset_Confirm();
  virtual ~Reset_Confirm();

  Reset_Confirm(const Reset_Confirm& from);

  inline Reset_Confirm& operator=(const Reset_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const Reset_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Reset_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Reset_Confirm* other);

  // implements Message ----------------------------------------------

  Reset_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Reset_Confirm& from);
  void MergeFrom(const Reset_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.Reset.Confirm)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Reset_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class Reset : public ::google::protobuf::MessageLite {
 public:
  Reset();
  virtual ~Reset();

  Reset(const Reset& from);

  inline Reset& operator=(const Reset& from) {
    CopyFrom(from);
    return *this;
  }

  static const Reset& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Reset* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Reset* other);

  // implements Message ----------------------------------------------

  Reset* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Reset& from);
  void MergeFrom(const Reset& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Reset_Request Request;
  typedef Reset_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.Reset.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::Reset_Request& req() const;
  inline ::cl_message::Reset_Request* mutable_req();
  inline ::cl_message::Reset_Request* release_req();
  inline void set_allocated_req(::cl_message::Reset_Request* req);

  // optional .cl_message.Reset.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::Reset_Confirm& conf() const;
  inline ::cl_message::Reset_Confirm* mutable_conf();
  inline ::cl_message::Reset_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::Reset_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.Reset)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::Reset_Request* req_;
  ::cl_message::Reset_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Reset* default_instance_;
};
// -------------------------------------------------------------------

class ParkLock_Request : public ::google::protobuf::MessageLite {
 public:
  ParkLock_Request();
  virtual ~ParkLock_Request();

  ParkLock_Request(const ParkLock_Request& from);

  inline ParkLock_Request& operator=(const ParkLock_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const ParkLock_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ParkLock_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ParkLock_Request* other);

  // implements Message ----------------------------------------------

  ParkLock_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ParkLock_Request& from);
  void MergeFrom(const ParkLock_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 lockid = 1;
  inline bool has_lockid() const;
  inline void clear_lockid();
  static const int kLockidFieldNumber = 1;
  inline ::google::protobuf::int32 lockid() const;
  inline void set_lockid(::google::protobuf::int32 value);

  // required int32 lock = 2;
  inline bool has_lock() const;
  inline void clear_lock();
  static const int kLockFieldNumber = 2;
  inline ::google::protobuf::int32 lock() const;
  inline void set_lock(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.ParkLock.Request)
 private:
  inline void set_has_lockid();
  inline void clear_has_lockid();
  inline void set_has_lock();
  inline void clear_has_lock();

  ::google::protobuf::int32 lockid_;
  ::google::protobuf::int32 lock_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ParkLock_Request* default_instance_;
};
// -------------------------------------------------------------------

class ParkLock_Confirm : public ::google::protobuf::MessageLite {
 public:
  ParkLock_Confirm();
  virtual ~ParkLock_Confirm();

  ParkLock_Confirm(const ParkLock_Confirm& from);

  inline ParkLock_Confirm& operator=(const ParkLock_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const ParkLock_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ParkLock_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ParkLock_Confirm* other);

  // implements Message ----------------------------------------------

  ParkLock_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ParkLock_Confirm& from);
  void MergeFrom(const ParkLock_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.ParkLock.Confirm)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ParkLock_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class ParkLock : public ::google::protobuf::MessageLite {
 public:
  ParkLock();
  virtual ~ParkLock();

  ParkLock(const ParkLock& from);

  inline ParkLock& operator=(const ParkLock& from) {
    CopyFrom(from);
    return *this;
  }

  static const ParkLock& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ParkLock* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ParkLock* other);

  // implements Message ----------------------------------------------

  ParkLock* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ParkLock& from);
  void MergeFrom(const ParkLock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ParkLock_Request Request;
  typedef ParkLock_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.ParkLock.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::ParkLock_Request& req() const;
  inline ::cl_message::ParkLock_Request* mutable_req();
  inline ::cl_message::ParkLock_Request* release_req();
  inline void set_allocated_req(::cl_message::ParkLock_Request* req);

  // optional .cl_message.ParkLock.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::ParkLock_Confirm& conf() const;
  inline ::cl_message::ParkLock_Confirm* mutable_conf();
  inline ::cl_message::ParkLock_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::ParkLock_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.ParkLock)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::ParkLock_Request* req_;
  ::cl_message::ParkLock_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ParkLock* default_instance_;
};
// -------------------------------------------------------------------

class Authorize_Request : public ::google::protobuf::MessageLite {
 public:
  Authorize_Request();
  virtual ~Authorize_Request();

  Authorize_Request(const Authorize_Request& from);

  inline Authorize_Request& operator=(const Authorize_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const Authorize_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Authorize_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Authorize_Request* other);

  // implements Message ----------------------------------------------

  Authorize_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Authorize_Request& from);
  void MergeFrom(const Authorize_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .cl_message.IdToken id_tag = 1;
  inline bool has_id_tag() const;
  inline void clear_id_tag();
  static const int kIdTagFieldNumber = 1;
  inline const ::cl_message::IdToken& id_tag() const;
  inline ::cl_message::IdToken* mutable_id_tag();
  inline ::cl_message::IdToken* release_id_tag();
  inline void set_allocated_id_tag(::cl_message::IdToken* id_tag);

  // @@protoc_insertion_point(class_scope:cl_message.Authorize.Request)
 private:
  inline void set_has_id_tag();
  inline void clear_has_id_tag();

  ::cl_message::IdToken* id_tag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Authorize_Request* default_instance_;
};
// -------------------------------------------------------------------

class Authorize_Confirm : public ::google::protobuf::MessageLite {
 public:
  Authorize_Confirm();
  virtual ~Authorize_Confirm();

  Authorize_Confirm(const Authorize_Confirm& from);

  inline Authorize_Confirm& operator=(const Authorize_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const Authorize_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Authorize_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Authorize_Confirm* other);

  // implements Message ----------------------------------------------

  Authorize_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Authorize_Confirm& from);
  void MergeFrom(const Authorize_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cl_message.IdTagInfo id_info = 1;
  inline bool has_id_info() const;
  inline void clear_id_info();
  static const int kIdInfoFieldNumber = 1;
  inline const ::cl_message::IdTagInfo& id_info() const;
  inline ::cl_message::IdTagInfo* mutable_id_info();
  inline ::cl_message::IdTagInfo* release_id_info();
  inline void set_allocated_id_info(::cl_message::IdTagInfo* id_info);

  // optional int32 price_scheme_id = 2;
  inline bool has_price_scheme_id() const;
  inline void clear_price_scheme_id();
  static const int kPriceSchemeIdFieldNumber = 2;
  inline ::google::protobuf::int32 price_scheme_id() const;
  inline void set_price_scheme_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.Authorize.Confirm)
 private:
  inline void set_has_id_info();
  inline void clear_has_id_info();
  inline void set_has_price_scheme_id();
  inline void clear_has_price_scheme_id();

  ::cl_message::IdTagInfo* id_info_;
  ::google::protobuf::int32 price_scheme_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Authorize_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class Authorize : public ::google::protobuf::MessageLite {
 public:
  Authorize();
  virtual ~Authorize();

  Authorize(const Authorize& from);

  inline Authorize& operator=(const Authorize& from) {
    CopyFrom(from);
    return *this;
  }

  static const Authorize& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Authorize* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Authorize* other);

  // implements Message ----------------------------------------------

  Authorize* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Authorize& from);
  void MergeFrom(const Authorize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Authorize_Request Request;
  typedef Authorize_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.Authorize.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::Authorize_Request& req() const;
  inline ::cl_message::Authorize_Request* mutable_req();
  inline ::cl_message::Authorize_Request* release_req();
  inline void set_allocated_req(::cl_message::Authorize_Request* req);

  // optional .cl_message.Authorize.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::Authorize_Confirm& conf() const;
  inline ::cl_message::Authorize_Confirm* mutable_conf();
  inline ::cl_message::Authorize_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::Authorize_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.Authorize)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::Authorize_Request* req_;
  ::cl_message::Authorize_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Authorize* default_instance_;
};
// -------------------------------------------------------------------

class TransactionStarted_Request : public ::google::protobuf::MessageLite {
 public:
  TransactionStarted_Request();
  virtual ~TransactionStarted_Request();

  TransactionStarted_Request(const TransactionStarted_Request& from);

  inline TransactionStarted_Request& operator=(const TransactionStarted_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransactionStarted_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransactionStarted_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransactionStarted_Request* other);

  // implements Message ----------------------------------------------

  TransactionStarted_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransactionStarted_Request& from);
  void MergeFrom(const TransactionStarted_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 connector_id = 1;
  inline bool has_connector_id() const;
  inline void clear_connector_id();
  static const int kConnectorIdFieldNumber = 1;
  inline ::google::protobuf::int32 connector_id() const;
  inline void set_connector_id(::google::protobuf::int32 value);

  // required .cl_message.IdToken id_tag = 2;
  inline bool has_id_tag() const;
  inline void clear_id_tag();
  static const int kIdTagFieldNumber = 2;
  inline const ::cl_message::IdToken& id_tag() const;
  inline ::cl_message::IdToken* mutable_id_tag();
  inline ::cl_message::IdToken* release_id_tag();
  inline void set_allocated_id_tag(::cl_message::IdToken* id_tag);

  // required int32 meter_start = 3;
  inline bool has_meter_start() const;
  inline void clear_meter_start();
  static const int kMeterStartFieldNumber = 3;
  inline ::google::protobuf::int32 meter_start() const;
  inline void set_meter_start(::google::protobuf::int32 value);

  // required int32 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // optional int32 price_scheme_id = 5;
  inline bool has_price_scheme_id() const;
  inline void clear_price_scheme_id();
  static const int kPriceSchemeIdFieldNumber = 5;
  inline ::google::protobuf::int32 price_scheme_id() const;
  inline void set_price_scheme_id(::google::protobuf::int32 value);

  // optional uint64 transaction_id = 6;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 6;
  inline ::google::protobuf::uint64 transaction_id() const;
  inline void set_transaction_id(::google::protobuf::uint64 value);

  // optional string pin_code = 7;
  inline bool has_pin_code() const;
  inline void clear_pin_code();
  static const int kPinCodeFieldNumber = 7;
  inline const ::std::string& pin_code() const;
  inline void set_pin_code(const ::std::string& value);
  inline void set_pin_code(const char* value);
  inline void set_pin_code(const char* value, size_t size);
  inline ::std::string* mutable_pin_code();
  inline ::std::string* release_pin_code();
  inline void set_allocated_pin_code(::std::string* pin_code);

  // optional string transparent = 8;
  inline bool has_transparent() const;
  inline void clear_transparent();
  static const int kTransparentFieldNumber = 8;
  inline const ::std::string& transparent() const;
  inline void set_transparent(const ::std::string& value);
  inline void set_transparent(const char* value);
  inline void set_transparent(const char* value, size_t size);
  inline ::std::string* mutable_transparent();
  inline ::std::string* release_transparent();
  inline void set_allocated_transparent(::std::string* transparent);

  // @@protoc_insertion_point(class_scope:cl_message.TransactionStarted.Request)
 private:
  inline void set_has_connector_id();
  inline void clear_has_connector_id();
  inline void set_has_id_tag();
  inline void clear_has_id_tag();
  inline void set_has_meter_start();
  inline void clear_has_meter_start();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_price_scheme_id();
  inline void clear_has_price_scheme_id();
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_pin_code();
  inline void clear_has_pin_code();
  inline void set_has_transparent();
  inline void clear_has_transparent();

  ::cl_message::IdToken* id_tag_;
  ::google::protobuf::int32 connector_id_;
  ::google::protobuf::int32 meter_start_;
  ::google::protobuf::int32 timestamp_;
  ::google::protobuf::int32 price_scheme_id_;
  ::google::protobuf::uint64 transaction_id_;
  ::std::string* pin_code_;
  ::std::string* transparent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static TransactionStarted_Request* default_instance_;
};
// -------------------------------------------------------------------

class TransactionStarted_Confirm : public ::google::protobuf::MessageLite {
 public:
  TransactionStarted_Confirm();
  virtual ~TransactionStarted_Confirm();

  TransactionStarted_Confirm(const TransactionStarted_Confirm& from);

  inline TransactionStarted_Confirm& operator=(const TransactionStarted_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransactionStarted_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransactionStarted_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransactionStarted_Confirm* other);

  // implements Message ----------------------------------------------

  TransactionStarted_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransactionStarted_Confirm& from);
  void MergeFrom(const TransactionStarted_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 transaction_id = 1;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 transaction_id() const;
  inline void set_transaction_id(::google::protobuf::uint64 value);

  // optional .cl_message.IdTagInfo id_info = 2;
  inline bool has_id_info() const;
  inline void clear_id_info();
  static const int kIdInfoFieldNumber = 2;
  inline const ::cl_message::IdTagInfo& id_info() const;
  inline ::cl_message::IdTagInfo* mutable_id_info();
  inline ::cl_message::IdTagInfo* release_id_info();
  inline void set_allocated_id_info(::cl_message::IdTagInfo* id_info);

  // optional int32 max_allowed_hours = 3;
  inline bool has_max_allowed_hours() const;
  inline void clear_max_allowed_hours();
  static const int kMaxAllowedHoursFieldNumber = 3;
  inline ::google::protobuf::int32 max_allowed_hours() const;
  inline void set_max_allowed_hours(::google::protobuf::int32 value);

  // optional int32 max_allowed_kwh = 4;
  inline bool has_max_allowed_kwh() const;
  inline void clear_max_allowed_kwh();
  static const int kMaxAllowedKwhFieldNumber = 4;
  inline ::google::protobuf::int32 max_allowed_kwh() const;
  inline void set_max_allowed_kwh(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.TransactionStarted.Confirm)
 private:
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_id_info();
  inline void clear_has_id_info();
  inline void set_has_max_allowed_hours();
  inline void clear_has_max_allowed_hours();
  inline void set_has_max_allowed_kwh();
  inline void clear_has_max_allowed_kwh();

  ::google::protobuf::uint64 transaction_id_;
  ::cl_message::IdTagInfo* id_info_;
  ::google::protobuf::int32 max_allowed_hours_;
  ::google::protobuf::int32 max_allowed_kwh_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static TransactionStarted_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class TransactionStarted : public ::google::protobuf::MessageLite {
 public:
  TransactionStarted();
  virtual ~TransactionStarted();

  TransactionStarted(const TransactionStarted& from);

  inline TransactionStarted& operator=(const TransactionStarted& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransactionStarted& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransactionStarted* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransactionStarted* other);

  // implements Message ----------------------------------------------

  TransactionStarted* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransactionStarted& from);
  void MergeFrom(const TransactionStarted& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TransactionStarted_Request Request;
  typedef TransactionStarted_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.TransactionStarted.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::TransactionStarted_Request& req() const;
  inline ::cl_message::TransactionStarted_Request* mutable_req();
  inline ::cl_message::TransactionStarted_Request* release_req();
  inline void set_allocated_req(::cl_message::TransactionStarted_Request* req);

  // optional .cl_message.TransactionStarted.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::TransactionStarted_Confirm& conf() const;
  inline ::cl_message::TransactionStarted_Confirm* mutable_conf();
  inline ::cl_message::TransactionStarted_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::TransactionStarted_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.TransactionStarted)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::TransactionStarted_Request* req_;
  ::cl_message::TransactionStarted_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static TransactionStarted* default_instance_;
};
// -------------------------------------------------------------------

class TransactionStopped_Request : public ::google::protobuf::MessageLite {
 public:
  TransactionStopped_Request();
  virtual ~TransactionStopped_Request();

  TransactionStopped_Request(const TransactionStopped_Request& from);

  inline TransactionStopped_Request& operator=(const TransactionStopped_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransactionStopped_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransactionStopped_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransactionStopped_Request* other);

  // implements Message ----------------------------------------------

  TransactionStopped_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransactionStopped_Request& from);
  void MergeFrom(const TransactionStopped_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 transaction_id = 1;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 transaction_id() const;
  inline void set_transaction_id(::google::protobuf::uint64 value);

  // required .cl_message.IdToken id_tag = 2;
  inline bool has_id_tag() const;
  inline void clear_id_tag();
  static const int kIdTagFieldNumber = 2;
  inline const ::cl_message::IdToken& id_tag() const;
  inline ::cl_message::IdToken* mutable_id_tag();
  inline ::cl_message::IdToken* release_id_tag();
  inline void set_allocated_id_tag(::cl_message::IdToken* id_tag);

  // required int32 meter_stop = 3;
  inline bool has_meter_stop() const;
  inline void clear_meter_stop();
  static const int kMeterStopFieldNumber = 3;
  inline ::google::protobuf::int32 meter_stop() const;
  inline void set_meter_stop(::google::protobuf::int32 value);

  // required int32 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // required int32 stop_reason = 5;
  inline bool has_stop_reason() const;
  inline void clear_stop_reason();
  static const int kStopReasonFieldNumber = 5;
  inline ::google::protobuf::int32 stop_reason() const;
  inline void set_stop_reason(::google::protobuf::int32 value);

  // optional int32 time_spent_charging = 6;
  inline bool has_time_spent_charging() const;
  inline void clear_time_spent_charging();
  static const int kTimeSpentChargingFieldNumber = 6;
  inline ::google::protobuf::int32 time_spent_charging() const;
  inline void set_time_spent_charging(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.TransactionStopped.Request)
 private:
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_id_tag();
  inline void clear_has_id_tag();
  inline void set_has_meter_stop();
  inline void clear_has_meter_stop();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_stop_reason();
  inline void clear_has_stop_reason();
  inline void set_has_time_spent_charging();
  inline void clear_has_time_spent_charging();

  ::google::protobuf::uint64 transaction_id_;
  ::cl_message::IdToken* id_tag_;
  ::google::protobuf::int32 meter_stop_;
  ::google::protobuf::int32 timestamp_;
  ::google::protobuf::int32 stop_reason_;
  ::google::protobuf::int32 time_spent_charging_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static TransactionStopped_Request* default_instance_;
};
// -------------------------------------------------------------------

class TransactionStopped_Confirm : public ::google::protobuf::MessageLite {
 public:
  TransactionStopped_Confirm();
  virtual ~TransactionStopped_Confirm();

  TransactionStopped_Confirm(const TransactionStopped_Confirm& from);

  inline TransactionStopped_Confirm& operator=(const TransactionStopped_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransactionStopped_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransactionStopped_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransactionStopped_Confirm* other);

  // implements Message ----------------------------------------------

  TransactionStopped_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransactionStopped_Confirm& from);
  void MergeFrom(const TransactionStopped_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 total_cost = 1;
  inline bool has_total_cost() const;
  inline void clear_total_cost();
  static const int kTotalCostFieldNumber = 1;
  inline ::google::protobuf::int32 total_cost() const;
  inline void set_total_cost(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.TransactionStopped.Confirm)
 private:
  inline void set_has_total_cost();
  inline void clear_has_total_cost();

  ::google::protobuf::int32 total_cost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static TransactionStopped_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class TransactionStopped : public ::google::protobuf::MessageLite {
 public:
  TransactionStopped();
  virtual ~TransactionStopped();

  TransactionStopped(const TransactionStopped& from);

  inline TransactionStopped& operator=(const TransactionStopped& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransactionStopped& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransactionStopped* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransactionStopped* other);

  // implements Message ----------------------------------------------

  TransactionStopped* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransactionStopped& from);
  void MergeFrom(const TransactionStopped& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TransactionStopped_Request Request;
  typedef TransactionStopped_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.TransactionStopped.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::TransactionStopped_Request& req() const;
  inline ::cl_message::TransactionStopped_Request* mutable_req();
  inline ::cl_message::TransactionStopped_Request* release_req();
  inline void set_allocated_req(::cl_message::TransactionStopped_Request* req);

  // optional .cl_message.TransactionStopped.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::TransactionStopped_Confirm& conf() const;
  inline ::cl_message::TransactionStopped_Confirm* mutable_conf();
  inline ::cl_message::TransactionStopped_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::TransactionStopped_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.TransactionStopped)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::TransactionStopped_Request* req_;
  ::cl_message::TransactionStopped_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static TransactionStopped* default_instance_;
};
// -------------------------------------------------------------------

class TransactionRecords_Request : public ::google::protobuf::MessageLite {
 public:
  TransactionRecords_Request();
  virtual ~TransactionRecords_Request();

  TransactionRecords_Request(const TransactionRecords_Request& from);

  inline TransactionRecords_Request& operator=(const TransactionRecords_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransactionRecords_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransactionRecords_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransactionRecords_Request* other);

  // implements Message ----------------------------------------------

  TransactionRecords_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransactionRecords_Request& from);
  void MergeFrom(const TransactionRecords_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 checksum = 1;
  inline bool has_checksum() const;
  inline void clear_checksum();
  static const int kChecksumFieldNumber = 1;
  inline ::google::protobuf::int32 checksum() const;
  inline void set_checksum(::google::protobuf::int32 value);

  // repeated .cl_message.Transactions records = 2;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 2;
  inline const ::cl_message::Transactions& records(int index) const;
  inline ::cl_message::Transactions* mutable_records(int index);
  inline ::cl_message::Transactions* add_records();
  inline const ::google::protobuf::RepeatedPtrField< ::cl_message::Transactions >&
      records() const;
  inline ::google::protobuf::RepeatedPtrField< ::cl_message::Transactions >*
      mutable_records();

  // @@protoc_insertion_point(class_scope:cl_message.TransactionRecords.Request)
 private:
  inline void set_has_checksum();
  inline void clear_has_checksum();

  ::google::protobuf::RepeatedPtrField< ::cl_message::Transactions > records_;
  ::google::protobuf::int32 checksum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static TransactionRecords_Request* default_instance_;
};
// -------------------------------------------------------------------

class TransactionRecords_Confirm : public ::google::protobuf::MessageLite {
 public:
  TransactionRecords_Confirm();
  virtual ~TransactionRecords_Confirm();

  TransactionRecords_Confirm(const TransactionRecords_Confirm& from);

  inline TransactionRecords_Confirm& operator=(const TransactionRecords_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransactionRecords_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransactionRecords_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransactionRecords_Confirm* other);

  // implements Message ----------------------------------------------

  TransactionRecords_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransactionRecords_Confirm& from);
  void MergeFrom(const TransactionRecords_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // repeated uint64 transaction_id = 2;
  inline int transaction_id_size() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 2;
  inline ::google::protobuf::uint64 transaction_id(int index) const;
  inline void set_transaction_id(int index, ::google::protobuf::uint64 value);
  inline void add_transaction_id(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      transaction_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_transaction_id();

  // @@protoc_insertion_point(class_scope:cl_message.TransactionRecords.Confirm)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > transaction_id_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static TransactionRecords_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class TransactionRecords : public ::google::protobuf::MessageLite {
 public:
  TransactionRecords();
  virtual ~TransactionRecords();

  TransactionRecords(const TransactionRecords& from);

  inline TransactionRecords& operator=(const TransactionRecords& from) {
    CopyFrom(from);
    return *this;
  }

  static const TransactionRecords& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TransactionRecords* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TransactionRecords* other);

  // implements Message ----------------------------------------------

  TransactionRecords* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TransactionRecords& from);
  void MergeFrom(const TransactionRecords& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TransactionRecords_Request Request;
  typedef TransactionRecords_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.TransactionRecords.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::TransactionRecords_Request& req() const;
  inline ::cl_message::TransactionRecords_Request* mutable_req();
  inline ::cl_message::TransactionRecords_Request* release_req();
  inline void set_allocated_req(::cl_message::TransactionRecords_Request* req);

  // optional .cl_message.TransactionRecords.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::TransactionRecords_Confirm& conf() const;
  inline ::cl_message::TransactionRecords_Confirm* mutable_conf();
  inline ::cl_message::TransactionRecords_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::TransactionRecords_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.TransactionRecords)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::TransactionRecords_Request* req_;
  ::cl_message::TransactionRecords_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static TransactionRecords* default_instance_;
};
// -------------------------------------------------------------------

class MeasureValue : public ::google::protobuf::MessageLite {
 public:
  MeasureValue();
  virtual ~MeasureValue();

  MeasureValue(const MeasureValue& from);

  inline MeasureValue& operator=(const MeasureValue& from) {
    CopyFrom(from);
    return *this;
  }

  static const MeasureValue& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MeasureValue* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MeasureValue* other);

  // implements Message ----------------------------------------------

  MeasureValue* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MeasureValue& from);
  void MergeFrom(const MeasureValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 Electricity = 1;
  inline bool has_electricity() const;
  inline void clear_electricity();
  static const int kElectricityFieldNumber = 1;
  inline ::google::protobuf::int32 electricity() const;
  inline void set_electricity(::google::protobuf::int32 value);

  // optional int32 Power = 2;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 2;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);

  // optional int32 CurrentA = 3;
  inline bool has_currenta() const;
  inline void clear_currenta();
  static const int kCurrentAFieldNumber = 3;
  inline ::google::protobuf::int32 currenta() const;
  inline void set_currenta(::google::protobuf::int32 value);

  // optional int32 CurrentB = 4;
  inline bool has_currentb() const;
  inline void clear_currentb();
  static const int kCurrentBFieldNumber = 4;
  inline ::google::protobuf::int32 currentb() const;
  inline void set_currentb(::google::protobuf::int32 value);

  // optional int32 CurrentC = 5;
  inline bool has_currentc() const;
  inline void clear_currentc();
  static const int kCurrentCFieldNumber = 5;
  inline ::google::protobuf::int32 currentc() const;
  inline void set_currentc(::google::protobuf::int32 value);

  // optional int32 VoltageA = 6;
  inline bool has_voltagea() const;
  inline void clear_voltagea();
  static const int kVoltageAFieldNumber = 6;
  inline ::google::protobuf::int32 voltagea() const;
  inline void set_voltagea(::google::protobuf::int32 value);

  // optional int32 VoltageB = 7;
  inline bool has_voltageb() const;
  inline void clear_voltageb();
  static const int kVoltageBFieldNumber = 7;
  inline ::google::protobuf::int32 voltageb() const;
  inline void set_voltageb(::google::protobuf::int32 value);

  // optional int32 VoltageC = 8;
  inline bool has_voltagec() const;
  inline void clear_voltagec();
  static const int kVoltageCFieldNumber = 8;
  inline ::google::protobuf::int32 voltagec() const;
  inline void set_voltagec(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.MeasureValue)
 private:
  inline void set_has_electricity();
  inline void clear_has_electricity();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_currenta();
  inline void clear_has_currenta();
  inline void set_has_currentb();
  inline void clear_has_currentb();
  inline void set_has_currentc();
  inline void clear_has_currentc();
  inline void set_has_voltagea();
  inline void clear_has_voltagea();
  inline void set_has_voltageb();
  inline void clear_has_voltageb();
  inline void set_has_voltagec();
  inline void clear_has_voltagec();

  ::google::protobuf::int32 electricity_;
  ::google::protobuf::int32 power_;
  ::google::protobuf::int32 currenta_;
  ::google::protobuf::int32 currentb_;
  ::google::protobuf::int32 currentc_;
  ::google::protobuf::int32 voltagea_;
  ::google::protobuf::int32 voltageb_;
  ::google::protobuf::int32 voltagec_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static MeasureValue* default_instance_;
};
// -------------------------------------------------------------------

class Measure_Request : public ::google::protobuf::MessageLite {
 public:
  Measure_Request();
  virtual ~Measure_Request();

  Measure_Request(const Measure_Request& from);

  inline Measure_Request& operator=(const Measure_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const Measure_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Measure_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Measure_Request* other);

  // implements Message ----------------------------------------------

  Measure_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Measure_Request& from);
  void MergeFrom(const Measure_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 connector_id = 1;
  inline bool has_connector_id() const;
  inline void clear_connector_id();
  static const int kConnectorIdFieldNumber = 1;
  inline ::google::protobuf::int32 connector_id() const;
  inline void set_connector_id(::google::protobuf::int32 value);

  // optional uint64 transaction_id = 2;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 2;
  inline ::google::protobuf::uint64 transaction_id() const;
  inline void set_transaction_id(::google::protobuf::uint64 value);

  // required .cl_message.MeasureValue value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::cl_message::MeasureValue& value() const;
  inline ::cl_message::MeasureValue* mutable_value();
  inline ::cl_message::MeasureValue* release_value();
  inline void set_allocated_value(::cl_message::MeasureValue* value);

  // @@protoc_insertion_point(class_scope:cl_message.Measure.Request)
 private:
  inline void set_has_connector_id();
  inline void clear_has_connector_id();
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::uint64 transaction_id_;
  ::cl_message::MeasureValue* value_;
  ::google::protobuf::int32 connector_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Measure_Request* default_instance_;
};
// -------------------------------------------------------------------

class Measure_Confirm : public ::google::protobuf::MessageLite {
 public:
  Measure_Confirm();
  virtual ~Measure_Confirm();

  Measure_Confirm(const Measure_Confirm& from);

  inline Measure_Confirm& operator=(const Measure_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const Measure_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Measure_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Measure_Confirm* other);

  // implements Message ----------------------------------------------

  Measure_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Measure_Confirm& from);
  void MergeFrom(const Measure_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cl_message.Measure.Confirm)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Measure_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class Measure : public ::google::protobuf::MessageLite {
 public:
  Measure();
  virtual ~Measure();

  Measure(const Measure& from);

  inline Measure& operator=(const Measure& from) {
    CopyFrom(from);
    return *this;
  }

  static const Measure& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Measure* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Measure* other);

  // implements Message ----------------------------------------------

  Measure* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Measure& from);
  void MergeFrom(const Measure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Measure_Request Request;
  typedef Measure_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.Measure.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::Measure_Request& req() const;
  inline ::cl_message::Measure_Request* mutable_req();
  inline ::cl_message::Measure_Request* release_req();
  inline void set_allocated_req(::cl_message::Measure_Request* req);

  // optional .cl_message.Measure.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::Measure_Confirm& conf() const;
  inline ::cl_message::Measure_Confirm* mutable_conf();
  inline ::cl_message::Measure_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::Measure_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.Measure)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::Measure_Request* req_;
  ::cl_message::Measure_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Measure* default_instance_;
};
// -------------------------------------------------------------------

class BootNotification_Request : public ::google::protobuf::MessageLite {
 public:
  BootNotification_Request();
  virtual ~BootNotification_Request();

  BootNotification_Request(const BootNotification_Request& from);

  inline BootNotification_Request& operator=(const BootNotification_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const BootNotification_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BootNotification_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BootNotification_Request* other);

  // implements Message ----------------------------------------------

  BootNotification_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BootNotification_Request& from);
  void MergeFrom(const BootNotification_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string cp_version = 2;
  inline bool has_cp_version() const;
  inline void clear_cp_version();
  static const int kCpVersionFieldNumber = 2;
  inline const ::std::string& cp_version() const;
  inline void set_cp_version(const ::std::string& value);
  inline void set_cp_version(const char* value);
  inline void set_cp_version(const char* value, size_t size);
  inline ::std::string* mutable_cp_version();
  inline ::std::string* release_cp_version();
  inline void set_allocated_cp_version(::std::string* cp_version);

  // optional string client_version = 3;
  inline bool has_client_version() const;
  inline void clear_client_version();
  static const int kClientVersionFieldNumber = 3;
  inline const ::std::string& client_version() const;
  inline void set_client_version(const ::std::string& value);
  inline void set_client_version(const char* value);
  inline void set_client_version(const char* value, size_t size);
  inline ::std::string* mutable_client_version();
  inline ::std::string* release_client_version();
  inline void set_allocated_client_version(::std::string* client_version);

  // optional string firmware_version = 4;
  inline bool has_firmware_version() const;
  inline void clear_firmware_version();
  static const int kFirmwareVersionFieldNumber = 4;
  inline const ::std::string& firmware_version() const;
  inline void set_firmware_version(const ::std::string& value);
  inline void set_firmware_version(const char* value);
  inline void set_firmware_version(const char* value, size_t size);
  inline ::std::string* mutable_firmware_version();
  inline ::std::string* release_firmware_version();
  inline void set_allocated_firmware_version(::std::string* firmware_version);

  // @@protoc_insertion_point(class_scope:cl_message.BootNotification.Request)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_cp_version();
  inline void clear_has_cp_version();
  inline void set_has_client_version();
  inline void clear_has_client_version();
  inline void set_has_firmware_version();
  inline void clear_has_firmware_version();

  ::std::string* version_;
  ::std::string* cp_version_;
  ::std::string* client_version_;
  ::std::string* firmware_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static BootNotification_Request* default_instance_;
};
// -------------------------------------------------------------------

class BootNotification_Confirm : public ::google::protobuf::MessageLite {
 public:
  BootNotification_Confirm();
  virtual ~BootNotification_Confirm();

  BootNotification_Confirm(const BootNotification_Confirm& from);

  inline BootNotification_Confirm& operator=(const BootNotification_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const BootNotification_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BootNotification_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BootNotification_Confirm* other);

  // implements Message ----------------------------------------------

  BootNotification_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BootNotification_Confirm& from);
  void MergeFrom(const BootNotification_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // optional int32 hb_interval = 2;
  inline bool has_hb_interval() const;
  inline void clear_hb_interval();
  static const int kHbIntervalFieldNumber = 2;
  inline ::google::protobuf::int32 hb_interval() const;
  inline void set_hb_interval(::google::protobuf::int32 value);

  // optional int32 meter_idle_interval = 3;
  inline bool has_meter_idle_interval() const;
  inline void clear_meter_idle_interval();
  static const int kMeterIdleIntervalFieldNumber = 3;
  inline ::google::protobuf::int32 meter_idle_interval() const;
  inline void set_meter_idle_interval(::google::protobuf::int32 value);

  // optional int32 meter_charge_interval = 4;
  inline bool has_meter_charge_interval() const;
  inline void clear_meter_charge_interval();
  static const int kMeterChargeIntervalFieldNumber = 4;
  inline ::google::protobuf::int32 meter_charge_interval() const;
  inline void set_meter_charge_interval(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.BootNotification.Confirm)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_hb_interval();
  inline void clear_has_hb_interval();
  inline void set_has_meter_idle_interval();
  inline void clear_has_meter_idle_interval();
  inline void set_has_meter_charge_interval();
  inline void clear_has_meter_charge_interval();

  ::google::protobuf::int32 timestamp_;
  ::google::protobuf::int32 hb_interval_;
  ::google::protobuf::int32 meter_idle_interval_;
  ::google::protobuf::int32 meter_charge_interval_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static BootNotification_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class BootNotification : public ::google::protobuf::MessageLite {
 public:
  BootNotification();
  virtual ~BootNotification();

  BootNotification(const BootNotification& from);

  inline BootNotification& operator=(const BootNotification& from) {
    CopyFrom(from);
    return *this;
  }

  static const BootNotification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BootNotification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BootNotification* other);

  // implements Message ----------------------------------------------

  BootNotification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BootNotification& from);
  void MergeFrom(const BootNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef BootNotification_Request Request;
  typedef BootNotification_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.BootNotification.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::BootNotification_Request& req() const;
  inline ::cl_message::BootNotification_Request* mutable_req();
  inline ::cl_message::BootNotification_Request* release_req();
  inline void set_allocated_req(::cl_message::BootNotification_Request* req);

  // optional .cl_message.BootNotification.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::BootNotification_Confirm& conf() const;
  inline ::cl_message::BootNotification_Confirm* mutable_conf();
  inline ::cl_message::BootNotification_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::BootNotification_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.BootNotification)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::BootNotification_Request* req_;
  ::cl_message::BootNotification_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static BootNotification* default_instance_;
};
// -------------------------------------------------------------------

class StatusNotification : public ::google::protobuf::MessageLite {
 public:
  StatusNotification();
  virtual ~StatusNotification();

  StatusNotification(const StatusNotification& from);

  inline StatusNotification& operator=(const StatusNotification& from) {
    CopyFrom(from);
    return *this;
  }

  static const StatusNotification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StatusNotification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StatusNotification* other);

  // implements Message ----------------------------------------------

  StatusNotification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StatusNotification& from);
  void MergeFrom(const StatusNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 connector_id = 1;
  inline bool has_connector_id() const;
  inline void clear_connector_id();
  static const int kConnectorIdFieldNumber = 1;
  inline ::google::protobuf::int32 connector_id() const;
  inline void set_connector_id(::google::protobuf::int32 value);

  // required .cl_message.ChargerStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::cl_message::ChargerStatus status() const;
  inline void set_status(::cl_message::ChargerStatus value);

  // @@protoc_insertion_point(class_scope:cl_message.StatusNotification)
 private:
  inline void set_has_connector_id();
  inline void clear_has_connector_id();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::int32 connector_id_;
  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static StatusNotification* default_instance_;
};
// -------------------------------------------------------------------

class FirmwareStatusNotifcation : public ::google::protobuf::MessageLite {
 public:
  FirmwareStatusNotifcation();
  virtual ~FirmwareStatusNotifcation();

  FirmwareStatusNotifcation(const FirmwareStatusNotifcation& from);

  inline FirmwareStatusNotifcation& operator=(const FirmwareStatusNotifcation& from) {
    CopyFrom(from);
    return *this;
  }

  static const FirmwareStatusNotifcation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FirmwareStatusNotifcation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FirmwareStatusNotifcation* other);

  // implements Message ----------------------------------------------

  FirmwareStatusNotifcation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FirmwareStatusNotifcation& from);
  void MergeFrom(const FirmwareStatusNotifcation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .cl_message.FirmwareStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::cl_message::FirmwareStatus status() const;
  inline void set_status(::cl_message::FirmwareStatus value);

  // @@protoc_insertion_point(class_scope:cl_message.FirmwareStatusNotifcation)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  int status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static FirmwareStatusNotifcation* default_instance_;
};
// -------------------------------------------------------------------

class SensorStatusNotification : public ::google::protobuf::MessageLite {
 public:
  SensorStatusNotification();
  virtual ~SensorStatusNotification();

  SensorStatusNotification(const SensorStatusNotification& from);

  inline SensorStatusNotification& operator=(const SensorStatusNotification& from) {
    CopyFrom(from);
    return *this;
  }

  static const SensorStatusNotification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SensorStatusNotification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SensorStatusNotification* other);

  // implements Message ----------------------------------------------

  SensorStatusNotification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SensorStatusNotification& from);
  void MergeFrom(const SensorStatusNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 deviceid = 1;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 1;
  inline ::google::protobuf::int32 deviceid() const;
  inline void set_deviceid(::google::protobuf::int32 value);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional int32 capacity = 5;
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 5;
  inline ::google::protobuf::int32 capacity() const;
  inline void set_capacity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.SensorStatusNotification)
 private:
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_capacity();
  inline void clear_has_capacity();

  ::google::protobuf::int32 deviceid_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 capacity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SensorStatusNotification* default_instance_;
};
// -------------------------------------------------------------------

class Consumption : public ::google::protobuf::MessageLite {
 public:
  Consumption();
  virtual ~Consumption();

  Consumption(const Consumption& from);

  inline Consumption& operator=(const Consumption& from) {
    CopyFrom(from);
    return *this;
  }

  static const Consumption& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Consumption* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Consumption* other);

  // implements Message ----------------------------------------------

  Consumption* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Consumption& from);
  void MergeFrom(const Consumption& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 tariffid = 1;
  inline bool has_tariffid() const;
  inline void clear_tariffid();
  static const int kTariffidFieldNumber = 1;
  inline ::google::protobuf::int32 tariffid() const;
  inline void set_tariffid(::google::protobuf::int32 value);

  // required int32 tariff_qty = 2;
  inline bool has_tariff_qty() const;
  inline void clear_tariff_qty();
  static const int kTariffQtyFieldNumber = 2;
  inline ::google::protobuf::int32 tariff_qty() const;
  inline void set_tariff_qty(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.Consumption)
 private:
  inline void set_has_tariffid();
  inline void clear_has_tariffid();
  inline void set_has_tariff_qty();
  inline void clear_has_tariff_qty();

  ::google::protobuf::int32 tariffid_;
  ::google::protobuf::int32 tariff_qty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Consumption* default_instance_;
};
// -------------------------------------------------------------------

class GetCost_Request : public ::google::protobuf::MessageLite {
 public:
  GetCost_Request();
  virtual ~GetCost_Request();

  GetCost_Request(const GetCost_Request& from);

  inline GetCost_Request& operator=(const GetCost_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetCost_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCost_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCost_Request* other);

  // implements Message ----------------------------------------------

  GetCost_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCost_Request& from);
  void MergeFrom(const GetCost_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 price_scheme_id = 1;
  inline bool has_price_scheme_id() const;
  inline void clear_price_scheme_id();
  static const int kPriceSchemeIdFieldNumber = 1;
  inline ::google::protobuf::int32 price_scheme_id() const;
  inline void set_price_scheme_id(::google::protobuf::int32 value);

  // repeated .cl_message.Consumption local_consumption = 2;
  inline int local_consumption_size() const;
  inline void clear_local_consumption();
  static const int kLocalConsumptionFieldNumber = 2;
  inline const ::cl_message::Consumption& local_consumption(int index) const;
  inline ::cl_message::Consumption* mutable_local_consumption(int index);
  inline ::cl_message::Consumption* add_local_consumption();
  inline const ::google::protobuf::RepeatedPtrField< ::cl_message::Consumption >&
      local_consumption() const;
  inline ::google::protobuf::RepeatedPtrField< ::cl_message::Consumption >*
      mutable_local_consumption();

  // @@protoc_insertion_point(class_scope:cl_message.GetCost.Request)
 private:
  inline void set_has_price_scheme_id();
  inline void clear_has_price_scheme_id();

  ::google::protobuf::RepeatedPtrField< ::cl_message::Consumption > local_consumption_;
  ::google::protobuf::int32 price_scheme_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static GetCost_Request* default_instance_;
};
// -------------------------------------------------------------------

class GetCost_Confirm : public ::google::protobuf::MessageLite {
 public:
  GetCost_Confirm();
  virtual ~GetCost_Confirm();

  GetCost_Confirm(const GetCost_Confirm& from);

  inline GetCost_Confirm& operator=(const GetCost_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetCost_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCost_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCost_Confirm* other);

  // implements Message ----------------------------------------------

  GetCost_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCost_Confirm& from);
  void MergeFrom(const GetCost_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 price_scheme_id = 1;
  inline bool has_price_scheme_id() const;
  inline void clear_price_scheme_id();
  static const int kPriceSchemeIdFieldNumber = 1;
  inline ::google::protobuf::int32 price_scheme_id() const;
  inline void set_price_scheme_id(::google::protobuf::int32 value);

  // required int32 total_cost = 2;
  inline bool has_total_cost() const;
  inline void clear_total_cost();
  static const int kTotalCostFieldNumber = 2;
  inline ::google::protobuf::int32 total_cost() const;
  inline void set_total_cost(::google::protobuf::int32 value);

  // repeated .cl_message.Consumption consum = 3;
  inline int consum_size() const;
  inline void clear_consum();
  static const int kConsumFieldNumber = 3;
  inline const ::cl_message::Consumption& consum(int index) const;
  inline ::cl_message::Consumption* mutable_consum(int index);
  inline ::cl_message::Consumption* add_consum();
  inline const ::google::protobuf::RepeatedPtrField< ::cl_message::Consumption >&
      consum() const;
  inline ::google::protobuf::RepeatedPtrField< ::cl_message::Consumption >*
      mutable_consum();

  // @@protoc_insertion_point(class_scope:cl_message.GetCost.Confirm)
 private:
  inline void set_has_price_scheme_id();
  inline void clear_has_price_scheme_id();
  inline void set_has_total_cost();
  inline void clear_has_total_cost();

  ::google::protobuf::int32 price_scheme_id_;
  ::google::protobuf::int32 total_cost_;
  ::google::protobuf::RepeatedPtrField< ::cl_message::Consumption > consum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static GetCost_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class GetCost : public ::google::protobuf::MessageLite {
 public:
  GetCost();
  virtual ~GetCost();

  GetCost(const GetCost& from);

  inline GetCost& operator=(const GetCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetCost& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCost* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCost* other);

  // implements Message ----------------------------------------------

  GetCost* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCost& from);
  void MergeFrom(const GetCost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GetCost_Request Request;
  typedef GetCost_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.GetCost.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::GetCost_Request& req() const;
  inline ::cl_message::GetCost_Request* mutable_req();
  inline ::cl_message::GetCost_Request* release_req();
  inline void set_allocated_req(::cl_message::GetCost_Request* req);

  // optional .cl_message.GetCost.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::GetCost_Confirm& conf() const;
  inline ::cl_message::GetCost_Confirm* mutable_conf();
  inline ::cl_message::GetCost_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::GetCost_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.GetCost)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::GetCost_Request* req_;
  ::cl_message::GetCost_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static GetCost* default_instance_;
};
// -------------------------------------------------------------------

class LoginGW_Request : public ::google::protobuf::MessageLite {
 public:
  LoginGW_Request();
  virtual ~LoginGW_Request();

  LoginGW_Request(const LoginGW_Request& from);

  inline LoginGW_Request& operator=(const LoginGW_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginGW_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginGW_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginGW_Request* other);

  // implements Message ----------------------------------------------

  LoginGW_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginGW_Request& from);
  void MergeFrom(const LoginGW_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string deviceid = 1;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 1;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // @@protoc_insertion_point(class_scope:cl_message.LoginGW.Request)
 private:
  inline void set_has_deviceid();
  inline void clear_has_deviceid();

  ::std::string* deviceid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static LoginGW_Request* default_instance_;
};
// -------------------------------------------------------------------

class LoginGW_Confirm : public ::google::protobuf::MessageLite {
 public:
  LoginGW_Confirm();
  virtual ~LoginGW_Confirm();

  LoginGW_Confirm(const LoginGW_Confirm& from);

  inline LoginGW_Confirm& operator=(const LoginGW_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginGW_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginGW_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginGW_Confirm* other);

  // implements Message ----------------------------------------------

  LoginGW_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginGW_Confirm& from);
  void MergeFrom(const LoginGW_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool accept = 1;
  inline bool has_accept() const;
  inline void clear_accept();
  static const int kAcceptFieldNumber = 1;
  inline bool accept() const;
  inline void set_accept(bool value);

  // optional int32 evse_id = 2;
  inline bool has_evse_id() const;
  inline void clear_evse_id();
  static const int kEvseIdFieldNumber = 2;
  inline ::google::protobuf::int32 evse_id() const;
  inline void set_evse_id(::google::protobuf::int32 value);

  // optional string cpid = 3;
  inline bool has_cpid() const;
  inline void clear_cpid();
  static const int kCpidFieldNumber = 3;
  inline const ::std::string& cpid() const;
  inline void set_cpid(const ::std::string& value);
  inline void set_cpid(const char* value);
  inline void set_cpid(const char* value, size_t size);
  inline ::std::string* mutable_cpid();
  inline ::std::string* release_cpid();
  inline void set_allocated_cpid(::std::string* cpid);

  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional bool isonline = 5;
  inline bool has_isonline() const;
  inline void clear_isonline();
  static const int kIsonlineFieldNumber = 5;
  inline bool isonline() const;
  inline void set_isonline(bool value);

  // optional int32 timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.LoginGW.Confirm)
 private:
  inline void set_has_accept();
  inline void clear_has_accept();
  inline void set_has_evse_id();
  inline void clear_has_evse_id();
  inline void set_has_cpid();
  inline void clear_has_cpid();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_isonline();
  inline void clear_has_isonline();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::int32 evse_id_;
  bool accept_;
  bool isonline_;
  ::std::string* cpid_;
  ::std::string* version_;
  ::google::protobuf::int32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static LoginGW_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class LoginGW : public ::google::protobuf::MessageLite {
 public:
  LoginGW();
  virtual ~LoginGW();

  LoginGW(const LoginGW& from);

  inline LoginGW& operator=(const LoginGW& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginGW& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginGW* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginGW* other);

  // implements Message ----------------------------------------------

  LoginGW* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginGW& from);
  void MergeFrom(const LoginGW& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef LoginGW_Request Request;
  typedef LoginGW_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.LoginGW.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::LoginGW_Request& req() const;
  inline ::cl_message::LoginGW_Request* mutable_req();
  inline ::cl_message::LoginGW_Request* release_req();
  inline void set_allocated_req(::cl_message::LoginGW_Request* req);

  // optional .cl_message.LoginGW.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::LoginGW_Confirm& conf() const;
  inline ::cl_message::LoginGW_Confirm* mutable_conf();
  inline ::cl_message::LoginGW_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::LoginGW_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.LoginGW)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::LoginGW_Request* req_;
  ::cl_message::LoginGW_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static LoginGW* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatGW_Request : public ::google::protobuf::MessageLite {
 public:
  HeartbeatGW_Request();
  virtual ~HeartbeatGW_Request();

  HeartbeatGW_Request(const HeartbeatGW_Request& from);

  inline HeartbeatGW_Request& operator=(const HeartbeatGW_Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const HeartbeatGW_Request& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeartbeatGW_Request* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeartbeatGW_Request* other);

  // implements Message ----------------------------------------------

  HeartbeatGW_Request* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeartbeatGW_Request& from);
  void MergeFrom(const HeartbeatGW_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.HeartbeatGW.Request)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::int32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatGW_Request* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatGW_Confirm : public ::google::protobuf::MessageLite {
 public:
  HeartbeatGW_Confirm();
  virtual ~HeartbeatGW_Confirm();

  HeartbeatGW_Confirm(const HeartbeatGW_Confirm& from);

  inline HeartbeatGW_Confirm& operator=(const HeartbeatGW_Confirm& from) {
    CopyFrom(from);
    return *this;
  }

  static const HeartbeatGW_Confirm& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeartbeatGW_Confirm* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeartbeatGW_Confirm* other);

  // implements Message ----------------------------------------------

  HeartbeatGW_Confirm* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeartbeatGW_Confirm& from);
  void MergeFrom(const HeartbeatGW_Confirm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 rssi = 1;
  inline bool has_rssi() const;
  inline void clear_rssi();
  static const int kRssiFieldNumber = 1;
  inline ::google::protobuf::int32 rssi() const;
  inline void set_rssi(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.HeartbeatGW.Confirm)
 private:
  inline void set_has_rssi();
  inline void clear_has_rssi();

  ::google::protobuf::int32 rssi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatGW_Confirm* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatGW : public ::google::protobuf::MessageLite {
 public:
  HeartbeatGW();
  virtual ~HeartbeatGW();

  HeartbeatGW(const HeartbeatGW& from);

  inline HeartbeatGW& operator=(const HeartbeatGW& from) {
    CopyFrom(from);
    return *this;
  }

  static const HeartbeatGW& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeartbeatGW* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeartbeatGW* other);

  // implements Message ----------------------------------------------

  HeartbeatGW* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeartbeatGW& from);
  void MergeFrom(const HeartbeatGW& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef HeartbeatGW_Request Request;
  typedef HeartbeatGW_Confirm Confirm;

  // accessors -------------------------------------------------------

  // optional .cl_message.HeartbeatGW.Request req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::cl_message::HeartbeatGW_Request& req() const;
  inline ::cl_message::HeartbeatGW_Request* mutable_req();
  inline ::cl_message::HeartbeatGW_Request* release_req();
  inline void set_allocated_req(::cl_message::HeartbeatGW_Request* req);

  // optional .cl_message.HeartbeatGW.Confirm conf = 2;
  inline bool has_conf() const;
  inline void clear_conf();
  static const int kConfFieldNumber = 2;
  inline const ::cl_message::HeartbeatGW_Confirm& conf() const;
  inline ::cl_message::HeartbeatGW_Confirm* mutable_conf();
  inline ::cl_message::HeartbeatGW_Confirm* release_conf();
  inline void set_allocated_conf(::cl_message::HeartbeatGW_Confirm* conf);

  // @@protoc_insertion_point(class_scope:cl_message.HeartbeatGW)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_conf();
  inline void clear_has_conf();

  ::cl_message::HeartbeatGW_Request* req_;
  ::cl_message::HeartbeatGW_Confirm* conf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatGW* default_instance_;
};
// -------------------------------------------------------------------

class NetstatGW : public ::google::protobuf::MessageLite {
 public:
  NetstatGW();
  virtual ~NetstatGW();

  NetstatGW(const NetstatGW& from);

  inline NetstatGW& operator=(const NetstatGW& from) {
    CopyFrom(from);
    return *this;
  }

  static const NetstatGW& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NetstatGW* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NetstatGW* other);

  // implements Message ----------------------------------------------

  NetstatGW* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NetstatGW& from);
  void MergeFrom(const NetstatGW& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool isonline = 1;
  inline bool has_isonline() const;
  inline void clear_isonline();
  static const int kIsonlineFieldNumber = 1;
  inline bool isonline() const;
  inline void set_isonline(bool value);

  // optional int32 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cl_message.NetstatGW)
 private:
  inline void set_has_isonline();
  inline void clear_has_isonline();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  bool isonline_;
  ::google::protobuf::int32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cl_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_cl_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_cl_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static NetstatGW* default_instance_;
};
// ===================================================================


// ===================================================================

// Base

// required int32 length = 1;
inline bool Base::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Base::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Base::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Base::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 Base::length() const {
  return length_;
}
inline void Base::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// required fixed32 cmd = 2;
inline bool Base::has_cmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Base::set_has_cmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Base::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Base::clear_cmd() {
  cmd_ = 0u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 Base::cmd() const {
  return cmd_;
}
inline void Base::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
}

// required fixed32 timestamp = 3;
inline bool Base::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Base::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Base::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Base::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 Base::timestamp() const {
  return timestamp_;
}
inline void Base::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional bytes payload = 4;
inline bool Base::has_payload() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Base::set_has_payload() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Base::clear_has_payload() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Base::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& Base::payload() const {
  return *payload_;
}
inline void Base::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void Base::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void Base::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Base::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* Base::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Base::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CallError

// required .cl_message.CallError.ErrorCode error_code = 2;
inline bool CallError::has_error_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CallError::set_has_error_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CallError::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CallError::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::cl_message::CallError_ErrorCode CallError::error_code() const {
  return static_cast< ::cl_message::CallError_ErrorCode >(error_code_);
}
inline void CallError::set_error_code(::cl_message::CallError_ErrorCode value) {
  assert(::cl_message::CallError_ErrorCode_IsValid(value));
  set_has_error_code();
  error_code_ = value;
}

// optional string error_desc = 3;
inline bool CallError::has_error_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CallError::set_has_error_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CallError::clear_has_error_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CallError::clear_error_desc() {
  if (error_desc_ != &::google::protobuf::internal::kEmptyString) {
    error_desc_->clear();
  }
  clear_has_error_desc();
}
inline const ::std::string& CallError::error_desc() const {
  return *error_desc_;
}
inline void CallError::set_error_desc(const ::std::string& value) {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    error_desc_ = new ::std::string;
  }
  error_desc_->assign(value);
}
inline void CallError::set_error_desc(const char* value) {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    error_desc_ = new ::std::string;
  }
  error_desc_->assign(value);
}
inline void CallError::set_error_desc(const char* value, size_t size) {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    error_desc_ = new ::std::string;
  }
  error_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CallError::mutable_error_desc() {
  set_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    error_desc_ = new ::std::string;
  }
  return error_desc_;
}
inline ::std::string* CallError::release_error_desc() {
  clear_has_error_desc();
  if (error_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_desc_;
    error_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CallError::set_allocated_error_desc(::std::string* error_desc) {
  if (error_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete error_desc_;
  }
  if (error_desc) {
    set_has_error_desc();
    error_desc_ = error_desc;
  } else {
    clear_has_error_desc();
    error_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string error_details = 4;
inline bool CallError::has_error_details() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CallError::set_has_error_details() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CallError::clear_has_error_details() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CallError::clear_error_details() {
  if (error_details_ != &::google::protobuf::internal::kEmptyString) {
    error_details_->clear();
  }
  clear_has_error_details();
}
inline const ::std::string& CallError::error_details() const {
  return *error_details_;
}
inline void CallError::set_error_details(const ::std::string& value) {
  set_has_error_details();
  if (error_details_ == &::google::protobuf::internal::kEmptyString) {
    error_details_ = new ::std::string;
  }
  error_details_->assign(value);
}
inline void CallError::set_error_details(const char* value) {
  set_has_error_details();
  if (error_details_ == &::google::protobuf::internal::kEmptyString) {
    error_details_ = new ::std::string;
  }
  error_details_->assign(value);
}
inline void CallError::set_error_details(const char* value, size_t size) {
  set_has_error_details();
  if (error_details_ == &::google::protobuf::internal::kEmptyString) {
    error_details_ = new ::std::string;
  }
  error_details_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CallError::mutable_error_details() {
  set_has_error_details();
  if (error_details_ == &::google::protobuf::internal::kEmptyString) {
    error_details_ = new ::std::string;
  }
  return error_details_;
}
inline ::std::string* CallError::release_error_details() {
  clear_has_error_details();
  if (error_details_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_details_;
    error_details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CallError::set_allocated_error_details(::std::string* error_details) {
  if (error_details_ != &::google::protobuf::internal::kEmptyString) {
    delete error_details_;
  }
  if (error_details) {
    set_has_error_details();
    error_details_ = error_details;
  } else {
    clear_has_error_details();
    error_details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IdToken

// required string id = 1;
inline bool IdToken::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IdToken::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IdToken::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IdToken::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& IdToken::id() const {
  return *id_;
}
inline void IdToken::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void IdToken::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void IdToken::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IdToken::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* IdToken::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IdToken::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .cl_message.IdType id_type = 2;
inline bool IdToken::has_id_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IdToken::set_has_id_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IdToken::clear_has_id_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IdToken::clear_id_type() {
  id_type_ = 1;
  clear_has_id_type();
}
inline ::cl_message::IdType IdToken::id_type() const {
  return static_cast< ::cl_message::IdType >(id_type_);
}
inline void IdToken::set_id_type(::cl_message::IdType value) {
  assert(::cl_message::IdType_IsValid(value));
  set_has_id_type();
  id_type_ = value;
}

// -------------------------------------------------------------------

// IdTagInfo

// optional int32 expiry_date = 1;
inline bool IdTagInfo::has_expiry_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IdTagInfo::set_has_expiry_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IdTagInfo::clear_has_expiry_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IdTagInfo::clear_expiry_date() {
  expiry_date_ = 0;
  clear_has_expiry_date();
}
inline ::google::protobuf::int32 IdTagInfo::expiry_date() const {
  return expiry_date_;
}
inline void IdTagInfo::set_expiry_date(::google::protobuf::int32 value) {
  set_has_expiry_date();
  expiry_date_ = value;
}

// optional string group_id = 2;
inline bool IdTagInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IdTagInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IdTagInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IdTagInfo::clear_group_id() {
  if (group_id_ != &::google::protobuf::internal::kEmptyString) {
    group_id_->clear();
  }
  clear_has_group_id();
}
inline const ::std::string& IdTagInfo::group_id() const {
  return *group_id_;
}
inline void IdTagInfo::set_group_id(const ::std::string& value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
}
inline void IdTagInfo::set_group_id(const char* value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
}
inline void IdTagInfo::set_group_id(const char* value, size_t size) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IdTagInfo::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  return group_id_;
}
inline ::std::string* IdTagInfo::release_group_id() {
  clear_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_id_;
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IdTagInfo::set_allocated_group_id(::std::string* group_id) {
  if (group_id_ != &::google::protobuf::internal::kEmptyString) {
    delete group_id_;
  }
  if (group_id) {
    set_has_group_id();
    group_id_ = group_id;
  } else {
    clear_has_group_id();
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .cl_message.AuthorizationStatus status = 3;
inline bool IdTagInfo::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IdTagInfo::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IdTagInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IdTagInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::cl_message::AuthorizationStatus IdTagInfo::status() const {
  return static_cast< ::cl_message::AuthorizationStatus >(status_);
}
inline void IdTagInfo::set_status(::cl_message::AuthorizationStatus value) {
  assert(::cl_message::AuthorizationStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// Transactions

// optional uint64 transaction_id = 1;
inline bool Transactions::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transactions::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transactions::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transactions::clear_transaction_id() {
  transaction_id_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::uint64 Transactions::transaction_id() const {
  return transaction_id_;
}
inline void Transactions::set_transaction_id(::google::protobuf::uint64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
}

// optional int32 connector_id = 2;
inline bool Transactions::has_connector_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Transactions::set_has_connector_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Transactions::clear_has_connector_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Transactions::clear_connector_id() {
  connector_id_ = 0;
  clear_has_connector_id();
}
inline ::google::protobuf::int32 Transactions::connector_id() const {
  return connector_id_;
}
inline void Transactions::set_connector_id(::google::protobuf::int32 value) {
  set_has_connector_id();
  connector_id_ = value;
}

// required .cl_message.IdToken id_tag = 3;
inline bool Transactions::has_id_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Transactions::set_has_id_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Transactions::clear_has_id_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Transactions::clear_id_tag() {
  if (id_tag_ != NULL) id_tag_->::cl_message::IdToken::Clear();
  clear_has_id_tag();
}
inline const ::cl_message::IdToken& Transactions::id_tag() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_tag_ != NULL ? *id_tag_ : *default_instance().id_tag_;
#else
  return id_tag_ != NULL ? *id_tag_ : *default_instance_->id_tag_;
#endif
}
inline ::cl_message::IdToken* Transactions::mutable_id_tag() {
  set_has_id_tag();
  if (id_tag_ == NULL) id_tag_ = new ::cl_message::IdToken;
  return id_tag_;
}
inline ::cl_message::IdToken* Transactions::release_id_tag() {
  clear_has_id_tag();
  ::cl_message::IdToken* temp = id_tag_;
  id_tag_ = NULL;
  return temp;
}
inline void Transactions::set_allocated_id_tag(::cl_message::IdToken* id_tag) {
  delete id_tag_;
  id_tag_ = id_tag;
  if (id_tag) {
    set_has_id_tag();
  } else {
    clear_has_id_tag();
  }
}

// required int32 meter_start = 4;
inline bool Transactions::has_meter_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Transactions::set_has_meter_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Transactions::clear_has_meter_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Transactions::clear_meter_start() {
  meter_start_ = 0;
  clear_has_meter_start();
}
inline ::google::protobuf::int32 Transactions::meter_start() const {
  return meter_start_;
}
inline void Transactions::set_meter_start(::google::protobuf::int32 value) {
  set_has_meter_start();
  meter_start_ = value;
}

// required int32 meter_stop = 5;
inline bool Transactions::has_meter_stop() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Transactions::set_has_meter_stop() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Transactions::clear_has_meter_stop() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Transactions::clear_meter_stop() {
  meter_stop_ = 0;
  clear_has_meter_stop();
}
inline ::google::protobuf::int32 Transactions::meter_stop() const {
  return meter_stop_;
}
inline void Transactions::set_meter_stop(::google::protobuf::int32 value) {
  set_has_meter_stop();
  meter_stop_ = value;
}

// required int32 time_start = 6;
inline bool Transactions::has_time_start() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Transactions::set_has_time_start() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Transactions::clear_has_time_start() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Transactions::clear_time_start() {
  time_start_ = 0;
  clear_has_time_start();
}
inline ::google::protobuf::int32 Transactions::time_start() const {
  return time_start_;
}
inline void Transactions::set_time_start(::google::protobuf::int32 value) {
  set_has_time_start();
  time_start_ = value;
}

// required int32 time_stop = 7;
inline bool Transactions::has_time_stop() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Transactions::set_has_time_stop() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Transactions::clear_has_time_stop() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Transactions::clear_time_stop() {
  time_stop_ = 0;
  clear_has_time_stop();
}
inline ::google::protobuf::int32 Transactions::time_stop() const {
  return time_stop_;
}
inline void Transactions::set_time_stop(::google::protobuf::int32 value) {
  set_has_time_stop();
  time_stop_ = value;
}

// optional .cl_message.PriceScheme price_scheme = 8;
inline bool Transactions::has_price_scheme() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Transactions::set_has_price_scheme() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Transactions::clear_has_price_scheme() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Transactions::clear_price_scheme() {
  if (price_scheme_ != NULL) price_scheme_->::cl_message::PriceScheme::Clear();
  clear_has_price_scheme();
}
inline const ::cl_message::PriceScheme& Transactions::price_scheme() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return price_scheme_ != NULL ? *price_scheme_ : *default_instance().price_scheme_;
#else
  return price_scheme_ != NULL ? *price_scheme_ : *default_instance_->price_scheme_;
#endif
}
inline ::cl_message::PriceScheme* Transactions::mutable_price_scheme() {
  set_has_price_scheme();
  if (price_scheme_ == NULL) price_scheme_ = new ::cl_message::PriceScheme;
  return price_scheme_;
}
inline ::cl_message::PriceScheme* Transactions::release_price_scheme() {
  clear_has_price_scheme();
  ::cl_message::PriceScheme* temp = price_scheme_;
  price_scheme_ = NULL;
  return temp;
}
inline void Transactions::set_allocated_price_scheme(::cl_message::PriceScheme* price_scheme) {
  delete price_scheme_;
  price_scheme_ = price_scheme;
  if (price_scheme) {
    set_has_price_scheme();
  } else {
    clear_has_price_scheme();
  }
}

// required int32 stop_reason = 9;
inline bool Transactions::has_stop_reason() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Transactions::set_has_stop_reason() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Transactions::clear_has_stop_reason() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Transactions::clear_stop_reason() {
  stop_reason_ = 0;
  clear_has_stop_reason();
}
inline ::google::protobuf::int32 Transactions::stop_reason() const {
  return stop_reason_;
}
inline void Transactions::set_stop_reason(::google::protobuf::int32 value) {
  set_has_stop_reason();
  stop_reason_ = value;
}

// optional int32 time_spent_charging = 10;
inline bool Transactions::has_time_spent_charging() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Transactions::set_has_time_spent_charging() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Transactions::clear_has_time_spent_charging() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Transactions::clear_time_spent_charging() {
  time_spent_charging_ = 0;
  clear_has_time_spent_charging();
}
inline ::google::protobuf::int32 Transactions::time_spent_charging() const {
  return time_spent_charging_;
}
inline void Transactions::set_time_spent_charging(::google::protobuf::int32 value) {
  set_has_time_spent_charging();
  time_spent_charging_ = value;
}

// -------------------------------------------------------------------

// Tariff

// required int32 tariffid = 1;
inline bool Tariff::has_tariffid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tariff::set_has_tariffid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tariff::clear_has_tariffid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tariff::clear_tariffid() {
  tariffid_ = 0;
  clear_has_tariffid();
}
inline ::google::protobuf::int32 Tariff::tariffid() const {
  return tariffid_;
}
inline void Tariff::set_tariffid(::google::protobuf::int32 value) {
  set_has_tariffid();
  tariffid_ = value;
}

// optional string display_text = 2;
inline bool Tariff::has_display_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tariff::set_has_display_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tariff::clear_has_display_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tariff::clear_display_text() {
  if (display_text_ != &::google::protobuf::internal::kEmptyString) {
    display_text_->clear();
  }
  clear_has_display_text();
}
inline const ::std::string& Tariff::display_text() const {
  return *display_text_;
}
inline void Tariff::set_display_text(const ::std::string& value) {
  set_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    display_text_ = new ::std::string;
  }
  display_text_->assign(value);
}
inline void Tariff::set_display_text(const char* value) {
  set_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    display_text_ = new ::std::string;
  }
  display_text_->assign(value);
}
inline void Tariff::set_display_text(const char* value, size_t size) {
  set_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    display_text_ = new ::std::string;
  }
  display_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Tariff::mutable_display_text() {
  set_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    display_text_ = new ::std::string;
  }
  return display_text_;
}
inline ::std::string* Tariff::release_display_text() {
  clear_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = display_text_;
    display_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Tariff::set_allocated_display_text(::std::string* display_text) {
  if (display_text_ != &::google::protobuf::internal::kEmptyString) {
    delete display_text_;
  }
  if (display_text) {
    set_has_display_text();
    display_text_ = display_text;
  } else {
    clear_has_display_text();
    display_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .cl_message.PricingUnit price_unit = 3;
inline bool Tariff::has_price_unit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Tariff::set_has_price_unit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Tariff::clear_has_price_unit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Tariff::clear_price_unit() {
  price_unit_ = 0;
  clear_has_price_unit();
}
inline ::cl_message::PricingUnit Tariff::price_unit() const {
  return static_cast< ::cl_message::PricingUnit >(price_unit_);
}
inline void Tariff::set_price_unit(::cl_message::PricingUnit value) {
  assert(::cl_message::PricingUnit_IsValid(value));
  set_has_price_unit();
  price_unit_ = value;
}

// required int32 price = 4;
inline bool Tariff::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Tariff::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Tariff::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Tariff::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 Tariff::price() const {
  return price_;
}
inline void Tariff::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// -------------------------------------------------------------------

// PriceScheme

// required int32 price_scheme_id = 1;
inline bool PriceScheme::has_price_scheme_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PriceScheme::set_has_price_scheme_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PriceScheme::clear_has_price_scheme_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PriceScheme::clear_price_scheme_id() {
  price_scheme_id_ = 0;
  clear_has_price_scheme_id();
}
inline ::google::protobuf::int32 PriceScheme::price_scheme_id() const {
  return price_scheme_id_;
}
inline void PriceScheme::set_price_scheme_id(::google::protobuf::int32 value) {
  set_has_price_scheme_id();
  price_scheme_id_ = value;
}

// optional string display_text = 2;
inline bool PriceScheme::has_display_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PriceScheme::set_has_display_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PriceScheme::clear_has_display_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PriceScheme::clear_display_text() {
  if (display_text_ != &::google::protobuf::internal::kEmptyString) {
    display_text_->clear();
  }
  clear_has_display_text();
}
inline const ::std::string& PriceScheme::display_text() const {
  return *display_text_;
}
inline void PriceScheme::set_display_text(const ::std::string& value) {
  set_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    display_text_ = new ::std::string;
  }
  display_text_->assign(value);
}
inline void PriceScheme::set_display_text(const char* value) {
  set_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    display_text_ = new ::std::string;
  }
  display_text_->assign(value);
}
inline void PriceScheme::set_display_text(const char* value, size_t size) {
  set_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    display_text_ = new ::std::string;
  }
  display_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PriceScheme::mutable_display_text() {
  set_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    display_text_ = new ::std::string;
  }
  return display_text_;
}
inline ::std::string* PriceScheme::release_display_text() {
  clear_has_display_text();
  if (display_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = display_text_;
    display_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PriceScheme::set_allocated_display_text(::std::string* display_text) {
  if (display_text_ != &::google::protobuf::internal::kEmptyString) {
    delete display_text_;
  }
  if (display_text) {
    set_has_display_text();
    display_text_ = display_text;
  } else {
    clear_has_display_text();
    display_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 expiry_date = 3;
inline bool PriceScheme::has_expiry_date() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PriceScheme::set_has_expiry_date() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PriceScheme::clear_has_expiry_date() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PriceScheme::clear_expiry_date() {
  expiry_date_ = 0;
  clear_has_expiry_date();
}
inline ::google::protobuf::int32 PriceScheme::expiry_date() const {
  return expiry_date_;
}
inline void PriceScheme::set_expiry_date(::google::protobuf::int32 value) {
  set_has_expiry_date();
  expiry_date_ = value;
}

// repeated .cl_message.Tariff tariff = 4;
inline int PriceScheme::tariff_size() const {
  return tariff_.size();
}
inline void PriceScheme::clear_tariff() {
  tariff_.Clear();
}
inline const ::cl_message::Tariff& PriceScheme::tariff(int index) const {
  return tariff_.Get(index);
}
inline ::cl_message::Tariff* PriceScheme::mutable_tariff(int index) {
  return tariff_.Mutable(index);
}
inline ::cl_message::Tariff* PriceScheme::add_tariff() {
  return tariff_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cl_message::Tariff >&
PriceScheme::tariff() const {
  return tariff_;
}
inline ::google::protobuf::RepeatedPtrField< ::cl_message::Tariff >*
PriceScheme::mutable_tariff() {
  return &tariff_;
}

// -------------------------------------------------------------------

// ConfigOption

// required string name = 1;
inline bool ConfigOption::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigOption::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigOption::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigOption::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ConfigOption::name() const {
  return *name_;
}
inline void ConfigOption::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConfigOption::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConfigOption::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigOption::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ConfigOption::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfigOption::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool ConfigOption::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigOption::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigOption::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigOption::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ConfigOption::value() const {
  return *value_;
}
inline void ConfigOption::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ConfigOption::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ConfigOption::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigOption::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ConfigOption::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfigOption::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConfigSection

// required string section = 1;
inline bool ConfigSection::has_section() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigSection::set_has_section() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigSection::clear_has_section() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigSection::clear_section() {
  if (section_ != &::google::protobuf::internal::kEmptyString) {
    section_->clear();
  }
  clear_has_section();
}
inline const ::std::string& ConfigSection::section() const {
  return *section_;
}
inline void ConfigSection::set_section(const ::std::string& value) {
  set_has_section();
  if (section_ == &::google::protobuf::internal::kEmptyString) {
    section_ = new ::std::string;
  }
  section_->assign(value);
}
inline void ConfigSection::set_section(const char* value) {
  set_has_section();
  if (section_ == &::google::protobuf::internal::kEmptyString) {
    section_ = new ::std::string;
  }
  section_->assign(value);
}
inline void ConfigSection::set_section(const char* value, size_t size) {
  set_has_section();
  if (section_ == &::google::protobuf::internal::kEmptyString) {
    section_ = new ::std::string;
  }
  section_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigSection::mutable_section() {
  set_has_section();
  if (section_ == &::google::protobuf::internal::kEmptyString) {
    section_ = new ::std::string;
  }
  return section_;
}
inline ::std::string* ConfigSection::release_section() {
  clear_has_section();
  if (section_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = section_;
    section_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfigSection::set_allocated_section(::std::string* section) {
  if (section_ != &::google::protobuf::internal::kEmptyString) {
    delete section_;
  }
  if (section) {
    set_has_section();
    section_ = section;
  } else {
    clear_has_section();
    section_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool ConfigSection::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigSection::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigSection::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigSection::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ConfigSection::name() const {
  return *name_;
}
inline void ConfigSection::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConfigSection::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConfigSection::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigSection::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ConfigSection::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfigSection::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 value = 3;
inline bool ConfigSection::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConfigSection::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConfigSection::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConfigSection::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 ConfigSection::value() const {
  return value_;
}
inline void ConfigSection::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// repeated .cl_message.ConfigOption options = 4;
inline int ConfigSection::options_size() const {
  return options_.size();
}
inline void ConfigSection::clear_options() {
  options_.Clear();
}
inline const ::cl_message::ConfigOption& ConfigSection::options(int index) const {
  return options_.Get(index);
}
inline ::cl_message::ConfigOption* ConfigSection::mutable_options(int index) {
  return options_.Mutable(index);
}
inline ::cl_message::ConfigOption* ConfigSection::add_options() {
  return options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cl_message::ConfigOption >&
ConfigSection::options() const {
  return options_;
}
inline ::google::protobuf::RepeatedPtrField< ::cl_message::ConfigOption >*
ConfigSection::mutable_options() {
  return &options_;
}

// -------------------------------------------------------------------

// RequestStart_Request

// optional int32 connector_id = 1;
inline bool RequestStart_Request::has_connector_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestStart_Request::set_has_connector_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestStart_Request::clear_has_connector_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestStart_Request::clear_connector_id() {
  connector_id_ = 0;
  clear_has_connector_id();
}
inline ::google::protobuf::int32 RequestStart_Request::connector_id() const {
  return connector_id_;
}
inline void RequestStart_Request::set_connector_id(::google::protobuf::int32 value) {
  set_has_connector_id();
  connector_id_ = value;
}

// required .cl_message.IdToken id_tag = 2;
inline bool RequestStart_Request::has_id_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestStart_Request::set_has_id_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestStart_Request::clear_has_id_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestStart_Request::clear_id_tag() {
  if (id_tag_ != NULL) id_tag_->::cl_message::IdToken::Clear();
  clear_has_id_tag();
}
inline const ::cl_message::IdToken& RequestStart_Request::id_tag() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_tag_ != NULL ? *id_tag_ : *default_instance().id_tag_;
#else
  return id_tag_ != NULL ? *id_tag_ : *default_instance_->id_tag_;
#endif
}
inline ::cl_message::IdToken* RequestStart_Request::mutable_id_tag() {
  set_has_id_tag();
  if (id_tag_ == NULL) id_tag_ = new ::cl_message::IdToken;
  return id_tag_;
}
inline ::cl_message::IdToken* RequestStart_Request::release_id_tag() {
  clear_has_id_tag();
  ::cl_message::IdToken* temp = id_tag_;
  id_tag_ = NULL;
  return temp;
}
inline void RequestStart_Request::set_allocated_id_tag(::cl_message::IdToken* id_tag) {
  delete id_tag_;
  id_tag_ = id_tag;
  if (id_tag) {
    set_has_id_tag();
  } else {
    clear_has_id_tag();
  }
}

// optional string pin_code = 3;
inline bool RequestStart_Request::has_pin_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestStart_Request::set_has_pin_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestStart_Request::clear_has_pin_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestStart_Request::clear_pin_code() {
  if (pin_code_ != &::google::protobuf::internal::kEmptyString) {
    pin_code_->clear();
  }
  clear_has_pin_code();
}
inline const ::std::string& RequestStart_Request::pin_code() const {
  return *pin_code_;
}
inline void RequestStart_Request::set_pin_code(const ::std::string& value) {
  set_has_pin_code();
  if (pin_code_ == &::google::protobuf::internal::kEmptyString) {
    pin_code_ = new ::std::string;
  }
  pin_code_->assign(value);
}
inline void RequestStart_Request::set_pin_code(const char* value) {
  set_has_pin_code();
  if (pin_code_ == &::google::protobuf::internal::kEmptyString) {
    pin_code_ = new ::std::string;
  }
  pin_code_->assign(value);
}
inline void RequestStart_Request::set_pin_code(const char* value, size_t size) {
  set_has_pin_code();
  if (pin_code_ == &::google::protobuf::internal::kEmptyString) {
    pin_code_ = new ::std::string;
  }
  pin_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestStart_Request::mutable_pin_code() {
  set_has_pin_code();
  if (pin_code_ == &::google::protobuf::internal::kEmptyString) {
    pin_code_ = new ::std::string;
  }
  return pin_code_;
}
inline ::std::string* RequestStart_Request::release_pin_code() {
  clear_has_pin_code();
  if (pin_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_code_;
    pin_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestStart_Request::set_allocated_pin_code(::std::string* pin_code) {
  if (pin_code_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_code_;
  }
  if (pin_code) {
    set_has_pin_code();
    pin_code_ = pin_code;
  } else {
    clear_has_pin_code();
    pin_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string transparent = 4;
inline bool RequestStart_Request::has_transparent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestStart_Request::set_has_transparent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestStart_Request::clear_has_transparent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestStart_Request::clear_transparent() {
  if (transparent_ != &::google::protobuf::internal::kEmptyString) {
    transparent_->clear();
  }
  clear_has_transparent();
}
inline const ::std::string& RequestStart_Request::transparent() const {
  return *transparent_;
}
inline void RequestStart_Request::set_transparent(const ::std::string& value) {
  set_has_transparent();
  if (transparent_ == &::google::protobuf::internal::kEmptyString) {
    transparent_ = new ::std::string;
  }
  transparent_->assign(value);
}
inline void RequestStart_Request::set_transparent(const char* value) {
  set_has_transparent();
  if (transparent_ == &::google::protobuf::internal::kEmptyString) {
    transparent_ = new ::std::string;
  }
  transparent_->assign(value);
}
inline void RequestStart_Request::set_transparent(const char* value, size_t size) {
  set_has_transparent();
  if (transparent_ == &::google::protobuf::internal::kEmptyString) {
    transparent_ = new ::std::string;
  }
  transparent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestStart_Request::mutable_transparent() {
  set_has_transparent();
  if (transparent_ == &::google::protobuf::internal::kEmptyString) {
    transparent_ = new ::std::string;
  }
  return transparent_;
}
inline ::std::string* RequestStart_Request::release_transparent() {
  clear_has_transparent();
  if (transparent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transparent_;
    transparent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestStart_Request::set_allocated_transparent(::std::string* transparent) {
  if (transparent_ != &::google::protobuf::internal::kEmptyString) {
    delete transparent_;
  }
  if (transparent) {
    set_has_transparent();
    transparent_ = transparent;
  } else {
    clear_has_transparent();
    transparent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestStart_Confirm

// required int32 status = 1;
inline bool RequestStart_Confirm::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestStart_Confirm::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestStart_Confirm::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestStart_Confirm::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 RequestStart_Confirm::status() const {
  return status_;
}
inline void RequestStart_Confirm::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// RequestStart

// optional .cl_message.RequestStart.Request req = 1;
inline bool RequestStart::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestStart::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestStart::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestStart::clear_req() {
  if (req_ != NULL) req_->::cl_message::RequestStart_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::RequestStart_Request& RequestStart::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::RequestStart_Request* RequestStart::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::RequestStart_Request;
  return req_;
}
inline ::cl_message::RequestStart_Request* RequestStart::release_req() {
  clear_has_req();
  ::cl_message::RequestStart_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void RequestStart::set_allocated_req(::cl_message::RequestStart_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.RequestStart.Confirm conf = 2;
inline bool RequestStart::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestStart::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestStart::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestStart::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::RequestStart_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::RequestStart_Confirm& RequestStart::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::RequestStart_Confirm* RequestStart::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::RequestStart_Confirm;
  return conf_;
}
inline ::cl_message::RequestStart_Confirm* RequestStart::release_conf() {
  clear_has_conf();
  ::cl_message::RequestStart_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void RequestStart::set_allocated_conf(::cl_message::RequestStart_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// RequestStop_Request

// required uint64 transaction_id = 1;
inline bool RequestStop_Request::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestStop_Request::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestStop_Request::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestStop_Request::clear_transaction_id() {
  transaction_id_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::uint64 RequestStop_Request::transaction_id() const {
  return transaction_id_;
}
inline void RequestStop_Request::set_transaction_id(::google::protobuf::uint64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
}

// -------------------------------------------------------------------

// RequestStop_Confirm

// required int32 status = 1;
inline bool RequestStop_Confirm::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestStop_Confirm::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestStop_Confirm::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestStop_Confirm::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 RequestStop_Confirm::status() const {
  return status_;
}
inline void RequestStop_Confirm::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// RequestStop

// optional .cl_message.RequestStop.Request req = 1;
inline bool RequestStop::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestStop::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestStop::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestStop::clear_req() {
  if (req_ != NULL) req_->::cl_message::RequestStop_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::RequestStop_Request& RequestStop::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::RequestStop_Request* RequestStop::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::RequestStop_Request;
  return req_;
}
inline ::cl_message::RequestStop_Request* RequestStop::release_req() {
  clear_has_req();
  ::cl_message::RequestStop_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void RequestStop::set_allocated_req(::cl_message::RequestStop_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.RequestStop.Confirm conf = 2;
inline bool RequestStop::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestStop::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestStop::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestStop::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::RequestStop_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::RequestStop_Confirm& RequestStop::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::RequestStop_Confirm* RequestStop::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::RequestStop_Confirm;
  return conf_;
}
inline ::cl_message::RequestStop_Confirm* RequestStop::release_conf() {
  clear_has_conf();
  ::cl_message::RequestStop_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void RequestStop::set_allocated_conf(::cl_message::RequestStop_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// GetTransactions_Request

// optional int32 start_time = 1;
inline bool GetTransactions_Request::has_start_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTransactions_Request::set_has_start_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTransactions_Request::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTransactions_Request::clear_start_time() {
  start_time_ = 0;
  clear_has_start_time();
}
inline ::google::protobuf::int32 GetTransactions_Request::start_time() const {
  return start_time_;
}
inline void GetTransactions_Request::set_start_time(::google::protobuf::int32 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional int32 end_time = 2;
inline bool GetTransactions_Request::has_end_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTransactions_Request::set_has_end_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTransactions_Request::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTransactions_Request::clear_end_time() {
  end_time_ = 0;
  clear_has_end_time();
}
inline ::google::protobuf::int32 GetTransactions_Request::end_time() const {
  return end_time_;
}
inline void GetTransactions_Request::set_end_time(::google::protobuf::int32 value) {
  set_has_end_time();
  end_time_ = value;
}

// optional int32 pos = 3;
inline bool GetTransactions_Request::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetTransactions_Request::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetTransactions_Request::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetTransactions_Request::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 GetTransactions_Request::pos() const {
  return pos_;
}
inline void GetTransactions_Request::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// optional int32 count = 4;
inline bool GetTransactions_Request::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetTransactions_Request::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetTransactions_Request::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetTransactions_Request::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 GetTransactions_Request::count() const {
  return count_;
}
inline void GetTransactions_Request::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// GetTransactions_Confirm

// required int32 count = 1;
inline bool GetTransactions_Confirm::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTransactions_Confirm::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTransactions_Confirm::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTransactions_Confirm::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 GetTransactions_Confirm::count() const {
  return count_;
}
inline void GetTransactions_Confirm::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// GetTransactions

// optional .cl_message.GetTransactions.Request req = 1;
inline bool GetTransactions::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTransactions::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTransactions::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTransactions::clear_req() {
  if (req_ != NULL) req_->::cl_message::GetTransactions_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::GetTransactions_Request& GetTransactions::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::GetTransactions_Request* GetTransactions::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::GetTransactions_Request;
  return req_;
}
inline ::cl_message::GetTransactions_Request* GetTransactions::release_req() {
  clear_has_req();
  ::cl_message::GetTransactions_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void GetTransactions::set_allocated_req(::cl_message::GetTransactions_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.GetTransactions.Confirm conf = 2;
inline bool GetTransactions::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTransactions::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTransactions::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTransactions::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::GetTransactions_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::GetTransactions_Confirm& GetTransactions::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::GetTransactions_Confirm* GetTransactions::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::GetTransactions_Confirm;
  return conf_;
}
inline ::cl_message::GetTransactions_Confirm* GetTransactions::release_conf() {
  clear_has_conf();
  ::cl_message::GetTransactions_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void GetTransactions::set_allocated_conf(::cl_message::GetTransactions_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// UpgradeFirmware_Request

// required string location = 1;
inline bool UpgradeFirmware_Request::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeFirmware_Request::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeFirmware_Request::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeFirmware_Request::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& UpgradeFirmware_Request::location() const {
  return *location_;
}
inline void UpgradeFirmware_Request::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void UpgradeFirmware_Request::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void UpgradeFirmware_Request::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpgradeFirmware_Request::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* UpgradeFirmware_Request::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpgradeFirmware_Request::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string md5 = 2;
inline bool UpgradeFirmware_Request::has_md5() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpgradeFirmware_Request::set_has_md5() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpgradeFirmware_Request::clear_has_md5() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpgradeFirmware_Request::clear_md5() {
  if (md5_ != &::google::protobuf::internal::kEmptyString) {
    md5_->clear();
  }
  clear_has_md5();
}
inline const ::std::string& UpgradeFirmware_Request::md5() const {
  return *md5_;
}
inline void UpgradeFirmware_Request::set_md5(const ::std::string& value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void UpgradeFirmware_Request::set_md5(const char* value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void UpgradeFirmware_Request::set_md5(const char* value, size_t size) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpgradeFirmware_Request::mutable_md5() {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  return md5_;
}
inline ::std::string* UpgradeFirmware_Request::release_md5() {
  clear_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = md5_;
    md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpgradeFirmware_Request::set_allocated_md5(::std::string* md5) {
  if (md5_ != &::google::protobuf::internal::kEmptyString) {
    delete md5_;
  }
  if (md5) {
    set_has_md5();
    md5_ = md5;
  } else {
    clear_has_md5();
    md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 retries = 3;
inline bool UpgradeFirmware_Request::has_retries() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpgradeFirmware_Request::set_has_retries() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpgradeFirmware_Request::clear_has_retries() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpgradeFirmware_Request::clear_retries() {
  retries_ = 0;
  clear_has_retries();
}
inline ::google::protobuf::int32 UpgradeFirmware_Request::retries() const {
  return retries_;
}
inline void UpgradeFirmware_Request::set_retries(::google::protobuf::int32 value) {
  set_has_retries();
  retries_ = value;
}

// optional string retrieve_date = 4;
inline bool UpgradeFirmware_Request::has_retrieve_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpgradeFirmware_Request::set_has_retrieve_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpgradeFirmware_Request::clear_has_retrieve_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpgradeFirmware_Request::clear_retrieve_date() {
  if (retrieve_date_ != &::google::protobuf::internal::kEmptyString) {
    retrieve_date_->clear();
  }
  clear_has_retrieve_date();
}
inline const ::std::string& UpgradeFirmware_Request::retrieve_date() const {
  return *retrieve_date_;
}
inline void UpgradeFirmware_Request::set_retrieve_date(const ::std::string& value) {
  set_has_retrieve_date();
  if (retrieve_date_ == &::google::protobuf::internal::kEmptyString) {
    retrieve_date_ = new ::std::string;
  }
  retrieve_date_->assign(value);
}
inline void UpgradeFirmware_Request::set_retrieve_date(const char* value) {
  set_has_retrieve_date();
  if (retrieve_date_ == &::google::protobuf::internal::kEmptyString) {
    retrieve_date_ = new ::std::string;
  }
  retrieve_date_->assign(value);
}
inline void UpgradeFirmware_Request::set_retrieve_date(const char* value, size_t size) {
  set_has_retrieve_date();
  if (retrieve_date_ == &::google::protobuf::internal::kEmptyString) {
    retrieve_date_ = new ::std::string;
  }
  retrieve_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpgradeFirmware_Request::mutable_retrieve_date() {
  set_has_retrieve_date();
  if (retrieve_date_ == &::google::protobuf::internal::kEmptyString) {
    retrieve_date_ = new ::std::string;
  }
  return retrieve_date_;
}
inline ::std::string* UpgradeFirmware_Request::release_retrieve_date() {
  clear_has_retrieve_date();
  if (retrieve_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = retrieve_date_;
    retrieve_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpgradeFirmware_Request::set_allocated_retrieve_date(::std::string* retrieve_date) {
  if (retrieve_date_ != &::google::protobuf::internal::kEmptyString) {
    delete retrieve_date_;
  }
  if (retrieve_date) {
    set_has_retrieve_date();
    retrieve_date_ = retrieve_date;
  } else {
    clear_has_retrieve_date();
    retrieve_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 retry_interval = 5;
inline bool UpgradeFirmware_Request::has_retry_interval() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpgradeFirmware_Request::set_has_retry_interval() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpgradeFirmware_Request::clear_has_retry_interval() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpgradeFirmware_Request::clear_retry_interval() {
  retry_interval_ = 0;
  clear_has_retry_interval();
}
inline ::google::protobuf::int32 UpgradeFirmware_Request::retry_interval() const {
  return retry_interval_;
}
inline void UpgradeFirmware_Request::set_retry_interval(::google::protobuf::int32 value) {
  set_has_retry_interval();
  retry_interval_ = value;
}

// -------------------------------------------------------------------

// UpgradeFirmware_Confirm

// required int32 status = 1;
inline bool UpgradeFirmware_Confirm::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeFirmware_Confirm::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeFirmware_Confirm::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeFirmware_Confirm::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 UpgradeFirmware_Confirm::status() const {
  return status_;
}
inline void UpgradeFirmware_Confirm::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// UpgradeFirmware

// optional .cl_message.UpgradeFirmware.Request req = 1;
inline bool UpgradeFirmware::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeFirmware::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeFirmware::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeFirmware::clear_req() {
  if (req_ != NULL) req_->::cl_message::UpgradeFirmware_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::UpgradeFirmware_Request& UpgradeFirmware::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::UpgradeFirmware_Request* UpgradeFirmware::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::UpgradeFirmware_Request;
  return req_;
}
inline ::cl_message::UpgradeFirmware_Request* UpgradeFirmware::release_req() {
  clear_has_req();
  ::cl_message::UpgradeFirmware_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void UpgradeFirmware::set_allocated_req(::cl_message::UpgradeFirmware_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.UpgradeFirmware.Confirm conf = 2;
inline bool UpgradeFirmware::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpgradeFirmware::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpgradeFirmware::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpgradeFirmware::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::UpgradeFirmware_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::UpgradeFirmware_Confirm& UpgradeFirmware::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::UpgradeFirmware_Confirm* UpgradeFirmware::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::UpgradeFirmware_Confirm;
  return conf_;
}
inline ::cl_message::UpgradeFirmware_Confirm* UpgradeFirmware::release_conf() {
  clear_has_conf();
  ::cl_message::UpgradeFirmware_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void UpgradeFirmware::set_allocated_conf(::cl_message::UpgradeFirmware_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// SetConfiguration_Request

// required string filename = 1;
inline bool SetConfiguration_Request::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetConfiguration_Request::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetConfiguration_Request::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetConfiguration_Request::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& SetConfiguration_Request::filename() const {
  return *filename_;
}
inline void SetConfiguration_Request::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void SetConfiguration_Request::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void SetConfiguration_Request::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SetConfiguration_Request::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* SetConfiguration_Request::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SetConfiguration_Request::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .cl_message.ConfigSection sections = 2;
inline int SetConfiguration_Request::sections_size() const {
  return sections_.size();
}
inline void SetConfiguration_Request::clear_sections() {
  sections_.Clear();
}
inline const ::cl_message::ConfigSection& SetConfiguration_Request::sections(int index) const {
  return sections_.Get(index);
}
inline ::cl_message::ConfigSection* SetConfiguration_Request::mutable_sections(int index) {
  return sections_.Mutable(index);
}
inline ::cl_message::ConfigSection* SetConfiguration_Request::add_sections() {
  return sections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cl_message::ConfigSection >&
SetConfiguration_Request::sections() const {
  return sections_;
}
inline ::google::protobuf::RepeatedPtrField< ::cl_message::ConfigSection >*
SetConfiguration_Request::mutable_sections() {
  return &sections_;
}

// -------------------------------------------------------------------

// SetConfiguration_Confirm

// required int32 status = 1;
inline bool SetConfiguration_Confirm::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetConfiguration_Confirm::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetConfiguration_Confirm::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetConfiguration_Confirm::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 SetConfiguration_Confirm::status() const {
  return status_;
}
inline void SetConfiguration_Confirm::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// SetConfiguration

// optional .cl_message.SetConfiguration.Request req = 1;
inline bool SetConfiguration::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetConfiguration::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetConfiguration::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetConfiguration::clear_req() {
  if (req_ != NULL) req_->::cl_message::SetConfiguration_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::SetConfiguration_Request& SetConfiguration::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::SetConfiguration_Request* SetConfiguration::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::SetConfiguration_Request;
  return req_;
}
inline ::cl_message::SetConfiguration_Request* SetConfiguration::release_req() {
  clear_has_req();
  ::cl_message::SetConfiguration_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void SetConfiguration::set_allocated_req(::cl_message::SetConfiguration_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.SetConfiguration.Confirm conf = 2;
inline bool SetConfiguration::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetConfiguration::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetConfiguration::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetConfiguration::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::SetConfiguration_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::SetConfiguration_Confirm& SetConfiguration::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::SetConfiguration_Confirm* SetConfiguration::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::SetConfiguration_Confirm;
  return conf_;
}
inline ::cl_message::SetConfiguration_Confirm* SetConfiguration::release_conf() {
  clear_has_conf();
  ::cl_message::SetConfiguration_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void SetConfiguration::set_allocated_conf(::cl_message::SetConfiguration_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// SetPricing_Request

// required .cl_message.PriceScheme price_scheme = 1;
inline bool SetPricing_Request::has_price_scheme() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetPricing_Request::set_has_price_scheme() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetPricing_Request::clear_has_price_scheme() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetPricing_Request::clear_price_scheme() {
  if (price_scheme_ != NULL) price_scheme_->::cl_message::PriceScheme::Clear();
  clear_has_price_scheme();
}
inline const ::cl_message::PriceScheme& SetPricing_Request::price_scheme() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return price_scheme_ != NULL ? *price_scheme_ : *default_instance().price_scheme_;
#else
  return price_scheme_ != NULL ? *price_scheme_ : *default_instance_->price_scheme_;
#endif
}
inline ::cl_message::PriceScheme* SetPricing_Request::mutable_price_scheme() {
  set_has_price_scheme();
  if (price_scheme_ == NULL) price_scheme_ = new ::cl_message::PriceScheme;
  return price_scheme_;
}
inline ::cl_message::PriceScheme* SetPricing_Request::release_price_scheme() {
  clear_has_price_scheme();
  ::cl_message::PriceScheme* temp = price_scheme_;
  price_scheme_ = NULL;
  return temp;
}
inline void SetPricing_Request::set_allocated_price_scheme(::cl_message::PriceScheme* price_scheme) {
  delete price_scheme_;
  price_scheme_ = price_scheme;
  if (price_scheme) {
    set_has_price_scheme();
  } else {
    clear_has_price_scheme();
  }
}

// -------------------------------------------------------------------

// SetPricing_Confirm

// required int32 status = 1;
inline bool SetPricing_Confirm::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetPricing_Confirm::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetPricing_Confirm::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetPricing_Confirm::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 SetPricing_Confirm::status() const {
  return status_;
}
inline void SetPricing_Confirm::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// SetPricing

// optional .cl_message.SetPricing.Request req = 1;
inline bool SetPricing::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetPricing::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetPricing::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetPricing::clear_req() {
  if (req_ != NULL) req_->::cl_message::SetPricing_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::SetPricing_Request& SetPricing::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::SetPricing_Request* SetPricing::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::SetPricing_Request;
  return req_;
}
inline ::cl_message::SetPricing_Request* SetPricing::release_req() {
  clear_has_req();
  ::cl_message::SetPricing_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void SetPricing::set_allocated_req(::cl_message::SetPricing_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.SetPricing.Confirm conf = 2;
inline bool SetPricing::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetPricing::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetPricing::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetPricing::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::SetPricing_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::SetPricing_Confirm& SetPricing::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::SetPricing_Confirm* SetPricing::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::SetPricing_Confirm;
  return conf_;
}
inline ::cl_message::SetPricing_Confirm* SetPricing::release_conf() {
  clear_has_conf();
  ::cl_message::SetPricing_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void SetPricing::set_allocated_conf(::cl_message::SetPricing_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// Reset_Request

// required int32 reset_type = 1;
inline bool Reset_Request::has_reset_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reset_Request::set_has_reset_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reset_Request::clear_has_reset_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reset_Request::clear_reset_type() {
  reset_type_ = 0;
  clear_has_reset_type();
}
inline ::google::protobuf::int32 Reset_Request::reset_type() const {
  return reset_type_;
}
inline void Reset_Request::set_reset_type(::google::protobuf::int32 value) {
  set_has_reset_type();
  reset_type_ = value;
}

// optional int32 connector_id = 2;
inline bool Reset_Request::has_connector_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reset_Request::set_has_connector_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reset_Request::clear_has_connector_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reset_Request::clear_connector_id() {
  connector_id_ = 0;
  clear_has_connector_id();
}
inline ::google::protobuf::int32 Reset_Request::connector_id() const {
  return connector_id_;
}
inline void Reset_Request::set_connector_id(::google::protobuf::int32 value) {
  set_has_connector_id();
  connector_id_ = value;
}

// -------------------------------------------------------------------

// Reset_Confirm

// required int32 status = 1;
inline bool Reset_Confirm::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reset_Confirm::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reset_Confirm::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reset_Confirm::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 Reset_Confirm::status() const {
  return status_;
}
inline void Reset_Confirm::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// Reset

// optional .cl_message.Reset.Request req = 1;
inline bool Reset::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reset::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reset::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reset::clear_req() {
  if (req_ != NULL) req_->::cl_message::Reset_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::Reset_Request& Reset::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::Reset_Request* Reset::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::Reset_Request;
  return req_;
}
inline ::cl_message::Reset_Request* Reset::release_req() {
  clear_has_req();
  ::cl_message::Reset_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void Reset::set_allocated_req(::cl_message::Reset_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.Reset.Confirm conf = 2;
inline bool Reset::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reset::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reset::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reset::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::Reset_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::Reset_Confirm& Reset::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::Reset_Confirm* Reset::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::Reset_Confirm;
  return conf_;
}
inline ::cl_message::Reset_Confirm* Reset::release_conf() {
  clear_has_conf();
  ::cl_message::Reset_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void Reset::set_allocated_conf(::cl_message::Reset_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// ParkLock_Request

// required int32 lockid = 1;
inline bool ParkLock_Request::has_lockid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParkLock_Request::set_has_lockid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParkLock_Request::clear_has_lockid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParkLock_Request::clear_lockid() {
  lockid_ = 0;
  clear_has_lockid();
}
inline ::google::protobuf::int32 ParkLock_Request::lockid() const {
  return lockid_;
}
inline void ParkLock_Request::set_lockid(::google::protobuf::int32 value) {
  set_has_lockid();
  lockid_ = value;
}

// required int32 lock = 2;
inline bool ParkLock_Request::has_lock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParkLock_Request::set_has_lock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParkLock_Request::clear_has_lock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParkLock_Request::clear_lock() {
  lock_ = 0;
  clear_has_lock();
}
inline ::google::protobuf::int32 ParkLock_Request::lock() const {
  return lock_;
}
inline void ParkLock_Request::set_lock(::google::protobuf::int32 value) {
  set_has_lock();
  lock_ = value;
}

// -------------------------------------------------------------------

// ParkLock_Confirm

// required int32 status = 1;
inline bool ParkLock_Confirm::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParkLock_Confirm::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParkLock_Confirm::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParkLock_Confirm::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ParkLock_Confirm::status() const {
  return status_;
}
inline void ParkLock_Confirm::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// ParkLock

// optional .cl_message.ParkLock.Request req = 1;
inline bool ParkLock::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParkLock::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParkLock::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParkLock::clear_req() {
  if (req_ != NULL) req_->::cl_message::ParkLock_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::ParkLock_Request& ParkLock::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::ParkLock_Request* ParkLock::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::ParkLock_Request;
  return req_;
}
inline ::cl_message::ParkLock_Request* ParkLock::release_req() {
  clear_has_req();
  ::cl_message::ParkLock_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void ParkLock::set_allocated_req(::cl_message::ParkLock_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.ParkLock.Confirm conf = 2;
inline bool ParkLock::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParkLock::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParkLock::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParkLock::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::ParkLock_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::ParkLock_Confirm& ParkLock::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::ParkLock_Confirm* ParkLock::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::ParkLock_Confirm;
  return conf_;
}
inline ::cl_message::ParkLock_Confirm* ParkLock::release_conf() {
  clear_has_conf();
  ::cl_message::ParkLock_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void ParkLock::set_allocated_conf(::cl_message::ParkLock_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// Authorize_Request

// required .cl_message.IdToken id_tag = 1;
inline bool Authorize_Request::has_id_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authorize_Request::set_has_id_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authorize_Request::clear_has_id_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authorize_Request::clear_id_tag() {
  if (id_tag_ != NULL) id_tag_->::cl_message::IdToken::Clear();
  clear_has_id_tag();
}
inline const ::cl_message::IdToken& Authorize_Request::id_tag() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_tag_ != NULL ? *id_tag_ : *default_instance().id_tag_;
#else
  return id_tag_ != NULL ? *id_tag_ : *default_instance_->id_tag_;
#endif
}
inline ::cl_message::IdToken* Authorize_Request::mutable_id_tag() {
  set_has_id_tag();
  if (id_tag_ == NULL) id_tag_ = new ::cl_message::IdToken;
  return id_tag_;
}
inline ::cl_message::IdToken* Authorize_Request::release_id_tag() {
  clear_has_id_tag();
  ::cl_message::IdToken* temp = id_tag_;
  id_tag_ = NULL;
  return temp;
}
inline void Authorize_Request::set_allocated_id_tag(::cl_message::IdToken* id_tag) {
  delete id_tag_;
  id_tag_ = id_tag;
  if (id_tag) {
    set_has_id_tag();
  } else {
    clear_has_id_tag();
  }
}

// -------------------------------------------------------------------

// Authorize_Confirm

// optional .cl_message.IdTagInfo id_info = 1;
inline bool Authorize_Confirm::has_id_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authorize_Confirm::set_has_id_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authorize_Confirm::clear_has_id_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authorize_Confirm::clear_id_info() {
  if (id_info_ != NULL) id_info_->::cl_message::IdTagInfo::Clear();
  clear_has_id_info();
}
inline const ::cl_message::IdTagInfo& Authorize_Confirm::id_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_info_ != NULL ? *id_info_ : *default_instance().id_info_;
#else
  return id_info_ != NULL ? *id_info_ : *default_instance_->id_info_;
#endif
}
inline ::cl_message::IdTagInfo* Authorize_Confirm::mutable_id_info() {
  set_has_id_info();
  if (id_info_ == NULL) id_info_ = new ::cl_message::IdTagInfo;
  return id_info_;
}
inline ::cl_message::IdTagInfo* Authorize_Confirm::release_id_info() {
  clear_has_id_info();
  ::cl_message::IdTagInfo* temp = id_info_;
  id_info_ = NULL;
  return temp;
}
inline void Authorize_Confirm::set_allocated_id_info(::cl_message::IdTagInfo* id_info) {
  delete id_info_;
  id_info_ = id_info;
  if (id_info) {
    set_has_id_info();
  } else {
    clear_has_id_info();
  }
}

// optional int32 price_scheme_id = 2;
inline bool Authorize_Confirm::has_price_scheme_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Authorize_Confirm::set_has_price_scheme_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Authorize_Confirm::clear_has_price_scheme_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Authorize_Confirm::clear_price_scheme_id() {
  price_scheme_id_ = 0;
  clear_has_price_scheme_id();
}
inline ::google::protobuf::int32 Authorize_Confirm::price_scheme_id() const {
  return price_scheme_id_;
}
inline void Authorize_Confirm::set_price_scheme_id(::google::protobuf::int32 value) {
  set_has_price_scheme_id();
  price_scheme_id_ = value;
}

// -------------------------------------------------------------------

// Authorize

// optional .cl_message.Authorize.Request req = 1;
inline bool Authorize::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authorize::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Authorize::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Authorize::clear_req() {
  if (req_ != NULL) req_->::cl_message::Authorize_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::Authorize_Request& Authorize::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::Authorize_Request* Authorize::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::Authorize_Request;
  return req_;
}
inline ::cl_message::Authorize_Request* Authorize::release_req() {
  clear_has_req();
  ::cl_message::Authorize_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void Authorize::set_allocated_req(::cl_message::Authorize_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.Authorize.Confirm conf = 2;
inline bool Authorize::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Authorize::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Authorize::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Authorize::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::Authorize_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::Authorize_Confirm& Authorize::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::Authorize_Confirm* Authorize::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::Authorize_Confirm;
  return conf_;
}
inline ::cl_message::Authorize_Confirm* Authorize::release_conf() {
  clear_has_conf();
  ::cl_message::Authorize_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void Authorize::set_allocated_conf(::cl_message::Authorize_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// TransactionStarted_Request

// optional int32 connector_id = 1;
inline bool TransactionStarted_Request::has_connector_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionStarted_Request::set_has_connector_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionStarted_Request::clear_has_connector_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionStarted_Request::clear_connector_id() {
  connector_id_ = 0;
  clear_has_connector_id();
}
inline ::google::protobuf::int32 TransactionStarted_Request::connector_id() const {
  return connector_id_;
}
inline void TransactionStarted_Request::set_connector_id(::google::protobuf::int32 value) {
  set_has_connector_id();
  connector_id_ = value;
}

// required .cl_message.IdToken id_tag = 2;
inline bool TransactionStarted_Request::has_id_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionStarted_Request::set_has_id_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionStarted_Request::clear_has_id_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionStarted_Request::clear_id_tag() {
  if (id_tag_ != NULL) id_tag_->::cl_message::IdToken::Clear();
  clear_has_id_tag();
}
inline const ::cl_message::IdToken& TransactionStarted_Request::id_tag() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_tag_ != NULL ? *id_tag_ : *default_instance().id_tag_;
#else
  return id_tag_ != NULL ? *id_tag_ : *default_instance_->id_tag_;
#endif
}
inline ::cl_message::IdToken* TransactionStarted_Request::mutable_id_tag() {
  set_has_id_tag();
  if (id_tag_ == NULL) id_tag_ = new ::cl_message::IdToken;
  return id_tag_;
}
inline ::cl_message::IdToken* TransactionStarted_Request::release_id_tag() {
  clear_has_id_tag();
  ::cl_message::IdToken* temp = id_tag_;
  id_tag_ = NULL;
  return temp;
}
inline void TransactionStarted_Request::set_allocated_id_tag(::cl_message::IdToken* id_tag) {
  delete id_tag_;
  id_tag_ = id_tag;
  if (id_tag) {
    set_has_id_tag();
  } else {
    clear_has_id_tag();
  }
}

// required int32 meter_start = 3;
inline bool TransactionStarted_Request::has_meter_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransactionStarted_Request::set_has_meter_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransactionStarted_Request::clear_has_meter_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransactionStarted_Request::clear_meter_start() {
  meter_start_ = 0;
  clear_has_meter_start();
}
inline ::google::protobuf::int32 TransactionStarted_Request::meter_start() const {
  return meter_start_;
}
inline void TransactionStarted_Request::set_meter_start(::google::protobuf::int32 value) {
  set_has_meter_start();
  meter_start_ = value;
}

// required int32 timestamp = 4;
inline bool TransactionStarted_Request::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransactionStarted_Request::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransactionStarted_Request::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransactionStarted_Request::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 TransactionStarted_Request::timestamp() const {
  return timestamp_;
}
inline void TransactionStarted_Request::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional int32 price_scheme_id = 5;
inline bool TransactionStarted_Request::has_price_scheme_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransactionStarted_Request::set_has_price_scheme_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransactionStarted_Request::clear_has_price_scheme_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransactionStarted_Request::clear_price_scheme_id() {
  price_scheme_id_ = 0;
  clear_has_price_scheme_id();
}
inline ::google::protobuf::int32 TransactionStarted_Request::price_scheme_id() const {
  return price_scheme_id_;
}
inline void TransactionStarted_Request::set_price_scheme_id(::google::protobuf::int32 value) {
  set_has_price_scheme_id();
  price_scheme_id_ = value;
}

// optional uint64 transaction_id = 6;
inline bool TransactionStarted_Request::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransactionStarted_Request::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransactionStarted_Request::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransactionStarted_Request::clear_transaction_id() {
  transaction_id_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::uint64 TransactionStarted_Request::transaction_id() const {
  return transaction_id_;
}
inline void TransactionStarted_Request::set_transaction_id(::google::protobuf::uint64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
}

// optional string pin_code = 7;
inline bool TransactionStarted_Request::has_pin_code() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransactionStarted_Request::set_has_pin_code() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransactionStarted_Request::clear_has_pin_code() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransactionStarted_Request::clear_pin_code() {
  if (pin_code_ != &::google::protobuf::internal::kEmptyString) {
    pin_code_->clear();
  }
  clear_has_pin_code();
}
inline const ::std::string& TransactionStarted_Request::pin_code() const {
  return *pin_code_;
}
inline void TransactionStarted_Request::set_pin_code(const ::std::string& value) {
  set_has_pin_code();
  if (pin_code_ == &::google::protobuf::internal::kEmptyString) {
    pin_code_ = new ::std::string;
  }
  pin_code_->assign(value);
}
inline void TransactionStarted_Request::set_pin_code(const char* value) {
  set_has_pin_code();
  if (pin_code_ == &::google::protobuf::internal::kEmptyString) {
    pin_code_ = new ::std::string;
  }
  pin_code_->assign(value);
}
inline void TransactionStarted_Request::set_pin_code(const char* value, size_t size) {
  set_has_pin_code();
  if (pin_code_ == &::google::protobuf::internal::kEmptyString) {
    pin_code_ = new ::std::string;
  }
  pin_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransactionStarted_Request::mutable_pin_code() {
  set_has_pin_code();
  if (pin_code_ == &::google::protobuf::internal::kEmptyString) {
    pin_code_ = new ::std::string;
  }
  return pin_code_;
}
inline ::std::string* TransactionStarted_Request::release_pin_code() {
  clear_has_pin_code();
  if (pin_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_code_;
    pin_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransactionStarted_Request::set_allocated_pin_code(::std::string* pin_code) {
  if (pin_code_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_code_;
  }
  if (pin_code) {
    set_has_pin_code();
    pin_code_ = pin_code;
  } else {
    clear_has_pin_code();
    pin_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string transparent = 8;
inline bool TransactionStarted_Request::has_transparent() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TransactionStarted_Request::set_has_transparent() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TransactionStarted_Request::clear_has_transparent() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TransactionStarted_Request::clear_transparent() {
  if (transparent_ != &::google::protobuf::internal::kEmptyString) {
    transparent_->clear();
  }
  clear_has_transparent();
}
inline const ::std::string& TransactionStarted_Request::transparent() const {
  return *transparent_;
}
inline void TransactionStarted_Request::set_transparent(const ::std::string& value) {
  set_has_transparent();
  if (transparent_ == &::google::protobuf::internal::kEmptyString) {
    transparent_ = new ::std::string;
  }
  transparent_->assign(value);
}
inline void TransactionStarted_Request::set_transparent(const char* value) {
  set_has_transparent();
  if (transparent_ == &::google::protobuf::internal::kEmptyString) {
    transparent_ = new ::std::string;
  }
  transparent_->assign(value);
}
inline void TransactionStarted_Request::set_transparent(const char* value, size_t size) {
  set_has_transparent();
  if (transparent_ == &::google::protobuf::internal::kEmptyString) {
    transparent_ = new ::std::string;
  }
  transparent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransactionStarted_Request::mutable_transparent() {
  set_has_transparent();
  if (transparent_ == &::google::protobuf::internal::kEmptyString) {
    transparent_ = new ::std::string;
  }
  return transparent_;
}
inline ::std::string* TransactionStarted_Request::release_transparent() {
  clear_has_transparent();
  if (transparent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transparent_;
    transparent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransactionStarted_Request::set_allocated_transparent(::std::string* transparent) {
  if (transparent_ != &::google::protobuf::internal::kEmptyString) {
    delete transparent_;
  }
  if (transparent) {
    set_has_transparent();
    transparent_ = transparent;
  } else {
    clear_has_transparent();
    transparent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TransactionStarted_Confirm

// optional uint64 transaction_id = 1;
inline bool TransactionStarted_Confirm::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionStarted_Confirm::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionStarted_Confirm::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionStarted_Confirm::clear_transaction_id() {
  transaction_id_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::uint64 TransactionStarted_Confirm::transaction_id() const {
  return transaction_id_;
}
inline void TransactionStarted_Confirm::set_transaction_id(::google::protobuf::uint64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
}

// optional .cl_message.IdTagInfo id_info = 2;
inline bool TransactionStarted_Confirm::has_id_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionStarted_Confirm::set_has_id_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionStarted_Confirm::clear_has_id_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionStarted_Confirm::clear_id_info() {
  if (id_info_ != NULL) id_info_->::cl_message::IdTagInfo::Clear();
  clear_has_id_info();
}
inline const ::cl_message::IdTagInfo& TransactionStarted_Confirm::id_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_info_ != NULL ? *id_info_ : *default_instance().id_info_;
#else
  return id_info_ != NULL ? *id_info_ : *default_instance_->id_info_;
#endif
}
inline ::cl_message::IdTagInfo* TransactionStarted_Confirm::mutable_id_info() {
  set_has_id_info();
  if (id_info_ == NULL) id_info_ = new ::cl_message::IdTagInfo;
  return id_info_;
}
inline ::cl_message::IdTagInfo* TransactionStarted_Confirm::release_id_info() {
  clear_has_id_info();
  ::cl_message::IdTagInfo* temp = id_info_;
  id_info_ = NULL;
  return temp;
}
inline void TransactionStarted_Confirm::set_allocated_id_info(::cl_message::IdTagInfo* id_info) {
  delete id_info_;
  id_info_ = id_info;
  if (id_info) {
    set_has_id_info();
  } else {
    clear_has_id_info();
  }
}

// optional int32 max_allowed_hours = 3;
inline bool TransactionStarted_Confirm::has_max_allowed_hours() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransactionStarted_Confirm::set_has_max_allowed_hours() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransactionStarted_Confirm::clear_has_max_allowed_hours() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransactionStarted_Confirm::clear_max_allowed_hours() {
  max_allowed_hours_ = 0;
  clear_has_max_allowed_hours();
}
inline ::google::protobuf::int32 TransactionStarted_Confirm::max_allowed_hours() const {
  return max_allowed_hours_;
}
inline void TransactionStarted_Confirm::set_max_allowed_hours(::google::protobuf::int32 value) {
  set_has_max_allowed_hours();
  max_allowed_hours_ = value;
}

// optional int32 max_allowed_kwh = 4;
inline bool TransactionStarted_Confirm::has_max_allowed_kwh() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransactionStarted_Confirm::set_has_max_allowed_kwh() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransactionStarted_Confirm::clear_has_max_allowed_kwh() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransactionStarted_Confirm::clear_max_allowed_kwh() {
  max_allowed_kwh_ = 0;
  clear_has_max_allowed_kwh();
}
inline ::google::protobuf::int32 TransactionStarted_Confirm::max_allowed_kwh() const {
  return max_allowed_kwh_;
}
inline void TransactionStarted_Confirm::set_max_allowed_kwh(::google::protobuf::int32 value) {
  set_has_max_allowed_kwh();
  max_allowed_kwh_ = value;
}

// -------------------------------------------------------------------

// TransactionStarted

// optional .cl_message.TransactionStarted.Request req = 1;
inline bool TransactionStarted::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionStarted::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionStarted::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionStarted::clear_req() {
  if (req_ != NULL) req_->::cl_message::TransactionStarted_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::TransactionStarted_Request& TransactionStarted::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::TransactionStarted_Request* TransactionStarted::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::TransactionStarted_Request;
  return req_;
}
inline ::cl_message::TransactionStarted_Request* TransactionStarted::release_req() {
  clear_has_req();
  ::cl_message::TransactionStarted_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void TransactionStarted::set_allocated_req(::cl_message::TransactionStarted_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.TransactionStarted.Confirm conf = 2;
inline bool TransactionStarted::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionStarted::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionStarted::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionStarted::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::TransactionStarted_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::TransactionStarted_Confirm& TransactionStarted::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::TransactionStarted_Confirm* TransactionStarted::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::TransactionStarted_Confirm;
  return conf_;
}
inline ::cl_message::TransactionStarted_Confirm* TransactionStarted::release_conf() {
  clear_has_conf();
  ::cl_message::TransactionStarted_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void TransactionStarted::set_allocated_conf(::cl_message::TransactionStarted_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// TransactionStopped_Request

// optional uint64 transaction_id = 1;
inline bool TransactionStopped_Request::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionStopped_Request::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionStopped_Request::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionStopped_Request::clear_transaction_id() {
  transaction_id_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::uint64 TransactionStopped_Request::transaction_id() const {
  return transaction_id_;
}
inline void TransactionStopped_Request::set_transaction_id(::google::protobuf::uint64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
}

// required .cl_message.IdToken id_tag = 2;
inline bool TransactionStopped_Request::has_id_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionStopped_Request::set_has_id_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionStopped_Request::clear_has_id_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionStopped_Request::clear_id_tag() {
  if (id_tag_ != NULL) id_tag_->::cl_message::IdToken::Clear();
  clear_has_id_tag();
}
inline const ::cl_message::IdToken& TransactionStopped_Request::id_tag() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_tag_ != NULL ? *id_tag_ : *default_instance().id_tag_;
#else
  return id_tag_ != NULL ? *id_tag_ : *default_instance_->id_tag_;
#endif
}
inline ::cl_message::IdToken* TransactionStopped_Request::mutable_id_tag() {
  set_has_id_tag();
  if (id_tag_ == NULL) id_tag_ = new ::cl_message::IdToken;
  return id_tag_;
}
inline ::cl_message::IdToken* TransactionStopped_Request::release_id_tag() {
  clear_has_id_tag();
  ::cl_message::IdToken* temp = id_tag_;
  id_tag_ = NULL;
  return temp;
}
inline void TransactionStopped_Request::set_allocated_id_tag(::cl_message::IdToken* id_tag) {
  delete id_tag_;
  id_tag_ = id_tag;
  if (id_tag) {
    set_has_id_tag();
  } else {
    clear_has_id_tag();
  }
}

// required int32 meter_stop = 3;
inline bool TransactionStopped_Request::has_meter_stop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransactionStopped_Request::set_has_meter_stop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransactionStopped_Request::clear_has_meter_stop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransactionStopped_Request::clear_meter_stop() {
  meter_stop_ = 0;
  clear_has_meter_stop();
}
inline ::google::protobuf::int32 TransactionStopped_Request::meter_stop() const {
  return meter_stop_;
}
inline void TransactionStopped_Request::set_meter_stop(::google::protobuf::int32 value) {
  set_has_meter_stop();
  meter_stop_ = value;
}

// required int32 timestamp = 4;
inline bool TransactionStopped_Request::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransactionStopped_Request::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransactionStopped_Request::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransactionStopped_Request::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 TransactionStopped_Request::timestamp() const {
  return timestamp_;
}
inline void TransactionStopped_Request::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required int32 stop_reason = 5;
inline bool TransactionStopped_Request::has_stop_reason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransactionStopped_Request::set_has_stop_reason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransactionStopped_Request::clear_has_stop_reason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransactionStopped_Request::clear_stop_reason() {
  stop_reason_ = 0;
  clear_has_stop_reason();
}
inline ::google::protobuf::int32 TransactionStopped_Request::stop_reason() const {
  return stop_reason_;
}
inline void TransactionStopped_Request::set_stop_reason(::google::protobuf::int32 value) {
  set_has_stop_reason();
  stop_reason_ = value;
}

// optional int32 time_spent_charging = 6;
inline bool TransactionStopped_Request::has_time_spent_charging() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransactionStopped_Request::set_has_time_spent_charging() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransactionStopped_Request::clear_has_time_spent_charging() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransactionStopped_Request::clear_time_spent_charging() {
  time_spent_charging_ = 0;
  clear_has_time_spent_charging();
}
inline ::google::protobuf::int32 TransactionStopped_Request::time_spent_charging() const {
  return time_spent_charging_;
}
inline void TransactionStopped_Request::set_time_spent_charging(::google::protobuf::int32 value) {
  set_has_time_spent_charging();
  time_spent_charging_ = value;
}

// -------------------------------------------------------------------

// TransactionStopped_Confirm

// optional int32 total_cost = 1;
inline bool TransactionStopped_Confirm::has_total_cost() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionStopped_Confirm::set_has_total_cost() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionStopped_Confirm::clear_has_total_cost() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionStopped_Confirm::clear_total_cost() {
  total_cost_ = 0;
  clear_has_total_cost();
}
inline ::google::protobuf::int32 TransactionStopped_Confirm::total_cost() const {
  return total_cost_;
}
inline void TransactionStopped_Confirm::set_total_cost(::google::protobuf::int32 value) {
  set_has_total_cost();
  total_cost_ = value;
}

// -------------------------------------------------------------------

// TransactionStopped

// optional .cl_message.TransactionStopped.Request req = 1;
inline bool TransactionStopped::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionStopped::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionStopped::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionStopped::clear_req() {
  if (req_ != NULL) req_->::cl_message::TransactionStopped_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::TransactionStopped_Request& TransactionStopped::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::TransactionStopped_Request* TransactionStopped::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::TransactionStopped_Request;
  return req_;
}
inline ::cl_message::TransactionStopped_Request* TransactionStopped::release_req() {
  clear_has_req();
  ::cl_message::TransactionStopped_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void TransactionStopped::set_allocated_req(::cl_message::TransactionStopped_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.TransactionStopped.Confirm conf = 2;
inline bool TransactionStopped::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionStopped::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionStopped::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionStopped::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::TransactionStopped_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::TransactionStopped_Confirm& TransactionStopped::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::TransactionStopped_Confirm* TransactionStopped::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::TransactionStopped_Confirm;
  return conf_;
}
inline ::cl_message::TransactionStopped_Confirm* TransactionStopped::release_conf() {
  clear_has_conf();
  ::cl_message::TransactionStopped_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void TransactionStopped::set_allocated_conf(::cl_message::TransactionStopped_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// TransactionRecords_Request

// optional int32 checksum = 1;
inline bool TransactionRecords_Request::has_checksum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionRecords_Request::set_has_checksum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionRecords_Request::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionRecords_Request::clear_checksum() {
  checksum_ = 0;
  clear_has_checksum();
}
inline ::google::protobuf::int32 TransactionRecords_Request::checksum() const {
  return checksum_;
}
inline void TransactionRecords_Request::set_checksum(::google::protobuf::int32 value) {
  set_has_checksum();
  checksum_ = value;
}

// repeated .cl_message.Transactions records = 2;
inline int TransactionRecords_Request::records_size() const {
  return records_.size();
}
inline void TransactionRecords_Request::clear_records() {
  records_.Clear();
}
inline const ::cl_message::Transactions& TransactionRecords_Request::records(int index) const {
  return records_.Get(index);
}
inline ::cl_message::Transactions* TransactionRecords_Request::mutable_records(int index) {
  return records_.Mutable(index);
}
inline ::cl_message::Transactions* TransactionRecords_Request::add_records() {
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cl_message::Transactions >&
TransactionRecords_Request::records() const {
  return records_;
}
inline ::google::protobuf::RepeatedPtrField< ::cl_message::Transactions >*
TransactionRecords_Request::mutable_records() {
  return &records_;
}

// -------------------------------------------------------------------

// TransactionRecords_Confirm

// required int32 status = 1;
inline bool TransactionRecords_Confirm::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionRecords_Confirm::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionRecords_Confirm::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionRecords_Confirm::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 TransactionRecords_Confirm::status() const {
  return status_;
}
inline void TransactionRecords_Confirm::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// repeated uint64 transaction_id = 2;
inline int TransactionRecords_Confirm::transaction_id_size() const {
  return transaction_id_.size();
}
inline void TransactionRecords_Confirm::clear_transaction_id() {
  transaction_id_.Clear();
}
inline ::google::protobuf::uint64 TransactionRecords_Confirm::transaction_id(int index) const {
  return transaction_id_.Get(index);
}
inline void TransactionRecords_Confirm::set_transaction_id(int index, ::google::protobuf::uint64 value) {
  transaction_id_.Set(index, value);
}
inline void TransactionRecords_Confirm::add_transaction_id(::google::protobuf::uint64 value) {
  transaction_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
TransactionRecords_Confirm::transaction_id() const {
  return transaction_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
TransactionRecords_Confirm::mutable_transaction_id() {
  return &transaction_id_;
}

// -------------------------------------------------------------------

// TransactionRecords

// optional .cl_message.TransactionRecords.Request req = 1;
inline bool TransactionRecords::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionRecords::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionRecords::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionRecords::clear_req() {
  if (req_ != NULL) req_->::cl_message::TransactionRecords_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::TransactionRecords_Request& TransactionRecords::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::TransactionRecords_Request* TransactionRecords::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::TransactionRecords_Request;
  return req_;
}
inline ::cl_message::TransactionRecords_Request* TransactionRecords::release_req() {
  clear_has_req();
  ::cl_message::TransactionRecords_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void TransactionRecords::set_allocated_req(::cl_message::TransactionRecords_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.TransactionRecords.Confirm conf = 2;
inline bool TransactionRecords::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionRecords::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionRecords::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionRecords::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::TransactionRecords_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::TransactionRecords_Confirm& TransactionRecords::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::TransactionRecords_Confirm* TransactionRecords::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::TransactionRecords_Confirm;
  return conf_;
}
inline ::cl_message::TransactionRecords_Confirm* TransactionRecords::release_conf() {
  clear_has_conf();
  ::cl_message::TransactionRecords_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void TransactionRecords::set_allocated_conf(::cl_message::TransactionRecords_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// MeasureValue

// optional int32 Electricity = 1;
inline bool MeasureValue::has_electricity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MeasureValue::set_has_electricity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MeasureValue::clear_has_electricity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MeasureValue::clear_electricity() {
  electricity_ = 0;
  clear_has_electricity();
}
inline ::google::protobuf::int32 MeasureValue::electricity() const {
  return electricity_;
}
inline void MeasureValue::set_electricity(::google::protobuf::int32 value) {
  set_has_electricity();
  electricity_ = value;
}

// optional int32 Power = 2;
inline bool MeasureValue::has_power() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MeasureValue::set_has_power() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MeasureValue::clear_has_power() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MeasureValue::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 MeasureValue::power() const {
  return power_;
}
inline void MeasureValue::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}

// optional int32 CurrentA = 3;
inline bool MeasureValue::has_currenta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MeasureValue::set_has_currenta() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MeasureValue::clear_has_currenta() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MeasureValue::clear_currenta() {
  currenta_ = 0;
  clear_has_currenta();
}
inline ::google::protobuf::int32 MeasureValue::currenta() const {
  return currenta_;
}
inline void MeasureValue::set_currenta(::google::protobuf::int32 value) {
  set_has_currenta();
  currenta_ = value;
}

// optional int32 CurrentB = 4;
inline bool MeasureValue::has_currentb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MeasureValue::set_has_currentb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MeasureValue::clear_has_currentb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MeasureValue::clear_currentb() {
  currentb_ = 0;
  clear_has_currentb();
}
inline ::google::protobuf::int32 MeasureValue::currentb() const {
  return currentb_;
}
inline void MeasureValue::set_currentb(::google::protobuf::int32 value) {
  set_has_currentb();
  currentb_ = value;
}

// optional int32 CurrentC = 5;
inline bool MeasureValue::has_currentc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MeasureValue::set_has_currentc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MeasureValue::clear_has_currentc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MeasureValue::clear_currentc() {
  currentc_ = 0;
  clear_has_currentc();
}
inline ::google::protobuf::int32 MeasureValue::currentc() const {
  return currentc_;
}
inline void MeasureValue::set_currentc(::google::protobuf::int32 value) {
  set_has_currentc();
  currentc_ = value;
}

// optional int32 VoltageA = 6;
inline bool MeasureValue::has_voltagea() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MeasureValue::set_has_voltagea() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MeasureValue::clear_has_voltagea() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MeasureValue::clear_voltagea() {
  voltagea_ = 0;
  clear_has_voltagea();
}
inline ::google::protobuf::int32 MeasureValue::voltagea() const {
  return voltagea_;
}
inline void MeasureValue::set_voltagea(::google::protobuf::int32 value) {
  set_has_voltagea();
  voltagea_ = value;
}

// optional int32 VoltageB = 7;
inline bool MeasureValue::has_voltageb() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MeasureValue::set_has_voltageb() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MeasureValue::clear_has_voltageb() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MeasureValue::clear_voltageb() {
  voltageb_ = 0;
  clear_has_voltageb();
}
inline ::google::protobuf::int32 MeasureValue::voltageb() const {
  return voltageb_;
}
inline void MeasureValue::set_voltageb(::google::protobuf::int32 value) {
  set_has_voltageb();
  voltageb_ = value;
}

// optional int32 VoltageC = 8;
inline bool MeasureValue::has_voltagec() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MeasureValue::set_has_voltagec() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MeasureValue::clear_has_voltagec() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MeasureValue::clear_voltagec() {
  voltagec_ = 0;
  clear_has_voltagec();
}
inline ::google::protobuf::int32 MeasureValue::voltagec() const {
  return voltagec_;
}
inline void MeasureValue::set_voltagec(::google::protobuf::int32 value) {
  set_has_voltagec();
  voltagec_ = value;
}

// -------------------------------------------------------------------

// Measure_Request

// optional int32 connector_id = 1;
inline bool Measure_Request::has_connector_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Measure_Request::set_has_connector_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Measure_Request::clear_has_connector_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Measure_Request::clear_connector_id() {
  connector_id_ = 0;
  clear_has_connector_id();
}
inline ::google::protobuf::int32 Measure_Request::connector_id() const {
  return connector_id_;
}
inline void Measure_Request::set_connector_id(::google::protobuf::int32 value) {
  set_has_connector_id();
  connector_id_ = value;
}

// optional uint64 transaction_id = 2;
inline bool Measure_Request::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Measure_Request::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Measure_Request::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Measure_Request::clear_transaction_id() {
  transaction_id_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::uint64 Measure_Request::transaction_id() const {
  return transaction_id_;
}
inline void Measure_Request::set_transaction_id(::google::protobuf::uint64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
}

// required .cl_message.MeasureValue value = 3;
inline bool Measure_Request::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Measure_Request::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Measure_Request::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Measure_Request::clear_value() {
  if (value_ != NULL) value_->::cl_message::MeasureValue::Clear();
  clear_has_value();
}
inline const ::cl_message::MeasureValue& Measure_Request::value() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return value_ != NULL ? *value_ : *default_instance().value_;
#else
  return value_ != NULL ? *value_ : *default_instance_->value_;
#endif
}
inline ::cl_message::MeasureValue* Measure_Request::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::cl_message::MeasureValue;
  return value_;
}
inline ::cl_message::MeasureValue* Measure_Request::release_value() {
  clear_has_value();
  ::cl_message::MeasureValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline void Measure_Request::set_allocated_value(::cl_message::MeasureValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// -------------------------------------------------------------------

// Measure_Confirm

// -------------------------------------------------------------------

// Measure

// optional .cl_message.Measure.Request req = 1;
inline bool Measure::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Measure::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Measure::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Measure::clear_req() {
  if (req_ != NULL) req_->::cl_message::Measure_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::Measure_Request& Measure::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::Measure_Request* Measure::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::Measure_Request;
  return req_;
}
inline ::cl_message::Measure_Request* Measure::release_req() {
  clear_has_req();
  ::cl_message::Measure_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void Measure::set_allocated_req(::cl_message::Measure_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.Measure.Confirm conf = 2;
inline bool Measure::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Measure::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Measure::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Measure::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::Measure_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::Measure_Confirm& Measure::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::Measure_Confirm* Measure::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::Measure_Confirm;
  return conf_;
}
inline ::cl_message::Measure_Confirm* Measure::release_conf() {
  clear_has_conf();
  ::cl_message::Measure_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void Measure::set_allocated_conf(::cl_message::Measure_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// BootNotification_Request

// optional string version = 1;
inline bool BootNotification_Request::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BootNotification_Request::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BootNotification_Request::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BootNotification_Request::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& BootNotification_Request::version() const {
  return *version_;
}
inline void BootNotification_Request::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void BootNotification_Request::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void BootNotification_Request::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BootNotification_Request::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* BootNotification_Request::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BootNotification_Request::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cp_version = 2;
inline bool BootNotification_Request::has_cp_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BootNotification_Request::set_has_cp_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BootNotification_Request::clear_has_cp_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BootNotification_Request::clear_cp_version() {
  if (cp_version_ != &::google::protobuf::internal::kEmptyString) {
    cp_version_->clear();
  }
  clear_has_cp_version();
}
inline const ::std::string& BootNotification_Request::cp_version() const {
  return *cp_version_;
}
inline void BootNotification_Request::set_cp_version(const ::std::string& value) {
  set_has_cp_version();
  if (cp_version_ == &::google::protobuf::internal::kEmptyString) {
    cp_version_ = new ::std::string;
  }
  cp_version_->assign(value);
}
inline void BootNotification_Request::set_cp_version(const char* value) {
  set_has_cp_version();
  if (cp_version_ == &::google::protobuf::internal::kEmptyString) {
    cp_version_ = new ::std::string;
  }
  cp_version_->assign(value);
}
inline void BootNotification_Request::set_cp_version(const char* value, size_t size) {
  set_has_cp_version();
  if (cp_version_ == &::google::protobuf::internal::kEmptyString) {
    cp_version_ = new ::std::string;
  }
  cp_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BootNotification_Request::mutable_cp_version() {
  set_has_cp_version();
  if (cp_version_ == &::google::protobuf::internal::kEmptyString) {
    cp_version_ = new ::std::string;
  }
  return cp_version_;
}
inline ::std::string* BootNotification_Request::release_cp_version() {
  clear_has_cp_version();
  if (cp_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cp_version_;
    cp_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BootNotification_Request::set_allocated_cp_version(::std::string* cp_version) {
  if (cp_version_ != &::google::protobuf::internal::kEmptyString) {
    delete cp_version_;
  }
  if (cp_version) {
    set_has_cp_version();
    cp_version_ = cp_version;
  } else {
    clear_has_cp_version();
    cp_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string client_version = 3;
inline bool BootNotification_Request::has_client_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BootNotification_Request::set_has_client_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BootNotification_Request::clear_has_client_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BootNotification_Request::clear_client_version() {
  if (client_version_ != &::google::protobuf::internal::kEmptyString) {
    client_version_->clear();
  }
  clear_has_client_version();
}
inline const ::std::string& BootNotification_Request::client_version() const {
  return *client_version_;
}
inline void BootNotification_Request::set_client_version(const ::std::string& value) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(value);
}
inline void BootNotification_Request::set_client_version(const char* value) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(value);
}
inline void BootNotification_Request::set_client_version(const char* value, size_t size) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BootNotification_Request::mutable_client_version() {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    client_version_ = new ::std::string;
  }
  return client_version_;
}
inline ::std::string* BootNotification_Request::release_client_version() {
  clear_has_client_version();
  if (client_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_version_;
    client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BootNotification_Request::set_allocated_client_version(::std::string* client_version) {
  if (client_version_ != &::google::protobuf::internal::kEmptyString) {
    delete client_version_;
  }
  if (client_version) {
    set_has_client_version();
    client_version_ = client_version;
  } else {
    clear_has_client_version();
    client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string firmware_version = 4;
inline bool BootNotification_Request::has_firmware_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BootNotification_Request::set_has_firmware_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BootNotification_Request::clear_has_firmware_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BootNotification_Request::clear_firmware_version() {
  if (firmware_version_ != &::google::protobuf::internal::kEmptyString) {
    firmware_version_->clear();
  }
  clear_has_firmware_version();
}
inline const ::std::string& BootNotification_Request::firmware_version() const {
  return *firmware_version_;
}
inline void BootNotification_Request::set_firmware_version(const ::std::string& value) {
  set_has_firmware_version();
  if (firmware_version_ == &::google::protobuf::internal::kEmptyString) {
    firmware_version_ = new ::std::string;
  }
  firmware_version_->assign(value);
}
inline void BootNotification_Request::set_firmware_version(const char* value) {
  set_has_firmware_version();
  if (firmware_version_ == &::google::protobuf::internal::kEmptyString) {
    firmware_version_ = new ::std::string;
  }
  firmware_version_->assign(value);
}
inline void BootNotification_Request::set_firmware_version(const char* value, size_t size) {
  set_has_firmware_version();
  if (firmware_version_ == &::google::protobuf::internal::kEmptyString) {
    firmware_version_ = new ::std::string;
  }
  firmware_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BootNotification_Request::mutable_firmware_version() {
  set_has_firmware_version();
  if (firmware_version_ == &::google::protobuf::internal::kEmptyString) {
    firmware_version_ = new ::std::string;
  }
  return firmware_version_;
}
inline ::std::string* BootNotification_Request::release_firmware_version() {
  clear_has_firmware_version();
  if (firmware_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = firmware_version_;
    firmware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BootNotification_Request::set_allocated_firmware_version(::std::string* firmware_version) {
  if (firmware_version_ != &::google::protobuf::internal::kEmptyString) {
    delete firmware_version_;
  }
  if (firmware_version) {
    set_has_firmware_version();
    firmware_version_ = firmware_version;
  } else {
    clear_has_firmware_version();
    firmware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BootNotification_Confirm

// optional int32 timestamp = 1;
inline bool BootNotification_Confirm::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BootNotification_Confirm::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BootNotification_Confirm::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BootNotification_Confirm::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 BootNotification_Confirm::timestamp() const {
  return timestamp_;
}
inline void BootNotification_Confirm::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional int32 hb_interval = 2;
inline bool BootNotification_Confirm::has_hb_interval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BootNotification_Confirm::set_has_hb_interval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BootNotification_Confirm::clear_has_hb_interval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BootNotification_Confirm::clear_hb_interval() {
  hb_interval_ = 0;
  clear_has_hb_interval();
}
inline ::google::protobuf::int32 BootNotification_Confirm::hb_interval() const {
  return hb_interval_;
}
inline void BootNotification_Confirm::set_hb_interval(::google::protobuf::int32 value) {
  set_has_hb_interval();
  hb_interval_ = value;
}

// optional int32 meter_idle_interval = 3;
inline bool BootNotification_Confirm::has_meter_idle_interval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BootNotification_Confirm::set_has_meter_idle_interval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BootNotification_Confirm::clear_has_meter_idle_interval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BootNotification_Confirm::clear_meter_idle_interval() {
  meter_idle_interval_ = 0;
  clear_has_meter_idle_interval();
}
inline ::google::protobuf::int32 BootNotification_Confirm::meter_idle_interval() const {
  return meter_idle_interval_;
}
inline void BootNotification_Confirm::set_meter_idle_interval(::google::protobuf::int32 value) {
  set_has_meter_idle_interval();
  meter_idle_interval_ = value;
}

// optional int32 meter_charge_interval = 4;
inline bool BootNotification_Confirm::has_meter_charge_interval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BootNotification_Confirm::set_has_meter_charge_interval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BootNotification_Confirm::clear_has_meter_charge_interval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BootNotification_Confirm::clear_meter_charge_interval() {
  meter_charge_interval_ = 0;
  clear_has_meter_charge_interval();
}
inline ::google::protobuf::int32 BootNotification_Confirm::meter_charge_interval() const {
  return meter_charge_interval_;
}
inline void BootNotification_Confirm::set_meter_charge_interval(::google::protobuf::int32 value) {
  set_has_meter_charge_interval();
  meter_charge_interval_ = value;
}

// -------------------------------------------------------------------

// BootNotification

// optional .cl_message.BootNotification.Request req = 1;
inline bool BootNotification::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BootNotification::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BootNotification::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BootNotification::clear_req() {
  if (req_ != NULL) req_->::cl_message::BootNotification_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::BootNotification_Request& BootNotification::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::BootNotification_Request* BootNotification::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::BootNotification_Request;
  return req_;
}
inline ::cl_message::BootNotification_Request* BootNotification::release_req() {
  clear_has_req();
  ::cl_message::BootNotification_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void BootNotification::set_allocated_req(::cl_message::BootNotification_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.BootNotification.Confirm conf = 2;
inline bool BootNotification::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BootNotification::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BootNotification::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BootNotification::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::BootNotification_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::BootNotification_Confirm& BootNotification::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::BootNotification_Confirm* BootNotification::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::BootNotification_Confirm;
  return conf_;
}
inline ::cl_message::BootNotification_Confirm* BootNotification::release_conf() {
  clear_has_conf();
  ::cl_message::BootNotification_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void BootNotification::set_allocated_conf(::cl_message::BootNotification_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// StatusNotification

// optional int32 connector_id = 1;
inline bool StatusNotification::has_connector_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusNotification::set_has_connector_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusNotification::clear_has_connector_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusNotification::clear_connector_id() {
  connector_id_ = 0;
  clear_has_connector_id();
}
inline ::google::protobuf::int32 StatusNotification::connector_id() const {
  return connector_id_;
}
inline void StatusNotification::set_connector_id(::google::protobuf::int32 value) {
  set_has_connector_id();
  connector_id_ = value;
}

// required .cl_message.ChargerStatus status = 2;
inline bool StatusNotification::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusNotification::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusNotification::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusNotification::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::cl_message::ChargerStatus StatusNotification::status() const {
  return static_cast< ::cl_message::ChargerStatus >(status_);
}
inline void StatusNotification::set_status(::cl_message::ChargerStatus value) {
  assert(::cl_message::ChargerStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// FirmwareStatusNotifcation

// required .cl_message.FirmwareStatus status = 1;
inline bool FirmwareStatusNotifcation::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FirmwareStatusNotifcation::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FirmwareStatusNotifcation::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FirmwareStatusNotifcation::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::cl_message::FirmwareStatus FirmwareStatusNotifcation::status() const {
  return static_cast< ::cl_message::FirmwareStatus >(status_);
}
inline void FirmwareStatusNotifcation::set_status(::cl_message::FirmwareStatus value) {
  assert(::cl_message::FirmwareStatus_IsValid(value));
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// SensorStatusNotification

// optional int32 deviceid = 1;
inline bool SensorStatusNotification::has_deviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorStatusNotification::set_has_deviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorStatusNotification::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorStatusNotification::clear_deviceid() {
  deviceid_ = 0;
  clear_has_deviceid();
}
inline ::google::protobuf::int32 SensorStatusNotification::deviceid() const {
  return deviceid_;
}
inline void SensorStatusNotification::set_deviceid(::google::protobuf::int32 value) {
  set_has_deviceid();
  deviceid_ = value;
}

// required int32 id = 2;
inline bool SensorStatusNotification::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorStatusNotification::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorStatusNotification::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorStatusNotification::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SensorStatusNotification::id() const {
  return id_;
}
inline void SensorStatusNotification::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 type = 3;
inline bool SensorStatusNotification::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorStatusNotification::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorStatusNotification::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorStatusNotification::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SensorStatusNotification::type() const {
  return type_;
}
inline void SensorStatusNotification::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 status = 4;
inline bool SensorStatusNotification::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorStatusNotification::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorStatusNotification::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorStatusNotification::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 SensorStatusNotification::status() const {
  return status_;
}
inline void SensorStatusNotification::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional int32 capacity = 5;
inline bool SensorStatusNotification::has_capacity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorStatusNotification::set_has_capacity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorStatusNotification::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorStatusNotification::clear_capacity() {
  capacity_ = 0;
  clear_has_capacity();
}
inline ::google::protobuf::int32 SensorStatusNotification::capacity() const {
  return capacity_;
}
inline void SensorStatusNotification::set_capacity(::google::protobuf::int32 value) {
  set_has_capacity();
  capacity_ = value;
}

// -------------------------------------------------------------------

// Consumption

// required int32 tariffid = 1;
inline bool Consumption::has_tariffid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Consumption::set_has_tariffid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Consumption::clear_has_tariffid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Consumption::clear_tariffid() {
  tariffid_ = 0;
  clear_has_tariffid();
}
inline ::google::protobuf::int32 Consumption::tariffid() const {
  return tariffid_;
}
inline void Consumption::set_tariffid(::google::protobuf::int32 value) {
  set_has_tariffid();
  tariffid_ = value;
}

// required int32 tariff_qty = 2;
inline bool Consumption::has_tariff_qty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Consumption::set_has_tariff_qty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Consumption::clear_has_tariff_qty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Consumption::clear_tariff_qty() {
  tariff_qty_ = 0;
  clear_has_tariff_qty();
}
inline ::google::protobuf::int32 Consumption::tariff_qty() const {
  return tariff_qty_;
}
inline void Consumption::set_tariff_qty(::google::protobuf::int32 value) {
  set_has_tariff_qty();
  tariff_qty_ = value;
}

// -------------------------------------------------------------------

// GetCost_Request

// required int32 price_scheme_id = 1;
inline bool GetCost_Request::has_price_scheme_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCost_Request::set_has_price_scheme_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCost_Request::clear_has_price_scheme_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCost_Request::clear_price_scheme_id() {
  price_scheme_id_ = 0;
  clear_has_price_scheme_id();
}
inline ::google::protobuf::int32 GetCost_Request::price_scheme_id() const {
  return price_scheme_id_;
}
inline void GetCost_Request::set_price_scheme_id(::google::protobuf::int32 value) {
  set_has_price_scheme_id();
  price_scheme_id_ = value;
}

// repeated .cl_message.Consumption local_consumption = 2;
inline int GetCost_Request::local_consumption_size() const {
  return local_consumption_.size();
}
inline void GetCost_Request::clear_local_consumption() {
  local_consumption_.Clear();
}
inline const ::cl_message::Consumption& GetCost_Request::local_consumption(int index) const {
  return local_consumption_.Get(index);
}
inline ::cl_message::Consumption* GetCost_Request::mutable_local_consumption(int index) {
  return local_consumption_.Mutable(index);
}
inline ::cl_message::Consumption* GetCost_Request::add_local_consumption() {
  return local_consumption_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cl_message::Consumption >&
GetCost_Request::local_consumption() const {
  return local_consumption_;
}
inline ::google::protobuf::RepeatedPtrField< ::cl_message::Consumption >*
GetCost_Request::mutable_local_consumption() {
  return &local_consumption_;
}

// -------------------------------------------------------------------

// GetCost_Confirm

// required int32 price_scheme_id = 1;
inline bool GetCost_Confirm::has_price_scheme_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCost_Confirm::set_has_price_scheme_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCost_Confirm::clear_has_price_scheme_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCost_Confirm::clear_price_scheme_id() {
  price_scheme_id_ = 0;
  clear_has_price_scheme_id();
}
inline ::google::protobuf::int32 GetCost_Confirm::price_scheme_id() const {
  return price_scheme_id_;
}
inline void GetCost_Confirm::set_price_scheme_id(::google::protobuf::int32 value) {
  set_has_price_scheme_id();
  price_scheme_id_ = value;
}

// required int32 total_cost = 2;
inline bool GetCost_Confirm::has_total_cost() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetCost_Confirm::set_has_total_cost() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetCost_Confirm::clear_has_total_cost() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetCost_Confirm::clear_total_cost() {
  total_cost_ = 0;
  clear_has_total_cost();
}
inline ::google::protobuf::int32 GetCost_Confirm::total_cost() const {
  return total_cost_;
}
inline void GetCost_Confirm::set_total_cost(::google::protobuf::int32 value) {
  set_has_total_cost();
  total_cost_ = value;
}

// repeated .cl_message.Consumption consum = 3;
inline int GetCost_Confirm::consum_size() const {
  return consum_.size();
}
inline void GetCost_Confirm::clear_consum() {
  consum_.Clear();
}
inline const ::cl_message::Consumption& GetCost_Confirm::consum(int index) const {
  return consum_.Get(index);
}
inline ::cl_message::Consumption* GetCost_Confirm::mutable_consum(int index) {
  return consum_.Mutable(index);
}
inline ::cl_message::Consumption* GetCost_Confirm::add_consum() {
  return consum_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::cl_message::Consumption >&
GetCost_Confirm::consum() const {
  return consum_;
}
inline ::google::protobuf::RepeatedPtrField< ::cl_message::Consumption >*
GetCost_Confirm::mutable_consum() {
  return &consum_;
}

// -------------------------------------------------------------------

// GetCost

// optional .cl_message.GetCost.Request req = 1;
inline bool GetCost::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCost::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCost::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCost::clear_req() {
  if (req_ != NULL) req_->::cl_message::GetCost_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::GetCost_Request& GetCost::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::GetCost_Request* GetCost::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::GetCost_Request;
  return req_;
}
inline ::cl_message::GetCost_Request* GetCost::release_req() {
  clear_has_req();
  ::cl_message::GetCost_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void GetCost::set_allocated_req(::cl_message::GetCost_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.GetCost.Confirm conf = 2;
inline bool GetCost::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetCost::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetCost::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetCost::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::GetCost_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::GetCost_Confirm& GetCost::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::GetCost_Confirm* GetCost::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::GetCost_Confirm;
  return conf_;
}
inline ::cl_message::GetCost_Confirm* GetCost::release_conf() {
  clear_has_conf();
  ::cl_message::GetCost_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void GetCost::set_allocated_conf(::cl_message::GetCost_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// LoginGW_Request

// required string deviceid = 1;
inline bool LoginGW_Request::has_deviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginGW_Request::set_has_deviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginGW_Request::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginGW_Request::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& LoginGW_Request::deviceid() const {
  return *deviceid_;
}
inline void LoginGW_Request::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void LoginGW_Request::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void LoginGW_Request::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginGW_Request::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* LoginGW_Request::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginGW_Request::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginGW_Confirm

// required bool accept = 1;
inline bool LoginGW_Confirm::has_accept() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginGW_Confirm::set_has_accept() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginGW_Confirm::clear_has_accept() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginGW_Confirm::clear_accept() {
  accept_ = false;
  clear_has_accept();
}
inline bool LoginGW_Confirm::accept() const {
  return accept_;
}
inline void LoginGW_Confirm::set_accept(bool value) {
  set_has_accept();
  accept_ = value;
}

// optional int32 evse_id = 2;
inline bool LoginGW_Confirm::has_evse_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginGW_Confirm::set_has_evse_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginGW_Confirm::clear_has_evse_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginGW_Confirm::clear_evse_id() {
  evse_id_ = 0;
  clear_has_evse_id();
}
inline ::google::protobuf::int32 LoginGW_Confirm::evse_id() const {
  return evse_id_;
}
inline void LoginGW_Confirm::set_evse_id(::google::protobuf::int32 value) {
  set_has_evse_id();
  evse_id_ = value;
}

// optional string cpid = 3;
inline bool LoginGW_Confirm::has_cpid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginGW_Confirm::set_has_cpid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginGW_Confirm::clear_has_cpid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginGW_Confirm::clear_cpid() {
  if (cpid_ != &::google::protobuf::internal::kEmptyString) {
    cpid_->clear();
  }
  clear_has_cpid();
}
inline const ::std::string& LoginGW_Confirm::cpid() const {
  return *cpid_;
}
inline void LoginGW_Confirm::set_cpid(const ::std::string& value) {
  set_has_cpid();
  if (cpid_ == &::google::protobuf::internal::kEmptyString) {
    cpid_ = new ::std::string;
  }
  cpid_->assign(value);
}
inline void LoginGW_Confirm::set_cpid(const char* value) {
  set_has_cpid();
  if (cpid_ == &::google::protobuf::internal::kEmptyString) {
    cpid_ = new ::std::string;
  }
  cpid_->assign(value);
}
inline void LoginGW_Confirm::set_cpid(const char* value, size_t size) {
  set_has_cpid();
  if (cpid_ == &::google::protobuf::internal::kEmptyString) {
    cpid_ = new ::std::string;
  }
  cpid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginGW_Confirm::mutable_cpid() {
  set_has_cpid();
  if (cpid_ == &::google::protobuf::internal::kEmptyString) {
    cpid_ = new ::std::string;
  }
  return cpid_;
}
inline ::std::string* LoginGW_Confirm::release_cpid() {
  clear_has_cpid();
  if (cpid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cpid_;
    cpid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginGW_Confirm::set_allocated_cpid(::std::string* cpid) {
  if (cpid_ != &::google::protobuf::internal::kEmptyString) {
    delete cpid_;
  }
  if (cpid) {
    set_has_cpid();
    cpid_ = cpid;
  } else {
    clear_has_cpid();
    cpid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 4;
inline bool LoginGW_Confirm::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginGW_Confirm::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginGW_Confirm::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginGW_Confirm::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& LoginGW_Confirm::version() const {
  return *version_;
}
inline void LoginGW_Confirm::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginGW_Confirm::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void LoginGW_Confirm::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginGW_Confirm::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* LoginGW_Confirm::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginGW_Confirm::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isonline = 5;
inline bool LoginGW_Confirm::has_isonline() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginGW_Confirm::set_has_isonline() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginGW_Confirm::clear_has_isonline() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginGW_Confirm::clear_isonline() {
  isonline_ = false;
  clear_has_isonline();
}
inline bool LoginGW_Confirm::isonline() const {
  return isonline_;
}
inline void LoginGW_Confirm::set_isonline(bool value) {
  set_has_isonline();
  isonline_ = value;
}

// optional int32 timestamp = 6;
inline bool LoginGW_Confirm::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginGW_Confirm::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginGW_Confirm::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginGW_Confirm::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 LoginGW_Confirm::timestamp() const {
  return timestamp_;
}
inline void LoginGW_Confirm::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// LoginGW

// optional .cl_message.LoginGW.Request req = 1;
inline bool LoginGW::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginGW::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginGW::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginGW::clear_req() {
  if (req_ != NULL) req_->::cl_message::LoginGW_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::LoginGW_Request& LoginGW::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::LoginGW_Request* LoginGW::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::LoginGW_Request;
  return req_;
}
inline ::cl_message::LoginGW_Request* LoginGW::release_req() {
  clear_has_req();
  ::cl_message::LoginGW_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void LoginGW::set_allocated_req(::cl_message::LoginGW_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.LoginGW.Confirm conf = 2;
inline bool LoginGW::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginGW::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginGW::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginGW::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::LoginGW_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::LoginGW_Confirm& LoginGW::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::LoginGW_Confirm* LoginGW::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::LoginGW_Confirm;
  return conf_;
}
inline ::cl_message::LoginGW_Confirm* LoginGW::release_conf() {
  clear_has_conf();
  ::cl_message::LoginGW_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void LoginGW::set_allocated_conf(::cl_message::LoginGW_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// HeartbeatGW_Request

// optional int32 timestamp = 1;
inline bool HeartbeatGW_Request::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatGW_Request::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatGW_Request::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatGW_Request::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 HeartbeatGW_Request::timestamp() const {
  return timestamp_;
}
inline void HeartbeatGW_Request::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// HeartbeatGW_Confirm

// optional int32 rssi = 1;
inline bool HeartbeatGW_Confirm::has_rssi() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatGW_Confirm::set_has_rssi() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatGW_Confirm::clear_has_rssi() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatGW_Confirm::clear_rssi() {
  rssi_ = 0;
  clear_has_rssi();
}
inline ::google::protobuf::int32 HeartbeatGW_Confirm::rssi() const {
  return rssi_;
}
inline void HeartbeatGW_Confirm::set_rssi(::google::protobuf::int32 value) {
  set_has_rssi();
  rssi_ = value;
}

// -------------------------------------------------------------------

// HeartbeatGW

// optional .cl_message.HeartbeatGW.Request req = 1;
inline bool HeartbeatGW::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatGW::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatGW::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatGW::clear_req() {
  if (req_ != NULL) req_->::cl_message::HeartbeatGW_Request::Clear();
  clear_has_req();
}
inline const ::cl_message::HeartbeatGW_Request& HeartbeatGW::req() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return req_ != NULL ? *req_ : *default_instance().req_;
#else
  return req_ != NULL ? *req_ : *default_instance_->req_;
#endif
}
inline ::cl_message::HeartbeatGW_Request* HeartbeatGW::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::cl_message::HeartbeatGW_Request;
  return req_;
}
inline ::cl_message::HeartbeatGW_Request* HeartbeatGW::release_req() {
  clear_has_req();
  ::cl_message::HeartbeatGW_Request* temp = req_;
  req_ = NULL;
  return temp;
}
inline void HeartbeatGW::set_allocated_req(::cl_message::HeartbeatGW_Request* req) {
  delete req_;
  req_ = req;
  if (req) {
    set_has_req();
  } else {
    clear_has_req();
  }
}

// optional .cl_message.HeartbeatGW.Confirm conf = 2;
inline bool HeartbeatGW::has_conf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatGW::set_has_conf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatGW::clear_has_conf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatGW::clear_conf() {
  if (conf_ != NULL) conf_->::cl_message::HeartbeatGW_Confirm::Clear();
  clear_has_conf();
}
inline const ::cl_message::HeartbeatGW_Confirm& HeartbeatGW::conf() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return conf_ != NULL ? *conf_ : *default_instance().conf_;
#else
  return conf_ != NULL ? *conf_ : *default_instance_->conf_;
#endif
}
inline ::cl_message::HeartbeatGW_Confirm* HeartbeatGW::mutable_conf() {
  set_has_conf();
  if (conf_ == NULL) conf_ = new ::cl_message::HeartbeatGW_Confirm;
  return conf_;
}
inline ::cl_message::HeartbeatGW_Confirm* HeartbeatGW::release_conf() {
  clear_has_conf();
  ::cl_message::HeartbeatGW_Confirm* temp = conf_;
  conf_ = NULL;
  return temp;
}
inline void HeartbeatGW::set_allocated_conf(::cl_message::HeartbeatGW_Confirm* conf) {
  delete conf_;
  conf_ = conf;
  if (conf) {
    set_has_conf();
  } else {
    clear_has_conf();
  }
}

// -------------------------------------------------------------------

// NetstatGW

// optional bool isonline = 1;
inline bool NetstatGW::has_isonline() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetstatGW::set_has_isonline() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetstatGW::clear_has_isonline() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetstatGW::clear_isonline() {
  isonline_ = false;
  clear_has_isonline();
}
inline bool NetstatGW::isonline() const {
  return isonline_;
}
inline void NetstatGW::set_isonline(bool value) {
  set_has_isonline();
  isonline_ = value;
}

// optional int32 timestamp = 2;
inline bool NetstatGW::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetstatGW::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetstatGW::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetstatGW::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 NetstatGW::timestamp() const {
  return timestamp_;
}
inline void NetstatGW::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cl_message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cl_5fmessage_2eproto__INCLUDED
