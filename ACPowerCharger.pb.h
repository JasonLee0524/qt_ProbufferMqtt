// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: oss/southbound/ACPowerCharger.proto

#ifndef PROTOBUF_oss_2fsouthbound_2fACPowerCharger_2eproto__INCLUDED
#define PROTOBUF_oss_2fsouthbound_2fACPowerCharger_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Protobuf/oss/southbound/common/CommonBasicInfo.pb.h"
#include "Protobuf/oss/southbound/common/ConnectivityState.pb.h"
#include "Protobuf/oss/southbound/common/Alarm.pb.h"
#include "Protobuf/oss/southbound/common/DeviceState.pb.h"
#include "Protobuf/oss/southbound/common/ChargingConnector.pb.h"
#include "Protobuf/oss/southbound/common/ControlCommandResponse.pb.h"
#include "Protobuf/oss/southbound/common/RemoteUpgrade.pb.h"
#include "Protobuf/oss/southbound/common/RemoteConfiguration.pb.h"
#include "Protobuf/oss/southbound/common/RemoteControl.pb.h"
// @@protoc_insertion_point(includes)

namespace oss {
namespace southbound {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_oss_2fsouthbound_2fACPowerCharger_2eproto();
void protobuf_AssignDesc_oss_2fsouthbound_2fACPowerCharger_2eproto();
void protobuf_ShutdownFile_oss_2fsouthbound_2fACPowerCharger_2eproto();

class ACPowerCharger;
class ACPowerCharger_BasicInfo;
class ACPowerCharger_RealtimeInfo;
class ACPowerCharger_ServiceInfo;
class ACPowerCharger_RemoteOperation;

enum ACPowerCharger_PowerChargerType {
  ACPowerCharger_PowerChargerType_PCT_AC_ONLY = 0,
  ACPowerCharger_PowerChargerType_PCT_DC_ONLY = 1,
  ACPowerCharger_PowerChargerType_PCT_AC_DC_HYBRID = 2,
  ACPowerCharger_PowerChargerType_PCT_OTHER = 254,
  ACPowerCharger_PowerChargerType_PCT_UNKNOWN = 255
};
bool ACPowerCharger_PowerChargerType_IsValid(int value);
const ACPowerCharger_PowerChargerType ACPowerCharger_PowerChargerType_PowerChargerType_MIN = ACPowerCharger_PowerChargerType_PCT_AC_ONLY;
const ACPowerCharger_PowerChargerType ACPowerCharger_PowerChargerType_PowerChargerType_MAX = ACPowerCharger_PowerChargerType_PCT_UNKNOWN;
const int ACPowerCharger_PowerChargerType_PowerChargerType_ARRAYSIZE = ACPowerCharger_PowerChargerType_PowerChargerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACPowerCharger_PowerChargerType_descriptor();
inline const ::std::string& ACPowerCharger_PowerChargerType_Name(ACPowerCharger_PowerChargerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACPowerCharger_PowerChargerType_descriptor(), value);
}
inline bool ACPowerCharger_PowerChargerType_Parse(
    const ::std::string& name, ACPowerCharger_PowerChargerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACPowerCharger_PowerChargerType>(
    ACPowerCharger_PowerChargerType_descriptor(), name, value);
}
// ===================================================================

class ACPowerCharger_BasicInfo : public ::google::protobuf::Message {
 public:
  ACPowerCharger_BasicInfo();
  virtual ~ACPowerCharger_BasicInfo();

  ACPowerCharger_BasicInfo(const ACPowerCharger_BasicInfo& from);

  inline ACPowerCharger_BasicInfo& operator=(const ACPowerCharger_BasicInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACPowerCharger_BasicInfo& default_instance();

  void Swap(ACPowerCharger_BasicInfo* other);

  // implements Message ----------------------------------------------

  ACPowerCharger_BasicInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACPowerCharger_BasicInfo& from);
  void MergeFrom(const ACPowerCharger_BasicInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .oss.southbound.CommonBasicInfo common_basic_info = 1;
  inline bool has_common_basic_info() const;
  inline void clear_common_basic_info();
  static const int kCommonBasicInfoFieldNumber = 1;
  inline const ::oss::southbound::CommonBasicInfo& common_basic_info() const;
  inline ::oss::southbound::CommonBasicInfo* mutable_common_basic_info();
  inline ::oss::southbound::CommonBasicInfo* release_common_basic_info();
  inline void set_allocated_common_basic_info(::oss::southbound::CommonBasicInfo* common_basic_info);

  // optional .oss.southbound.ACPowerCharger.PowerChargerType power_charger_type = 2;
  inline bool has_power_charger_type() const;
  inline void clear_power_charger_type();
  static const int kPowerChargerTypeFieldNumber = 2;
  inline ::oss::southbound::ACPowerCharger_PowerChargerType power_charger_type() const;
  inline void set_power_charger_type(::oss::southbound::ACPowerCharger_PowerChargerType value);

  // optional int32 charging_connector_quantity = 3;
  inline bool has_charging_connector_quantity() const;
  inline void clear_charging_connector_quantity();
  static const int kChargingConnectorQuantityFieldNumber = 3;
  inline ::google::protobuf::int32 charging_connector_quantity() const;
  inline void set_charging_connector_quantity(::google::protobuf::int32 value);

  // optional float power = 4;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 4;
  inline float power() const;
  inline void set_power(float value);

  // @@protoc_insertion_point(class_scope:oss.southbound.ACPowerCharger.BasicInfo)
 private:
  inline void set_has_common_basic_info();
  inline void clear_has_common_basic_info();
  inline void set_has_power_charger_type();
  inline void clear_has_power_charger_type();
  inline void set_has_charging_connector_quantity();
  inline void clear_has_charging_connector_quantity();
  inline void set_has_power();
  inline void clear_has_power();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::oss::southbound::CommonBasicInfo* common_basic_info_;
  int power_charger_type_;
  ::google::protobuf::int32 charging_connector_quantity_;
  float power_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_oss_2fsouthbound_2fACPowerCharger_2eproto();
  friend void protobuf_AssignDesc_oss_2fsouthbound_2fACPowerCharger_2eproto();
  friend void protobuf_ShutdownFile_oss_2fsouthbound_2fACPowerCharger_2eproto();

  void InitAsDefaultInstance();
  static ACPowerCharger_BasicInfo* default_instance_;
};
// -------------------------------------------------------------------

class ACPowerCharger_RealtimeInfo : public ::google::protobuf::Message {
 public:
  ACPowerCharger_RealtimeInfo();
  virtual ~ACPowerCharger_RealtimeInfo();

  ACPowerCharger_RealtimeInfo(const ACPowerCharger_RealtimeInfo& from);

  inline ACPowerCharger_RealtimeInfo& operator=(const ACPowerCharger_RealtimeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACPowerCharger_RealtimeInfo& default_instance();

  void Swap(ACPowerCharger_RealtimeInfo* other);

  // implements Message ----------------------------------------------

  ACPowerCharger_RealtimeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACPowerCharger_RealtimeInfo& from);
  void MergeFrom(const ACPowerCharger_RealtimeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .oss.southbound.ConnectivityState connectivity_state = 1;
  inline bool has_connectivity_state() const;
  inline void clear_connectivity_state();
  static const int kConnectivityStateFieldNumber = 1;
  inline const ::oss::southbound::ConnectivityState& connectivity_state() const;
  inline ::oss::southbound::ConnectivityState* mutable_connectivity_state();
  inline ::oss::southbound::ConnectivityState* release_connectivity_state();
  inline void set_allocated_connectivity_state(::oss::southbound::ConnectivityState* connectivity_state);

  // optional .oss.southbound.DeviceState device_state = 2;
  inline bool has_device_state() const;
  inline void clear_device_state();
  static const int kDeviceStateFieldNumber = 2;
  inline const ::oss::southbound::DeviceState& device_state() const;
  inline ::oss::southbound::DeviceState* mutable_device_state();
  inline ::oss::southbound::DeviceState* release_device_state();
  inline void set_allocated_device_state(::oss::southbound::DeviceState* device_state);

  // optional .oss.southbound.ChargingConnector charging_connector = 4;
  inline bool has_charging_connector() const;
  inline void clear_charging_connector();
  static const int kChargingConnectorFieldNumber = 4;
  inline const ::oss::southbound::ChargingConnector& charging_connector() const;
  inline ::oss::southbound::ChargingConnector* mutable_charging_connector();
  inline ::oss::southbound::ChargingConnector* release_charging_connector();
  inline void set_allocated_charging_connector(::oss::southbound::ChargingConnector* charging_connector);

  // @@protoc_insertion_point(class_scope:oss.southbound.ACPowerCharger.RealtimeInfo)
 private:
  inline void set_has_connectivity_state();
  inline void clear_has_connectivity_state();
  inline void set_has_device_state();
  inline void clear_has_device_state();
  inline void set_has_charging_connector();
  inline void clear_has_charging_connector();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::oss::southbound::ConnectivityState* connectivity_state_;
  ::oss::southbound::DeviceState* device_state_;
  ::oss::southbound::ChargingConnector* charging_connector_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_oss_2fsouthbound_2fACPowerCharger_2eproto();
  friend void protobuf_AssignDesc_oss_2fsouthbound_2fACPowerCharger_2eproto();
  friend void protobuf_ShutdownFile_oss_2fsouthbound_2fACPowerCharger_2eproto();

  void InitAsDefaultInstance();
  static ACPowerCharger_RealtimeInfo* default_instance_;
};
// -------------------------------------------------------------------

class ACPowerCharger_ServiceInfo : public ::google::protobuf::Message {
 public:
  ACPowerCharger_ServiceInfo();
  virtual ~ACPowerCharger_ServiceInfo();

  ACPowerCharger_ServiceInfo(const ACPowerCharger_ServiceInfo& from);

  inline ACPowerCharger_ServiceInfo& operator=(const ACPowerCharger_ServiceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACPowerCharger_ServiceInfo& default_instance();

  void Swap(ACPowerCharger_ServiceInfo* other);

  // implements Message ----------------------------------------------

  ACPowerCharger_ServiceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACPowerCharger_ServiceInfo& from);
  void MergeFrom(const ACPowerCharger_ServiceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .oss.southbound.ChargingEvent charging_event = 1;
  inline bool has_charging_event() const;
  inline void clear_charging_event();
  static const int kChargingEventFieldNumber = 1;
  inline ::oss::southbound::ChargingEvent charging_event() const;
  inline void set_charging_event(::oss::southbound::ChargingEvent value);

  // optional int64 charging_start_timestamp = 2;
  inline bool has_charging_start_timestamp() const;
  inline void clear_charging_start_timestamp();
  static const int kChargingStartTimestampFieldNumber = 2;
  inline ::google::protobuf::int64 charging_start_timestamp() const;
  inline void set_charging_start_timestamp(::google::protobuf::int64 value);

  // optional float voltage = 3;
  inline bool has_voltage() const;
  inline void clear_voltage();
  static const int kVoltageFieldNumber = 3;
  inline float voltage() const;
  inline void set_voltage(float value);

  // optional float current = 4;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 4;
  inline float current() const;
  inline void set_current(float value);

  // optional float power = 5;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 5;
  inline float power() const;
  inline void set_power(float value);

  // optional float charged_power_realtime = 6;
  inline bool has_charged_power_realtime() const;
  inline void clear_charged_power_realtime();
  static const int kChargedPowerRealtimeFieldNumber = 6;
  inline float charged_power_realtime() const;
  inline void set_charged_power_realtime(float value);

  // optional int64 charging_finish_timestamp = 7;
  inline bool has_charging_finish_timestamp() const;
  inline void clear_charging_finish_timestamp();
  static const int kChargingFinishTimestampFieldNumber = 7;
  inline ::google::protobuf::int64 charging_finish_timestamp() const;
  inline void set_charging_finish_timestamp(::google::protobuf::int64 value);

  // optional float charged_power_total = 8;
  inline bool has_charged_power_total() const;
  inline void clear_charged_power_total();
  static const int kChargedPowerTotalFieldNumber = 8;
  inline float charged_power_total() const;
  inline void set_charged_power_total(float value);

  // optional int32 charging_duration = 9;
  inline bool has_charging_duration() const;
  inline void clear_charging_duration();
  static const int kChargingDurationFieldNumber = 9;
  inline ::google::protobuf::int32 charging_duration() const;
  inline void set_charging_duration(::google::protobuf::int32 value);

  // optional .oss.southbound.ChargingFinishResult charging_finish_result = 10;
  inline bool has_charging_finish_result() const;
  inline void clear_charging_finish_result();
  static const int kChargingFinishResultFieldNumber = 10;
  inline ::oss::southbound::ChargingFinishResult charging_finish_result() const;
  inline void set_charging_finish_result(::oss::southbound::ChargingFinishResult value);

  // @@protoc_insertion_point(class_scope:oss.southbound.ACPowerCharger.ServiceInfo)
 private:
  inline void set_has_charging_event();
  inline void clear_has_charging_event();
  inline void set_has_charging_start_timestamp();
  inline void clear_has_charging_start_timestamp();
  inline void set_has_voltage();
  inline void clear_has_voltage();
  inline void set_has_current();
  inline void clear_has_current();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_charged_power_realtime();
  inline void clear_has_charged_power_realtime();
  inline void set_has_charging_finish_timestamp();
  inline void clear_has_charging_finish_timestamp();
  inline void set_has_charged_power_total();
  inline void clear_has_charged_power_total();
  inline void set_has_charging_duration();
  inline void clear_has_charging_duration();
  inline void set_has_charging_finish_result();
  inline void clear_has_charging_finish_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charging_start_timestamp_;
  int charging_event_;
  float voltage_;
  float current_;
  float power_;
  ::google::protobuf::int64 charging_finish_timestamp_;
  float charged_power_realtime_;
  float charged_power_total_;
  ::google::protobuf::int32 charging_duration_;
  int charging_finish_result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_oss_2fsouthbound_2fACPowerCharger_2eproto();
  friend void protobuf_AssignDesc_oss_2fsouthbound_2fACPowerCharger_2eproto();
  friend void protobuf_ShutdownFile_oss_2fsouthbound_2fACPowerCharger_2eproto();

  void InitAsDefaultInstance();
  static ACPowerCharger_ServiceInfo* default_instance_;
};
// -------------------------------------------------------------------

class ACPowerCharger_RemoteOperation : public ::google::protobuf::Message {
 public:
  ACPowerCharger_RemoteOperation();
  virtual ~ACPowerCharger_RemoteOperation();

  ACPowerCharger_RemoteOperation(const ACPowerCharger_RemoteOperation& from);

  inline ACPowerCharger_RemoteOperation& operator=(const ACPowerCharger_RemoteOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACPowerCharger_RemoteOperation& default_instance();

  void Swap(ACPowerCharger_RemoteOperation* other);

  // implements Message ----------------------------------------------

  ACPowerCharger_RemoteOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACPowerCharger_RemoteOperation& from);
  void MergeFrom(const ACPowerCharger_RemoteOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .oss.southbound.ChargingPolicy charging_policy = 1;
  inline bool has_charging_policy() const;
  inline void clear_charging_policy();
  static const int kChargingPolicyFieldNumber = 1;
  inline const ::oss::southbound::ChargingPolicy& charging_policy() const;
  inline ::oss::southbound::ChargingPolicy* mutable_charging_policy();
  inline ::oss::southbound::ChargingPolicy* release_charging_policy();
  inline void set_allocated_charging_policy(::oss::southbound::ChargingPolicy* charging_policy);

  // optional .oss.southbound.RemoteControl remote_control = 2;
  inline bool has_remote_control() const;
  inline void clear_remote_control();
  static const int kRemoteControlFieldNumber = 2;
  inline const ::oss::southbound::RemoteControl& remote_control() const;
  inline ::oss::southbound::RemoteControl* mutable_remote_control();
  inline ::oss::southbound::RemoteControl* release_remote_control();
  inline void set_allocated_remote_control(::oss::southbound::RemoteControl* remote_control);

  // optional .oss.southbound.RemoteUpgrade remote_upgrade = 3;
  inline bool has_remote_upgrade() const;
  inline void clear_remote_upgrade();
  static const int kRemoteUpgradeFieldNumber = 3;
  inline const ::oss::southbound::RemoteUpgrade& remote_upgrade() const;
  inline ::oss::southbound::RemoteUpgrade* mutable_remote_upgrade();
  inline ::oss::southbound::RemoteUpgrade* release_remote_upgrade();
  inline void set_allocated_remote_upgrade(::oss::southbound::RemoteUpgrade* remote_upgrade);

  // optional .oss.southbound.RemoteConfiguration remote_configuration = 4;
  inline bool has_remote_configuration() const;
  inline void clear_remote_configuration();
  static const int kRemoteConfigurationFieldNumber = 4;
  inline const ::oss::southbound::RemoteConfiguration& remote_configuration() const;
  inline ::oss::southbound::RemoteConfiguration* mutable_remote_configuration();
  inline ::oss::southbound::RemoteConfiguration* release_remote_configuration();
  inline void set_allocated_remote_configuration(::oss::southbound::RemoteConfiguration* remote_configuration);

  // optional .oss.southbound.RemoteOperationResponse remote_operation_response = 5;
  inline bool has_remote_operation_response() const;
  inline void clear_remote_operation_response();
  static const int kRemoteOperationResponseFieldNumber = 5;
  inline const ::oss::southbound::RemoteOperationResponse& remote_operation_response() const;
  inline ::oss::southbound::RemoteOperationResponse* mutable_remote_operation_response();
  inline ::oss::southbound::RemoteOperationResponse* release_remote_operation_response();
  inline void set_allocated_remote_operation_response(::oss::southbound::RemoteOperationResponse* remote_operation_response);

  // @@protoc_insertion_point(class_scope:oss.southbound.ACPowerCharger.RemoteOperation)
 private:
  inline void set_has_charging_policy();
  inline void clear_has_charging_policy();
  inline void set_has_remote_control();
  inline void clear_has_remote_control();
  inline void set_has_remote_upgrade();
  inline void clear_has_remote_upgrade();
  inline void set_has_remote_configuration();
  inline void clear_has_remote_configuration();
  inline void set_has_remote_operation_response();
  inline void clear_has_remote_operation_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::oss::southbound::ChargingPolicy* charging_policy_;
  ::oss::southbound::RemoteControl* remote_control_;
  ::oss::southbound::RemoteUpgrade* remote_upgrade_;
  ::oss::southbound::RemoteConfiguration* remote_configuration_;
  ::oss::southbound::RemoteOperationResponse* remote_operation_response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_oss_2fsouthbound_2fACPowerCharger_2eproto();
  friend void protobuf_AssignDesc_oss_2fsouthbound_2fACPowerCharger_2eproto();
  friend void protobuf_ShutdownFile_oss_2fsouthbound_2fACPowerCharger_2eproto();

  void InitAsDefaultInstance();
  static ACPowerCharger_RemoteOperation* default_instance_;
};
// -------------------------------------------------------------------

class ACPowerCharger : public ::google::protobuf::Message {
 public:
  ACPowerCharger();
  virtual ~ACPowerCharger();

  ACPowerCharger(const ACPowerCharger& from);

  inline ACPowerCharger& operator=(const ACPowerCharger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACPowerCharger& default_instance();

  void Swap(ACPowerCharger* other);

  // implements Message ----------------------------------------------

  ACPowerCharger* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACPowerCharger& from);
  void MergeFrom(const ACPowerCharger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ACPowerCharger_BasicInfo BasicInfo;
  typedef ACPowerCharger_RealtimeInfo RealtimeInfo;
  typedef ACPowerCharger_ServiceInfo ServiceInfo;
  typedef ACPowerCharger_RemoteOperation RemoteOperation;

  typedef ACPowerCharger_PowerChargerType PowerChargerType;
  static const PowerChargerType PCT_AC_ONLY = ACPowerCharger_PowerChargerType_PCT_AC_ONLY;
  static const PowerChargerType PCT_DC_ONLY = ACPowerCharger_PowerChargerType_PCT_DC_ONLY;
  static const PowerChargerType PCT_AC_DC_HYBRID = ACPowerCharger_PowerChargerType_PCT_AC_DC_HYBRID;
  static const PowerChargerType PCT_OTHER = ACPowerCharger_PowerChargerType_PCT_OTHER;
  static const PowerChargerType PCT_UNKNOWN = ACPowerCharger_PowerChargerType_PCT_UNKNOWN;
  static inline bool PowerChargerType_IsValid(int value) {
    return ACPowerCharger_PowerChargerType_IsValid(value);
  }
  static const PowerChargerType PowerChargerType_MIN =
    ACPowerCharger_PowerChargerType_PowerChargerType_MIN;
  static const PowerChargerType PowerChargerType_MAX =
    ACPowerCharger_PowerChargerType_PowerChargerType_MAX;
  static const int PowerChargerType_ARRAYSIZE =
    ACPowerCharger_PowerChargerType_PowerChargerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PowerChargerType_descriptor() {
    return ACPowerCharger_PowerChargerType_descriptor();
  }
  static inline const ::std::string& PowerChargerType_Name(PowerChargerType value) {
    return ACPowerCharger_PowerChargerType_Name(value);
  }
  static inline bool PowerChargerType_Parse(const ::std::string& name,
      PowerChargerType* value) {
    return ACPowerCharger_PowerChargerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string device_id = 1;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional int64 message_timestamp = 2;
  inline bool has_message_timestamp() const;
  inline void clear_message_timestamp();
  static const int kMessageTimestampFieldNumber = 2;
  inline ::google::protobuf::int64 message_timestamp() const;
  inline void set_message_timestamp(::google::protobuf::int64 value);

  // optional .oss.southbound.ACPowerCharger.BasicInfo basicInfo = 3;
  inline bool has_basicinfo() const;
  inline void clear_basicinfo();
  static const int kBasicInfoFieldNumber = 3;
  inline const ::oss::southbound::ACPowerCharger_BasicInfo& basicinfo() const;
  inline ::oss::southbound::ACPowerCharger_BasicInfo* mutable_basicinfo();
  inline ::oss::southbound::ACPowerCharger_BasicInfo* release_basicinfo();
  inline void set_allocated_basicinfo(::oss::southbound::ACPowerCharger_BasicInfo* basicinfo);

  // optional .oss.southbound.ACPowerCharger.RealtimeInfo realtime_info = 4;
  inline bool has_realtime_info() const;
  inline void clear_realtime_info();
  static const int kRealtimeInfoFieldNumber = 4;
  inline const ::oss::southbound::ACPowerCharger_RealtimeInfo& realtime_info() const;
  inline ::oss::southbound::ACPowerCharger_RealtimeInfo* mutable_realtime_info();
  inline ::oss::southbound::ACPowerCharger_RealtimeInfo* release_realtime_info();
  inline void set_allocated_realtime_info(::oss::southbound::ACPowerCharger_RealtimeInfo* realtime_info);

  // repeated .oss.southbound.Alarm alarms = 5;
  inline int alarms_size() const;
  inline void clear_alarms();
  static const int kAlarmsFieldNumber = 5;
  inline const ::oss::southbound::Alarm& alarms(int index) const;
  inline ::oss::southbound::Alarm* mutable_alarms(int index);
  inline ::oss::southbound::Alarm* add_alarms();
  inline const ::google::protobuf::RepeatedPtrField< ::oss::southbound::Alarm >&
      alarms() const;
  inline ::google::protobuf::RepeatedPtrField< ::oss::southbound::Alarm >*
      mutable_alarms();

  // optional .oss.southbound.ACPowerCharger.ServiceInfo service_info = 6;
  inline bool has_service_info() const;
  inline void clear_service_info();
  static const int kServiceInfoFieldNumber = 6;
  inline const ::oss::southbound::ACPowerCharger_ServiceInfo& service_info() const;
  inline ::oss::southbound::ACPowerCharger_ServiceInfo* mutable_service_info();
  inline ::oss::southbound::ACPowerCharger_ServiceInfo* release_service_info();
  inline void set_allocated_service_info(::oss::southbound::ACPowerCharger_ServiceInfo* service_info);

  // optional .oss.southbound.ACPowerCharger.RemoteOperation remote_operation = 7;
  inline bool has_remote_operation() const;
  inline void clear_remote_operation();
  static const int kRemoteOperationFieldNumber = 7;
  inline const ::oss::southbound::ACPowerCharger_RemoteOperation& remote_operation() const;
  inline ::oss::southbound::ACPowerCharger_RemoteOperation* mutable_remote_operation();
  inline ::oss::southbound::ACPowerCharger_RemoteOperation* release_remote_operation();
  inline void set_allocated_remote_operation(::oss::southbound::ACPowerCharger_RemoteOperation* remote_operation);

  // @@protoc_insertion_point(class_scope:oss.southbound.ACPowerCharger)
 private:
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_message_timestamp();
  inline void clear_has_message_timestamp();
  inline void set_has_basicinfo();
  inline void clear_has_basicinfo();
  inline void set_has_realtime_info();
  inline void clear_has_realtime_info();
  inline void set_has_service_info();
  inline void clear_has_service_info();
  inline void set_has_remote_operation();
  inline void clear_has_remote_operation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_id_;
  ::google::protobuf::int64 message_timestamp_;
  ::oss::southbound::ACPowerCharger_BasicInfo* basicinfo_;
  ::oss::southbound::ACPowerCharger_RealtimeInfo* realtime_info_;
  ::google::protobuf::RepeatedPtrField< ::oss::southbound::Alarm > alarms_;
  ::oss::southbound::ACPowerCharger_ServiceInfo* service_info_;
  ::oss::southbound::ACPowerCharger_RemoteOperation* remote_operation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_oss_2fsouthbound_2fACPowerCharger_2eproto();
  friend void protobuf_AssignDesc_oss_2fsouthbound_2fACPowerCharger_2eproto();
  friend void protobuf_ShutdownFile_oss_2fsouthbound_2fACPowerCharger_2eproto();

  void InitAsDefaultInstance();
  static ACPowerCharger* default_instance_;
};
// ===================================================================


// ===================================================================

// ACPowerCharger_BasicInfo

// optional .oss.southbound.CommonBasicInfo common_basic_info = 1;
inline bool ACPowerCharger_BasicInfo::has_common_basic_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACPowerCharger_BasicInfo::set_has_common_basic_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACPowerCharger_BasicInfo::clear_has_common_basic_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACPowerCharger_BasicInfo::clear_common_basic_info() {
  if (common_basic_info_ != NULL) common_basic_info_->::oss::southbound::CommonBasicInfo::Clear();
  clear_has_common_basic_info();
}
inline const ::oss::southbound::CommonBasicInfo& ACPowerCharger_BasicInfo::common_basic_info() const {
  return common_basic_info_ != NULL ? *common_basic_info_ : *default_instance_->common_basic_info_;
}
inline ::oss::southbound::CommonBasicInfo* ACPowerCharger_BasicInfo::mutable_common_basic_info() {
  set_has_common_basic_info();
  if (common_basic_info_ == NULL) common_basic_info_ = new ::oss::southbound::CommonBasicInfo;
  return common_basic_info_;
}
inline ::oss::southbound::CommonBasicInfo* ACPowerCharger_BasicInfo::release_common_basic_info() {
  clear_has_common_basic_info();
  ::oss::southbound::CommonBasicInfo* temp = common_basic_info_;
  common_basic_info_ = NULL;
  return temp;
}
inline void ACPowerCharger_BasicInfo::set_allocated_common_basic_info(::oss::southbound::CommonBasicInfo* common_basic_info) {
  delete common_basic_info_;
  common_basic_info_ = common_basic_info;
  if (common_basic_info) {
    set_has_common_basic_info();
  } else {
    clear_has_common_basic_info();
  }
}

// optional .oss.southbound.ACPowerCharger.PowerChargerType power_charger_type = 2;
inline bool ACPowerCharger_BasicInfo::has_power_charger_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACPowerCharger_BasicInfo::set_has_power_charger_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACPowerCharger_BasicInfo::clear_has_power_charger_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACPowerCharger_BasicInfo::clear_power_charger_type() {
  power_charger_type_ = 0;
  clear_has_power_charger_type();
}
inline ::oss::southbound::ACPowerCharger_PowerChargerType ACPowerCharger_BasicInfo::power_charger_type() const {
  return static_cast< ::oss::southbound::ACPowerCharger_PowerChargerType >(power_charger_type_);
}
inline void ACPowerCharger_BasicInfo::set_power_charger_type(::oss::southbound::ACPowerCharger_PowerChargerType value) {
  assert(::oss::southbound::ACPowerCharger_PowerChargerType_IsValid(value));
  set_has_power_charger_type();
  power_charger_type_ = value;
}

// optional int32 charging_connector_quantity = 3;
inline bool ACPowerCharger_BasicInfo::has_charging_connector_quantity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACPowerCharger_BasicInfo::set_has_charging_connector_quantity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACPowerCharger_BasicInfo::clear_has_charging_connector_quantity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACPowerCharger_BasicInfo::clear_charging_connector_quantity() {
  charging_connector_quantity_ = 0;
  clear_has_charging_connector_quantity();
}
inline ::google::protobuf::int32 ACPowerCharger_BasicInfo::charging_connector_quantity() const {
  return charging_connector_quantity_;
}
inline void ACPowerCharger_BasicInfo::set_charging_connector_quantity(::google::protobuf::int32 value) {
  set_has_charging_connector_quantity();
  charging_connector_quantity_ = value;
}

// optional float power = 4;
inline bool ACPowerCharger_BasicInfo::has_power() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACPowerCharger_BasicInfo::set_has_power() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACPowerCharger_BasicInfo::clear_has_power() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACPowerCharger_BasicInfo::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline float ACPowerCharger_BasicInfo::power() const {
  return power_;
}
inline void ACPowerCharger_BasicInfo::set_power(float value) {
  set_has_power();
  power_ = value;
}

// -------------------------------------------------------------------

// ACPowerCharger_RealtimeInfo

// optional .oss.southbound.ConnectivityState connectivity_state = 1;
inline bool ACPowerCharger_RealtimeInfo::has_connectivity_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACPowerCharger_RealtimeInfo::set_has_connectivity_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACPowerCharger_RealtimeInfo::clear_has_connectivity_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACPowerCharger_RealtimeInfo::clear_connectivity_state() {
  if (connectivity_state_ != NULL) connectivity_state_->::oss::southbound::ConnectivityState::Clear();
  clear_has_connectivity_state();
}
inline const ::oss::southbound::ConnectivityState& ACPowerCharger_RealtimeInfo::connectivity_state() const {
  return connectivity_state_ != NULL ? *connectivity_state_ : *default_instance_->connectivity_state_;
}
inline ::oss::southbound::ConnectivityState* ACPowerCharger_RealtimeInfo::mutable_connectivity_state() {
  set_has_connectivity_state();
  if (connectivity_state_ == NULL) connectivity_state_ = new ::oss::southbound::ConnectivityState;
  return connectivity_state_;
}
inline ::oss::southbound::ConnectivityState* ACPowerCharger_RealtimeInfo::release_connectivity_state() {
  clear_has_connectivity_state();
  ::oss::southbound::ConnectivityState* temp = connectivity_state_;
  connectivity_state_ = NULL;
  return temp;
}
inline void ACPowerCharger_RealtimeInfo::set_allocated_connectivity_state(::oss::southbound::ConnectivityState* connectivity_state) {
  delete connectivity_state_;
  connectivity_state_ = connectivity_state;
  if (connectivity_state) {
    set_has_connectivity_state();
  } else {
    clear_has_connectivity_state();
  }
}

// optional .oss.southbound.DeviceState device_state = 2;
inline bool ACPowerCharger_RealtimeInfo::has_device_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACPowerCharger_RealtimeInfo::set_has_device_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACPowerCharger_RealtimeInfo::clear_has_device_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACPowerCharger_RealtimeInfo::clear_device_state() {
  if (device_state_ != NULL) device_state_->::oss::southbound::DeviceState::Clear();
  clear_has_device_state();
}
inline const ::oss::southbound::DeviceState& ACPowerCharger_RealtimeInfo::device_state() const {
  return device_state_ != NULL ? *device_state_ : *default_instance_->device_state_;
}
inline ::oss::southbound::DeviceState* ACPowerCharger_RealtimeInfo::mutable_device_state() {
  set_has_device_state();
  if (device_state_ == NULL) device_state_ = new ::oss::southbound::DeviceState;
  return device_state_;
}
inline ::oss::southbound::DeviceState* ACPowerCharger_RealtimeInfo::release_device_state() {
  clear_has_device_state();
  ::oss::southbound::DeviceState* temp = device_state_;
  device_state_ = NULL;
  return temp;
}
inline void ACPowerCharger_RealtimeInfo::set_allocated_device_state(::oss::southbound::DeviceState* device_state) {
  delete device_state_;
  device_state_ = device_state;
  if (device_state) {
    set_has_device_state();
  } else {
    clear_has_device_state();
  }
}

// optional .oss.southbound.ChargingConnector charging_connector = 4;
inline bool ACPowerCharger_RealtimeInfo::has_charging_connector() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACPowerCharger_RealtimeInfo::set_has_charging_connector() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACPowerCharger_RealtimeInfo::clear_has_charging_connector() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACPowerCharger_RealtimeInfo::clear_charging_connector() {
  if (charging_connector_ != NULL) charging_connector_->::oss::southbound::ChargingConnector::Clear();
  clear_has_charging_connector();
}
inline const ::oss::southbound::ChargingConnector& ACPowerCharger_RealtimeInfo::charging_connector() const {
  return charging_connector_ != NULL ? *charging_connector_ : *default_instance_->charging_connector_;
}
inline ::oss::southbound::ChargingConnector* ACPowerCharger_RealtimeInfo::mutable_charging_connector() {
  set_has_charging_connector();
  if (charging_connector_ == NULL) charging_connector_ = new ::oss::southbound::ChargingConnector;
  return charging_connector_;
}
inline ::oss::southbound::ChargingConnector* ACPowerCharger_RealtimeInfo::release_charging_connector() {
  clear_has_charging_connector();
  ::oss::southbound::ChargingConnector* temp = charging_connector_;
  charging_connector_ = NULL;
  return temp;
}
inline void ACPowerCharger_RealtimeInfo::set_allocated_charging_connector(::oss::southbound::ChargingConnector* charging_connector) {
  delete charging_connector_;
  charging_connector_ = charging_connector;
  if (charging_connector) {
    set_has_charging_connector();
  } else {
    clear_has_charging_connector();
  }
}

// -------------------------------------------------------------------

// ACPowerCharger_ServiceInfo

// optional .oss.southbound.ChargingEvent charging_event = 1;
inline bool ACPowerCharger_ServiceInfo::has_charging_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_charging_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_charging_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACPowerCharger_ServiceInfo::clear_charging_event() {
  charging_event_ = 0;
  clear_has_charging_event();
}
inline ::oss::southbound::ChargingEvent ACPowerCharger_ServiceInfo::charging_event() const {
  return static_cast< ::oss::southbound::ChargingEvent >(charging_event_);
}
inline void ACPowerCharger_ServiceInfo::set_charging_event(::oss::southbound::ChargingEvent value) {
  assert(::oss::southbound::ChargingEvent_IsValid(value));
  set_has_charging_event();
  charging_event_ = value;
}

// optional int64 charging_start_timestamp = 2;
inline bool ACPowerCharger_ServiceInfo::has_charging_start_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_charging_start_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_charging_start_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACPowerCharger_ServiceInfo::clear_charging_start_timestamp() {
  charging_start_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_charging_start_timestamp();
}
inline ::google::protobuf::int64 ACPowerCharger_ServiceInfo::charging_start_timestamp() const {
  return charging_start_timestamp_;
}
inline void ACPowerCharger_ServiceInfo::set_charging_start_timestamp(::google::protobuf::int64 value) {
  set_has_charging_start_timestamp();
  charging_start_timestamp_ = value;
}

// optional float voltage = 3;
inline bool ACPowerCharger_ServiceInfo::has_voltage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_voltage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_voltage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACPowerCharger_ServiceInfo::clear_voltage() {
  voltage_ = 0;
  clear_has_voltage();
}
inline float ACPowerCharger_ServiceInfo::voltage() const {
  return voltage_;
}
inline void ACPowerCharger_ServiceInfo::set_voltage(float value) {
  set_has_voltage();
  voltage_ = value;
}

// optional float current = 4;
inline bool ACPowerCharger_ServiceInfo::has_current() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_current() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_current() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACPowerCharger_ServiceInfo::clear_current() {
  current_ = 0;
  clear_has_current();
}
inline float ACPowerCharger_ServiceInfo::current() const {
  return current_;
}
inline void ACPowerCharger_ServiceInfo::set_current(float value) {
  set_has_current();
  current_ = value;
}

// optional float power = 5;
inline bool ACPowerCharger_ServiceInfo::has_power() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_power() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_power() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACPowerCharger_ServiceInfo::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline float ACPowerCharger_ServiceInfo::power() const {
  return power_;
}
inline void ACPowerCharger_ServiceInfo::set_power(float value) {
  set_has_power();
  power_ = value;
}

// optional float charged_power_realtime = 6;
inline bool ACPowerCharger_ServiceInfo::has_charged_power_realtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_charged_power_realtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_charged_power_realtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ACPowerCharger_ServiceInfo::clear_charged_power_realtime() {
  charged_power_realtime_ = 0;
  clear_has_charged_power_realtime();
}
inline float ACPowerCharger_ServiceInfo::charged_power_realtime() const {
  return charged_power_realtime_;
}
inline void ACPowerCharger_ServiceInfo::set_charged_power_realtime(float value) {
  set_has_charged_power_realtime();
  charged_power_realtime_ = value;
}

// optional int64 charging_finish_timestamp = 7;
inline bool ACPowerCharger_ServiceInfo::has_charging_finish_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_charging_finish_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_charging_finish_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ACPowerCharger_ServiceInfo::clear_charging_finish_timestamp() {
  charging_finish_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_charging_finish_timestamp();
}
inline ::google::protobuf::int64 ACPowerCharger_ServiceInfo::charging_finish_timestamp() const {
  return charging_finish_timestamp_;
}
inline void ACPowerCharger_ServiceInfo::set_charging_finish_timestamp(::google::protobuf::int64 value) {
  set_has_charging_finish_timestamp();
  charging_finish_timestamp_ = value;
}

// optional float charged_power_total = 8;
inline bool ACPowerCharger_ServiceInfo::has_charged_power_total() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_charged_power_total() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_charged_power_total() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ACPowerCharger_ServiceInfo::clear_charged_power_total() {
  charged_power_total_ = 0;
  clear_has_charged_power_total();
}
inline float ACPowerCharger_ServiceInfo::charged_power_total() const {
  return charged_power_total_;
}
inline void ACPowerCharger_ServiceInfo::set_charged_power_total(float value) {
  set_has_charged_power_total();
  charged_power_total_ = value;
}

// optional int32 charging_duration = 9;
inline bool ACPowerCharger_ServiceInfo::has_charging_duration() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_charging_duration() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_charging_duration() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ACPowerCharger_ServiceInfo::clear_charging_duration() {
  charging_duration_ = 0;
  clear_has_charging_duration();
}
inline ::google::protobuf::int32 ACPowerCharger_ServiceInfo::charging_duration() const {
  return charging_duration_;
}
inline void ACPowerCharger_ServiceInfo::set_charging_duration(::google::protobuf::int32 value) {
  set_has_charging_duration();
  charging_duration_ = value;
}

// optional .oss.southbound.ChargingFinishResult charging_finish_result = 10;
inline bool ACPowerCharger_ServiceInfo::has_charging_finish_result() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ACPowerCharger_ServiceInfo::set_has_charging_finish_result() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ACPowerCharger_ServiceInfo::clear_has_charging_finish_result() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ACPowerCharger_ServiceInfo::clear_charging_finish_result() {
  charging_finish_result_ = 0;
  clear_has_charging_finish_result();
}
inline ::oss::southbound::ChargingFinishResult ACPowerCharger_ServiceInfo::charging_finish_result() const {
  return static_cast< ::oss::southbound::ChargingFinishResult >(charging_finish_result_);
}
inline void ACPowerCharger_ServiceInfo::set_charging_finish_result(::oss::southbound::ChargingFinishResult value) {
  assert(::oss::southbound::ChargingFinishResult_IsValid(value));
  set_has_charging_finish_result();
  charging_finish_result_ = value;
}

// -------------------------------------------------------------------

// ACPowerCharger_RemoteOperation

// optional .oss.southbound.ChargingPolicy charging_policy = 1;
inline bool ACPowerCharger_RemoteOperation::has_charging_policy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACPowerCharger_RemoteOperation::set_has_charging_policy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACPowerCharger_RemoteOperation::clear_has_charging_policy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACPowerCharger_RemoteOperation::clear_charging_policy() {
  if (charging_policy_ != NULL) charging_policy_->::oss::southbound::ChargingPolicy::Clear();
  clear_has_charging_policy();
}
inline const ::oss::southbound::ChargingPolicy& ACPowerCharger_RemoteOperation::charging_policy() const {
  return charging_policy_ != NULL ? *charging_policy_ : *default_instance_->charging_policy_;
}
inline ::oss::southbound::ChargingPolicy* ACPowerCharger_RemoteOperation::mutable_charging_policy() {
  set_has_charging_policy();
  if (charging_policy_ == NULL) charging_policy_ = new ::oss::southbound::ChargingPolicy;
  return charging_policy_;
}
inline ::oss::southbound::ChargingPolicy* ACPowerCharger_RemoteOperation::release_charging_policy() {
  clear_has_charging_policy();
  ::oss::southbound::ChargingPolicy* temp = charging_policy_;
  charging_policy_ = NULL;
  return temp;
}
inline void ACPowerCharger_RemoteOperation::set_allocated_charging_policy(::oss::southbound::ChargingPolicy* charging_policy) {
  delete charging_policy_;
  charging_policy_ = charging_policy;
  if (charging_policy) {
    set_has_charging_policy();
  } else {
    clear_has_charging_policy();
  }
}

// optional .oss.southbound.RemoteControl remote_control = 2;
inline bool ACPowerCharger_RemoteOperation::has_remote_control() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACPowerCharger_RemoteOperation::set_has_remote_control() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACPowerCharger_RemoteOperation::clear_has_remote_control() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACPowerCharger_RemoteOperation::clear_remote_control() {
  if (remote_control_ != NULL) remote_control_->::oss::southbound::RemoteControl::Clear();
  clear_has_remote_control();
}
inline const ::oss::southbound::RemoteControl& ACPowerCharger_RemoteOperation::remote_control() const {
  return remote_control_ != NULL ? *remote_control_ : *default_instance_->remote_control_;
}
inline ::oss::southbound::RemoteControl* ACPowerCharger_RemoteOperation::mutable_remote_control() {
  set_has_remote_control();
  if (remote_control_ == NULL) remote_control_ = new ::oss::southbound::RemoteControl;
  return remote_control_;
}
inline ::oss::southbound::RemoteControl* ACPowerCharger_RemoteOperation::release_remote_control() {
  clear_has_remote_control();
  ::oss::southbound::RemoteControl* temp = remote_control_;
  remote_control_ = NULL;
  return temp;
}
inline void ACPowerCharger_RemoteOperation::set_allocated_remote_control(::oss::southbound::RemoteControl* remote_control) {
  delete remote_control_;
  remote_control_ = remote_control;
  if (remote_control) {
    set_has_remote_control();
  } else {
    clear_has_remote_control();
  }
}

// optional .oss.southbound.RemoteUpgrade remote_upgrade = 3;
inline bool ACPowerCharger_RemoteOperation::has_remote_upgrade() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACPowerCharger_RemoteOperation::set_has_remote_upgrade() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACPowerCharger_RemoteOperation::clear_has_remote_upgrade() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACPowerCharger_RemoteOperation::clear_remote_upgrade() {
  if (remote_upgrade_ != NULL) remote_upgrade_->::oss::southbound::RemoteUpgrade::Clear();
  clear_has_remote_upgrade();
}
inline const ::oss::southbound::RemoteUpgrade& ACPowerCharger_RemoteOperation::remote_upgrade() const {
  return remote_upgrade_ != NULL ? *remote_upgrade_ : *default_instance_->remote_upgrade_;
}
inline ::oss::southbound::RemoteUpgrade* ACPowerCharger_RemoteOperation::mutable_remote_upgrade() {
  set_has_remote_upgrade();
  if (remote_upgrade_ == NULL) remote_upgrade_ = new ::oss::southbound::RemoteUpgrade;
  return remote_upgrade_;
}
inline ::oss::southbound::RemoteUpgrade* ACPowerCharger_RemoteOperation::release_remote_upgrade() {
  clear_has_remote_upgrade();
  ::oss::southbound::RemoteUpgrade* temp = remote_upgrade_;
  remote_upgrade_ = NULL;
  return temp;
}
inline void ACPowerCharger_RemoteOperation::set_allocated_remote_upgrade(::oss::southbound::RemoteUpgrade* remote_upgrade) {
  delete remote_upgrade_;
  remote_upgrade_ = remote_upgrade;
  if (remote_upgrade) {
    set_has_remote_upgrade();
  } else {
    clear_has_remote_upgrade();
  }
}

// optional .oss.southbound.RemoteConfiguration remote_configuration = 4;
inline bool ACPowerCharger_RemoteOperation::has_remote_configuration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACPowerCharger_RemoteOperation::set_has_remote_configuration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACPowerCharger_RemoteOperation::clear_has_remote_configuration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACPowerCharger_RemoteOperation::clear_remote_configuration() {
  if (remote_configuration_ != NULL) remote_configuration_->::oss::southbound::RemoteConfiguration::Clear();
  clear_has_remote_configuration();
}
inline const ::oss::southbound::RemoteConfiguration& ACPowerCharger_RemoteOperation::remote_configuration() const {
  return remote_configuration_ != NULL ? *remote_configuration_ : *default_instance_->remote_configuration_;
}
inline ::oss::southbound::RemoteConfiguration* ACPowerCharger_RemoteOperation::mutable_remote_configuration() {
  set_has_remote_configuration();
  if (remote_configuration_ == NULL) remote_configuration_ = new ::oss::southbound::RemoteConfiguration;
  return remote_configuration_;
}
inline ::oss::southbound::RemoteConfiguration* ACPowerCharger_RemoteOperation::release_remote_configuration() {
  clear_has_remote_configuration();
  ::oss::southbound::RemoteConfiguration* temp = remote_configuration_;
  remote_configuration_ = NULL;
  return temp;
}
inline void ACPowerCharger_RemoteOperation::set_allocated_remote_configuration(::oss::southbound::RemoteConfiguration* remote_configuration) {
  delete remote_configuration_;
  remote_configuration_ = remote_configuration;
  if (remote_configuration) {
    set_has_remote_configuration();
  } else {
    clear_has_remote_configuration();
  }
}

// optional .oss.southbound.RemoteOperationResponse remote_operation_response = 5;
inline bool ACPowerCharger_RemoteOperation::has_remote_operation_response() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACPowerCharger_RemoteOperation::set_has_remote_operation_response() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ACPowerCharger_RemoteOperation::clear_has_remote_operation_response() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ACPowerCharger_RemoteOperation::clear_remote_operation_response() {
  if (remote_operation_response_ != NULL) remote_operation_response_->::oss::southbound::RemoteOperationResponse::Clear();
  clear_has_remote_operation_response();
}
inline const ::oss::southbound::RemoteOperationResponse& ACPowerCharger_RemoteOperation::remote_operation_response() const {
  return remote_operation_response_ != NULL ? *remote_operation_response_ : *default_instance_->remote_operation_response_;
}
inline ::oss::southbound::RemoteOperationResponse* ACPowerCharger_RemoteOperation::mutable_remote_operation_response() {
  set_has_remote_operation_response();
  if (remote_operation_response_ == NULL) remote_operation_response_ = new ::oss::southbound::RemoteOperationResponse;
  return remote_operation_response_;
}
inline ::oss::southbound::RemoteOperationResponse* ACPowerCharger_RemoteOperation::release_remote_operation_response() {
  clear_has_remote_operation_response();
  ::oss::southbound::RemoteOperationResponse* temp = remote_operation_response_;
  remote_operation_response_ = NULL;
  return temp;
}
inline void ACPowerCharger_RemoteOperation::set_allocated_remote_operation_response(::oss::southbound::RemoteOperationResponse* remote_operation_response) {
  delete remote_operation_response_;
  remote_operation_response_ = remote_operation_response;
  if (remote_operation_response) {
    set_has_remote_operation_response();
  } else {
    clear_has_remote_operation_response();
  }
}

// -------------------------------------------------------------------

// ACPowerCharger

// optional string device_id = 1;
inline bool ACPowerCharger::has_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACPowerCharger::set_has_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACPowerCharger::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACPowerCharger::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& ACPowerCharger::device_id() const {
  return *device_id_;
}
inline void ACPowerCharger::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ACPowerCharger::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void ACPowerCharger::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ACPowerCharger::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* ACPowerCharger::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ACPowerCharger::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 message_timestamp = 2;
inline bool ACPowerCharger::has_message_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACPowerCharger::set_has_message_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACPowerCharger::clear_has_message_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACPowerCharger::clear_message_timestamp() {
  message_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_message_timestamp();
}
inline ::google::protobuf::int64 ACPowerCharger::message_timestamp() const {
  return message_timestamp_;
}
inline void ACPowerCharger::set_message_timestamp(::google::protobuf::int64 value) {
  set_has_message_timestamp();
  message_timestamp_ = value;
}

// optional .oss.southbound.ACPowerCharger.BasicInfo basicInfo = 3;
inline bool ACPowerCharger::has_basicinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACPowerCharger::set_has_basicinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ACPowerCharger::clear_has_basicinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ACPowerCharger::clear_basicinfo() {
  if (basicinfo_ != NULL) basicinfo_->::oss::southbound::ACPowerCharger_BasicInfo::Clear();
  clear_has_basicinfo();
}
inline const ::oss::southbound::ACPowerCharger_BasicInfo& ACPowerCharger::basicinfo() const {
  return basicinfo_ != NULL ? *basicinfo_ : *default_instance_->basicinfo_;
}
inline ::oss::southbound::ACPowerCharger_BasicInfo* ACPowerCharger::mutable_basicinfo() {
  set_has_basicinfo();
  if (basicinfo_ == NULL) basicinfo_ = new ::oss::southbound::ACPowerCharger_BasicInfo;
  return basicinfo_;
}
inline ::oss::southbound::ACPowerCharger_BasicInfo* ACPowerCharger::release_basicinfo() {
  clear_has_basicinfo();
  ::oss::southbound::ACPowerCharger_BasicInfo* temp = basicinfo_;
  basicinfo_ = NULL;
  return temp;
}
inline void ACPowerCharger::set_allocated_basicinfo(::oss::southbound::ACPowerCharger_BasicInfo* basicinfo) {
  delete basicinfo_;
  basicinfo_ = basicinfo;
  if (basicinfo) {
    set_has_basicinfo();
  } else {
    clear_has_basicinfo();
  }
}

// optional .oss.southbound.ACPowerCharger.RealtimeInfo realtime_info = 4;
inline bool ACPowerCharger::has_realtime_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACPowerCharger::set_has_realtime_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ACPowerCharger::clear_has_realtime_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ACPowerCharger::clear_realtime_info() {
  if (realtime_info_ != NULL) realtime_info_->::oss::southbound::ACPowerCharger_RealtimeInfo::Clear();
  clear_has_realtime_info();
}
inline const ::oss::southbound::ACPowerCharger_RealtimeInfo& ACPowerCharger::realtime_info() const {
  return realtime_info_ != NULL ? *realtime_info_ : *default_instance_->realtime_info_;
}
inline ::oss::southbound::ACPowerCharger_RealtimeInfo* ACPowerCharger::mutable_realtime_info() {
  set_has_realtime_info();
  if (realtime_info_ == NULL) realtime_info_ = new ::oss::southbound::ACPowerCharger_RealtimeInfo;
  return realtime_info_;
}
inline ::oss::southbound::ACPowerCharger_RealtimeInfo* ACPowerCharger::release_realtime_info() {
  clear_has_realtime_info();
  ::oss::southbound::ACPowerCharger_RealtimeInfo* temp = realtime_info_;
  realtime_info_ = NULL;
  return temp;
}
inline void ACPowerCharger::set_allocated_realtime_info(::oss::southbound::ACPowerCharger_RealtimeInfo* realtime_info) {
  delete realtime_info_;
  realtime_info_ = realtime_info;
  if (realtime_info) {
    set_has_realtime_info();
  } else {
    clear_has_realtime_info();
  }
}

// repeated .oss.southbound.Alarm alarms = 5;
inline int ACPowerCharger::alarms_size() const {
  return alarms_.size();
}
inline void ACPowerCharger::clear_alarms() {
  alarms_.Clear();
}
inline const ::oss::southbound::Alarm& ACPowerCharger::alarms(int index) const {
  return alarms_.Get(index);
}
inline ::oss::southbound::Alarm* ACPowerCharger::mutable_alarms(int index) {
  return alarms_.Mutable(index);
}
inline ::oss::southbound::Alarm* ACPowerCharger::add_alarms() {
  return alarms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::oss::southbound::Alarm >&
ACPowerCharger::alarms() const {
  return alarms_;
}
inline ::google::protobuf::RepeatedPtrField< ::oss::southbound::Alarm >*
ACPowerCharger::mutable_alarms() {
  return &alarms_;
}

// optional .oss.southbound.ACPowerCharger.ServiceInfo service_info = 6;
inline bool ACPowerCharger::has_service_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ACPowerCharger::set_has_service_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ACPowerCharger::clear_has_service_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ACPowerCharger::clear_service_info() {
  if (service_info_ != NULL) service_info_->::oss::southbound::ACPowerCharger_ServiceInfo::Clear();
  clear_has_service_info();
}
inline const ::oss::southbound::ACPowerCharger_ServiceInfo& ACPowerCharger::service_info() const {
  return service_info_ != NULL ? *service_info_ : *default_instance_->service_info_;
}
inline ::oss::southbound::ACPowerCharger_ServiceInfo* ACPowerCharger::mutable_service_info() {
  set_has_service_info();
  if (service_info_ == NULL) service_info_ = new ::oss::southbound::ACPowerCharger_ServiceInfo;
  return service_info_;
}
inline ::oss::southbound::ACPowerCharger_ServiceInfo* ACPowerCharger::release_service_info() {
  clear_has_service_info();
  ::oss::southbound::ACPowerCharger_ServiceInfo* temp = service_info_;
  service_info_ = NULL;
  return temp;
}
inline void ACPowerCharger::set_allocated_service_info(::oss::southbound::ACPowerCharger_ServiceInfo* service_info) {
  delete service_info_;
  service_info_ = service_info;
  if (service_info) {
    set_has_service_info();
  } else {
    clear_has_service_info();
  }
}

// optional .oss.southbound.ACPowerCharger.RemoteOperation remote_operation = 7;
inline bool ACPowerCharger::has_remote_operation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ACPowerCharger::set_has_remote_operation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ACPowerCharger::clear_has_remote_operation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ACPowerCharger::clear_remote_operation() {
  if (remote_operation_ != NULL) remote_operation_->::oss::southbound::ACPowerCharger_RemoteOperation::Clear();
  clear_has_remote_operation();
}
inline const ::oss::southbound::ACPowerCharger_RemoteOperation& ACPowerCharger::remote_operation() const {
  return remote_operation_ != NULL ? *remote_operation_ : *default_instance_->remote_operation_;
}
inline ::oss::southbound::ACPowerCharger_RemoteOperation* ACPowerCharger::mutable_remote_operation() {
  set_has_remote_operation();
  if (remote_operation_ == NULL) remote_operation_ = new ::oss::southbound::ACPowerCharger_RemoteOperation;
  return remote_operation_;
}
inline ::oss::southbound::ACPowerCharger_RemoteOperation* ACPowerCharger::release_remote_operation() {
  clear_has_remote_operation();
  ::oss::southbound::ACPowerCharger_RemoteOperation* temp = remote_operation_;
  remote_operation_ = NULL;
  return temp;
}
inline void ACPowerCharger::set_allocated_remote_operation(::oss::southbound::ACPowerCharger_RemoteOperation* remote_operation) {
  delete remote_operation_;
  remote_operation_ = remote_operation;
  if (remote_operation) {
    set_has_remote_operation();
  } else {
    clear_has_remote_operation();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace southbound
}  // namespace oss

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::oss::southbound::ACPowerCharger_PowerChargerType>() {
  return ::oss::southbound::ACPowerCharger_PowerChargerType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_oss_2fsouthbound_2fACPowerCharger_2eproto__INCLUDED
