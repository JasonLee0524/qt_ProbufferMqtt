// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cl_message.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "cl_message.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace cl_message {

void protobuf_ShutdownFile_cl_5fmessage_2eproto() {
  delete Base::default_instance_;
  delete CallError::default_instance_;
  delete IdToken::default_instance_;
  delete IdTagInfo::default_instance_;
  delete Transactions::default_instance_;
  delete Tariff::default_instance_;
  delete PriceScheme::default_instance_;
  delete ConfigOption::default_instance_;
  delete ConfigSection::default_instance_;
  delete RequestStart::default_instance_;
  delete RequestStart_Request::default_instance_;
  delete RequestStart_Confirm::default_instance_;
  delete RequestStop::default_instance_;
  delete RequestStop_Request::default_instance_;
  delete RequestStop_Confirm::default_instance_;
  delete GetTransactions::default_instance_;
  delete GetTransactions_Request::default_instance_;
  delete GetTransactions_Confirm::default_instance_;
  delete UpgradeFirmware::default_instance_;
  delete UpgradeFirmware_Request::default_instance_;
  delete UpgradeFirmware_Confirm::default_instance_;
  delete SetConfiguration::default_instance_;
  delete SetConfiguration_Request::default_instance_;
  delete SetConfiguration_Confirm::default_instance_;
  delete SetPricing::default_instance_;
  delete SetPricing_Request::default_instance_;
  delete SetPricing_Confirm::default_instance_;
  delete Reset::default_instance_;
  delete Reset_Request::default_instance_;
  delete Reset_Confirm::default_instance_;
  delete ParkLock::default_instance_;
  delete ParkLock_Request::default_instance_;
  delete ParkLock_Confirm::default_instance_;
  delete Authorize::default_instance_;
  delete Authorize_Request::default_instance_;
  delete Authorize_Confirm::default_instance_;
  delete TransactionStarted::default_instance_;
  delete TransactionStarted_Request::default_instance_;
  delete TransactionStarted_Confirm::default_instance_;
  delete TransactionStopped::default_instance_;
  delete TransactionStopped_Request::default_instance_;
  delete TransactionStopped_Confirm::default_instance_;
  delete TransactionRecords::default_instance_;
  delete TransactionRecords_Request::default_instance_;
  delete TransactionRecords_Confirm::default_instance_;
  delete MeasureValue::default_instance_;
  delete Measure::default_instance_;
  delete Measure_Request::default_instance_;
  delete Measure_Confirm::default_instance_;
  delete BootNotification::default_instance_;
  delete BootNotification_Request::default_instance_;
  delete BootNotification_Confirm::default_instance_;
  delete StatusNotification::default_instance_;
  delete FirmwareStatusNotifcation::default_instance_;
  delete SensorStatusNotification::default_instance_;
  delete Consumption::default_instance_;
  delete GetCost::default_instance_;
  delete GetCost_Request::default_instance_;
  delete GetCost_Confirm::default_instance_;
  delete LoginGW::default_instance_;
  delete LoginGW_Request::default_instance_;
  delete LoginGW_Confirm::default_instance_;
  delete HeartbeatGW::default_instance_;
  delete HeartbeatGW_Request::default_instance_;
  delete HeartbeatGW_Confirm::default_instance_;
  delete NetstatGW::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_cl_5fmessage_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_cl_5fmessage_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Base::default_instance_ = new Base();
  CallError::default_instance_ = new CallError();
  IdToken::default_instance_ = new IdToken();
  IdTagInfo::default_instance_ = new IdTagInfo();
  Transactions::default_instance_ = new Transactions();
  Tariff::default_instance_ = new Tariff();
  PriceScheme::default_instance_ = new PriceScheme();
  ConfigOption::default_instance_ = new ConfigOption();
  ConfigSection::default_instance_ = new ConfigSection();
  RequestStart::default_instance_ = new RequestStart();
  RequestStart_Request::default_instance_ = new RequestStart_Request();
  RequestStart_Confirm::default_instance_ = new RequestStart_Confirm();
  RequestStop::default_instance_ = new RequestStop();
  RequestStop_Request::default_instance_ = new RequestStop_Request();
  RequestStop_Confirm::default_instance_ = new RequestStop_Confirm();
  GetTransactions::default_instance_ = new GetTransactions();
  GetTransactions_Request::default_instance_ = new GetTransactions_Request();
  GetTransactions_Confirm::default_instance_ = new GetTransactions_Confirm();
  UpgradeFirmware::default_instance_ = new UpgradeFirmware();
  UpgradeFirmware_Request::default_instance_ = new UpgradeFirmware_Request();
  UpgradeFirmware_Confirm::default_instance_ = new UpgradeFirmware_Confirm();
  SetConfiguration::default_instance_ = new SetConfiguration();
  SetConfiguration_Request::default_instance_ = new SetConfiguration_Request();
  SetConfiguration_Confirm::default_instance_ = new SetConfiguration_Confirm();
  SetPricing::default_instance_ = new SetPricing();
  SetPricing_Request::default_instance_ = new SetPricing_Request();
  SetPricing_Confirm::default_instance_ = new SetPricing_Confirm();
  Reset::default_instance_ = new Reset();
  Reset_Request::default_instance_ = new Reset_Request();
  Reset_Confirm::default_instance_ = new Reset_Confirm();
  ParkLock::default_instance_ = new ParkLock();
  ParkLock_Request::default_instance_ = new ParkLock_Request();
  ParkLock_Confirm::default_instance_ = new ParkLock_Confirm();
  Authorize::default_instance_ = new Authorize();
  Authorize_Request::default_instance_ = new Authorize_Request();
  Authorize_Confirm::default_instance_ = new Authorize_Confirm();
  TransactionStarted::default_instance_ = new TransactionStarted();
  TransactionStarted_Request::default_instance_ = new TransactionStarted_Request();
  TransactionStarted_Confirm::default_instance_ = new TransactionStarted_Confirm();
  TransactionStopped::default_instance_ = new TransactionStopped();
  TransactionStopped_Request::default_instance_ = new TransactionStopped_Request();
  TransactionStopped_Confirm::default_instance_ = new TransactionStopped_Confirm();
  TransactionRecords::default_instance_ = new TransactionRecords();
  TransactionRecords_Request::default_instance_ = new TransactionRecords_Request();
  TransactionRecords_Confirm::default_instance_ = new TransactionRecords_Confirm();
  MeasureValue::default_instance_ = new MeasureValue();
  Measure::default_instance_ = new Measure();
  Measure_Request::default_instance_ = new Measure_Request();
  Measure_Confirm::default_instance_ = new Measure_Confirm();
  BootNotification::default_instance_ = new BootNotification();
  BootNotification_Request::default_instance_ = new BootNotification_Request();
  BootNotification_Confirm::default_instance_ = new BootNotification_Confirm();
  StatusNotification::default_instance_ = new StatusNotification();
  FirmwareStatusNotifcation::default_instance_ = new FirmwareStatusNotifcation();
  SensorStatusNotification::default_instance_ = new SensorStatusNotification();
  Consumption::default_instance_ = new Consumption();
  GetCost::default_instance_ = new GetCost();
  GetCost_Request::default_instance_ = new GetCost_Request();
  GetCost_Confirm::default_instance_ = new GetCost_Confirm();
  LoginGW::default_instance_ = new LoginGW();
  LoginGW_Request::default_instance_ = new LoginGW_Request();
  LoginGW_Confirm::default_instance_ = new LoginGW_Confirm();
  HeartbeatGW::default_instance_ = new HeartbeatGW();
  HeartbeatGW_Request::default_instance_ = new HeartbeatGW_Request();
  HeartbeatGW_Confirm::default_instance_ = new HeartbeatGW_Confirm();
  NetstatGW::default_instance_ = new NetstatGW();
  Base::default_instance_->InitAsDefaultInstance();
  CallError::default_instance_->InitAsDefaultInstance();
  IdToken::default_instance_->InitAsDefaultInstance();
  IdTagInfo::default_instance_->InitAsDefaultInstance();
  Transactions::default_instance_->InitAsDefaultInstance();
  Tariff::default_instance_->InitAsDefaultInstance();
  PriceScheme::default_instance_->InitAsDefaultInstance();
  ConfigOption::default_instance_->InitAsDefaultInstance();
  ConfigSection::default_instance_->InitAsDefaultInstance();
  RequestStart::default_instance_->InitAsDefaultInstance();
  RequestStart_Request::default_instance_->InitAsDefaultInstance();
  RequestStart_Confirm::default_instance_->InitAsDefaultInstance();
  RequestStop::default_instance_->InitAsDefaultInstance();
  RequestStop_Request::default_instance_->InitAsDefaultInstance();
  RequestStop_Confirm::default_instance_->InitAsDefaultInstance();
  GetTransactions::default_instance_->InitAsDefaultInstance();
  GetTransactions_Request::default_instance_->InitAsDefaultInstance();
  GetTransactions_Confirm::default_instance_->InitAsDefaultInstance();
  UpgradeFirmware::default_instance_->InitAsDefaultInstance();
  UpgradeFirmware_Request::default_instance_->InitAsDefaultInstance();
  UpgradeFirmware_Confirm::default_instance_->InitAsDefaultInstance();
  SetConfiguration::default_instance_->InitAsDefaultInstance();
  SetConfiguration_Request::default_instance_->InitAsDefaultInstance();
  SetConfiguration_Confirm::default_instance_->InitAsDefaultInstance();
  SetPricing::default_instance_->InitAsDefaultInstance();
  SetPricing_Request::default_instance_->InitAsDefaultInstance();
  SetPricing_Confirm::default_instance_->InitAsDefaultInstance();
  Reset::default_instance_->InitAsDefaultInstance();
  Reset_Request::default_instance_->InitAsDefaultInstance();
  Reset_Confirm::default_instance_->InitAsDefaultInstance();
  ParkLock::default_instance_->InitAsDefaultInstance();
  ParkLock_Request::default_instance_->InitAsDefaultInstance();
  ParkLock_Confirm::default_instance_->InitAsDefaultInstance();
  Authorize::default_instance_->InitAsDefaultInstance();
  Authorize_Request::default_instance_->InitAsDefaultInstance();
  Authorize_Confirm::default_instance_->InitAsDefaultInstance();
  TransactionStarted::default_instance_->InitAsDefaultInstance();
  TransactionStarted_Request::default_instance_->InitAsDefaultInstance();
  TransactionStarted_Confirm::default_instance_->InitAsDefaultInstance();
  TransactionStopped::default_instance_->InitAsDefaultInstance();
  TransactionStopped_Request::default_instance_->InitAsDefaultInstance();
  TransactionStopped_Confirm::default_instance_->InitAsDefaultInstance();
  TransactionRecords::default_instance_->InitAsDefaultInstance();
  TransactionRecords_Request::default_instance_->InitAsDefaultInstance();
  TransactionRecords_Confirm::default_instance_->InitAsDefaultInstance();
  MeasureValue::default_instance_->InitAsDefaultInstance();
  Measure::default_instance_->InitAsDefaultInstance();
  Measure_Request::default_instance_->InitAsDefaultInstance();
  Measure_Confirm::default_instance_->InitAsDefaultInstance();
  BootNotification::default_instance_->InitAsDefaultInstance();
  BootNotification_Request::default_instance_->InitAsDefaultInstance();
  BootNotification_Confirm::default_instance_->InitAsDefaultInstance();
  StatusNotification::default_instance_->InitAsDefaultInstance();
  FirmwareStatusNotifcation::default_instance_->InitAsDefaultInstance();
  SensorStatusNotification::default_instance_->InitAsDefaultInstance();
  Consumption::default_instance_->InitAsDefaultInstance();
  GetCost::default_instance_->InitAsDefaultInstance();
  GetCost_Request::default_instance_->InitAsDefaultInstance();
  GetCost_Confirm::default_instance_->InitAsDefaultInstance();
  LoginGW::default_instance_->InitAsDefaultInstance();
  LoginGW_Request::default_instance_->InitAsDefaultInstance();
  LoginGW_Confirm::default_instance_->InitAsDefaultInstance();
  HeartbeatGW::default_instance_->InitAsDefaultInstance();
  HeartbeatGW_Request::default_instance_->InitAsDefaultInstance();
  HeartbeatGW_Confirm::default_instance_->InitAsDefaultInstance();
  NetstatGW::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_cl_5fmessage_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_cl_5fmessage_2eproto_once_);
void protobuf_AddDesc_cl_5fmessage_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_cl_5fmessage_2eproto_once_,
                 &protobuf_AddDesc_cl_5fmessage_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_cl_5fmessage_2eproto {
  StaticDescriptorInitializer_cl_5fmessage_2eproto() {
    protobuf_AddDesc_cl_5fmessage_2eproto();
  }
} static_descriptor_initializer_cl_5fmessage_2eproto_;
#endif
bool MSG_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 257:
    case 258:
    case 259:
    case 260:
      return true;
    default:
      return false;
  }
}

bool IdType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

bool ChargerStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool FirmwareStatus_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

bool AuthorizationStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

bool PricingUnit_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Base::kLengthFieldNumber;
const int Base::kCmdFieldNumber;
const int Base::kTimestampFieldNumber;
const int Base::kPayloadFieldNumber;
#endif  // !_MSC_VER

Base::Base()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Base::InitAsDefaultInstance() {
}

Base::Base(const Base& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Base::SharedCtor() {
  _cached_size_ = 0;
  length_ = 0;
  cmd_ = 0u;
  timestamp_ = 0u;
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Base::~Base() {
  SharedDtor();
}

void Base::SharedDtor() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Base::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Base& Base::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

Base* Base::default_instance_ = NULL;

Base* Base::New() const {
  return new Base;
}

void Base::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    length_ = 0;
    cmd_ = 0u;
    timestamp_ = 0u;
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Base::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 length = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &length_)));
          set_has_length();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_cmd;
        break;
      }

      // required fixed32 cmd = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_cmd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &cmd_)));
          set_has_cmd();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_timestamp;
        break;
      }

      // required fixed32 timestamp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_payload;
        break;
      }

      // optional bytes payload = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Base::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 length = 1;
  if (has_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->length(), output);
  }

  // required fixed32 cmd = 2;
  if (has_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(2, this->cmd(), output);
  }

  // required fixed32 timestamp = 3;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(3, this->timestamp(), output);
  }

  // optional bytes payload = 4;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->payload(), output);
  }

}

int Base::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 length = 1;
    if (has_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->length());
    }

    // required fixed32 cmd = 2;
    if (has_cmd()) {
      total_size += 1 + 4;
    }

    // required fixed32 timestamp = 3;
    if (has_timestamp()) {
      total_size += 1 + 4;
    }

    // optional bytes payload = 4;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Base::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Base*>(&from));
}

void Base::MergeFrom(const Base& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_length()) {
      set_length(from.length());
    }
    if (from.has_cmd()) {
      set_cmd(from.cmd());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
  }
}

void Base::CopyFrom(const Base& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Base::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Base::Swap(Base* other) {
  if (other != this) {
    std::swap(length_, other->length_);
    std::swap(cmd_, other->cmd_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(payload_, other->payload_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Base::GetTypeName() const {
  return "cl_message.Base";
}


// ===================================================================

bool CallError_ErrorCode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const CallError_ErrorCode CallError::NOT_IMPLEMENTED;
const CallError_ErrorCode CallError::NOT_SUPPORTED;
const CallError_ErrorCode CallError::INTERNAL_ERROR;
const CallError_ErrorCode CallError::PROTOCOL_ERROR;
const CallError_ErrorCode CallError::SECURITY_ERROR;
const CallError_ErrorCode CallError::FORMATION_VIOLATION;
const CallError_ErrorCode CallError::PROPERTY_CONSTRAINT_VIOLATION;
const CallError_ErrorCode CallError::OCCURENCE_CONSTRAINT_VIOLATION;
const CallError_ErrorCode CallError::TYPE_CONSTRAINT_VIOLATION;
const CallError_ErrorCode CallError::GENERIC_ERROR;
const CallError_ErrorCode CallError::ErrorCode_MIN;
const CallError_ErrorCode CallError::ErrorCode_MAX;
const int CallError::ErrorCode_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int CallError::kErrorCodeFieldNumber;
const int CallError::kErrorDescFieldNumber;
const int CallError::kErrorDetailsFieldNumber;
#endif  // !_MSC_VER

CallError::CallError()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CallError::InitAsDefaultInstance() {
}

CallError::CallError(const CallError& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CallError::SharedCtor() {
  _cached_size_ = 0;
  error_code_ = 0;
  error_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  error_details_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CallError::~CallError() {
  SharedDtor();
}

void CallError::SharedDtor() {
  if (error_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete error_desc_;
  }
  if (error_details_ != &::google::protobuf::internal::kEmptyString) {
    delete error_details_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CallError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CallError& CallError::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

CallError* CallError::default_instance_ = NULL;

CallError* CallError::New() const {
  return new CallError;
}

void CallError::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_code_ = 0;
    if (has_error_desc()) {
      if (error_desc_ != &::google::protobuf::internal::kEmptyString) {
        error_desc_->clear();
      }
    }
    if (has_error_details()) {
      if (error_details_ != &::google::protobuf::internal::kEmptyString) {
        error_details_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CallError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .cl_message.CallError.ErrorCode error_code = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cl_message::CallError_ErrorCode_IsValid(value)) {
            set_error_code(static_cast< ::cl_message::CallError_ErrorCode >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_error_desc;
        break;
      }

      // optional string error_desc = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_error_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_error_desc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_error_details;
        break;
      }

      // optional string error_details = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_error_details:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_error_details()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CallError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .cl_message.CallError.ErrorCode error_code = 2;
  if (has_error_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->error_code(), output);
  }

  // optional string error_desc = 3;
  if (has_error_desc()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->error_desc(), output);
  }

  // optional string error_details = 4;
  if (has_error_details()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->error_details(), output);
  }

}

int CallError::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .cl_message.CallError.ErrorCode error_code = 2;
    if (has_error_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->error_code());
    }

    // optional string error_desc = 3;
    if (has_error_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->error_desc());
    }

    // optional string error_details = 4;
    if (has_error_details()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->error_details());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CallError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CallError*>(&from));
}

void CallError::MergeFrom(const CallError& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error_code()) {
      set_error_code(from.error_code());
    }
    if (from.has_error_desc()) {
      set_error_desc(from.error_desc());
    }
    if (from.has_error_details()) {
      set_error_details(from.error_details());
    }
  }
}

void CallError::CopyFrom(const CallError& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CallError::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CallError::Swap(CallError* other) {
  if (other != this) {
    std::swap(error_code_, other->error_code_);
    std::swap(error_desc_, other->error_desc_);
    std::swap(error_details_, other->error_details_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CallError::GetTypeName() const {
  return "cl_message.CallError";
}


// ===================================================================

#ifndef _MSC_VER
const int IdToken::kIdFieldNumber;
const int IdToken::kIdTypeFieldNumber;
#endif  // !_MSC_VER

IdToken::IdToken()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IdToken::InitAsDefaultInstance() {
}

IdToken::IdToken(const IdToken& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IdToken::SharedCtor() {
  _cached_size_ = 0;
  id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  id_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IdToken::~IdToken() {
  SharedDtor();
}

void IdToken::SharedDtor() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IdToken::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IdToken& IdToken::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

IdToken* IdToken::default_instance_ = NULL;

IdToken* IdToken::New() const {
  return new IdToken;
}

void IdToken::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id()) {
      if (id_ != &::google::protobuf::internal::kEmptyString) {
        id_->clear();
      }
    }
    id_type_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IdToken::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id_type;
        break;
      }

      // optional .cl_message.IdType id_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cl_message::IdType_IsValid(value)) {
            set_id_type(static_cast< ::cl_message::IdType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IdToken::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->id(), output);
  }

  // optional .cl_message.IdType id_type = 2;
  if (has_id_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->id_type(), output);
  }

}

int IdToken::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->id());
    }

    // optional .cl_message.IdType id_type = 2;
    if (has_id_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->id_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IdToken::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IdToken*>(&from));
}

void IdToken::MergeFrom(const IdToken& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_id_type()) {
      set_id_type(from.id_type());
    }
  }
}

void IdToken::CopyFrom(const IdToken& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IdToken::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void IdToken::Swap(IdToken* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(id_type_, other->id_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IdToken::GetTypeName() const {
  return "cl_message.IdToken";
}


// ===================================================================

#ifndef _MSC_VER
const int IdTagInfo::kExpiryDateFieldNumber;
const int IdTagInfo::kGroupIdFieldNumber;
const int IdTagInfo::kStatusFieldNumber;
#endif  // !_MSC_VER

IdTagInfo::IdTagInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void IdTagInfo::InitAsDefaultInstance() {
}

IdTagInfo::IdTagInfo(const IdTagInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void IdTagInfo::SharedCtor() {
  _cached_size_ = 0;
  expiry_date_ = 0;
  group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IdTagInfo::~IdTagInfo() {
  SharedDtor();
}

void IdTagInfo::SharedDtor() {
  if (group_id_ != &::google::protobuf::internal::kEmptyString) {
    delete group_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IdTagInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IdTagInfo& IdTagInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

IdTagInfo* IdTagInfo::default_instance_ = NULL;

IdTagInfo* IdTagInfo::New() const {
  return new IdTagInfo;
}

void IdTagInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    expiry_date_ = 0;
    if (has_group_id()) {
      if (group_id_ != &::google::protobuf::internal::kEmptyString) {
        group_id_->clear();
      }
    }
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool IdTagInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 expiry_date = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &expiry_date_)));
          set_has_expiry_date();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_group_id;
        break;
      }

      // optional string group_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_group_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group_id()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_status;
        break;
      }

      // required .cl_message.AuthorizationStatus status = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cl_message::AuthorizationStatus_IsValid(value)) {
            set_status(static_cast< ::cl_message::AuthorizationStatus >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IdTagInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 expiry_date = 1;
  if (has_expiry_date()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->expiry_date(), output);
  }

  // optional string group_id = 2;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->group_id(), output);
  }

  // required .cl_message.AuthorizationStatus status = 3;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->status(), output);
  }

}

int IdTagInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 expiry_date = 1;
    if (has_expiry_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->expiry_date());
    }

    // optional string group_id = 2;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group_id());
    }

    // required .cl_message.AuthorizationStatus status = 3;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IdTagInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IdTagInfo*>(&from));
}

void IdTagInfo::MergeFrom(const IdTagInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_expiry_date()) {
      set_expiry_date(from.expiry_date());
    }
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
}

void IdTagInfo::CopyFrom(const IdTagInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IdTagInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  return true;
}

void IdTagInfo::Swap(IdTagInfo* other) {
  if (other != this) {
    std::swap(expiry_date_, other->expiry_date_);
    std::swap(group_id_, other->group_id_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IdTagInfo::GetTypeName() const {
  return "cl_message.IdTagInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int Transactions::kTransactionIdFieldNumber;
const int Transactions::kConnectorIdFieldNumber;
const int Transactions::kIdTagFieldNumber;
const int Transactions::kMeterStartFieldNumber;
const int Transactions::kMeterStopFieldNumber;
const int Transactions::kTimeStartFieldNumber;
const int Transactions::kTimeStopFieldNumber;
const int Transactions::kPriceSchemeFieldNumber;
const int Transactions::kStopReasonFieldNumber;
const int Transactions::kTimeSpentChargingFieldNumber;
#endif  // !_MSC_VER

Transactions::Transactions()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Transactions::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_tag_ = const_cast< ::cl_message::IdToken*>(
      ::cl_message::IdToken::internal_default_instance());
#else
  id_tag_ = const_cast< ::cl_message::IdToken*>(&::cl_message::IdToken::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  price_scheme_ = const_cast< ::cl_message::PriceScheme*>(
      ::cl_message::PriceScheme::internal_default_instance());
#else
  price_scheme_ = const_cast< ::cl_message::PriceScheme*>(&::cl_message::PriceScheme::default_instance());
#endif
}

Transactions::Transactions(const Transactions& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Transactions::SharedCtor() {
  _cached_size_ = 0;
  transaction_id_ = GOOGLE_ULONGLONG(0);
  connector_id_ = 0;
  id_tag_ = NULL;
  meter_start_ = 0;
  meter_stop_ = 0;
  time_start_ = 0;
  time_stop_ = 0;
  price_scheme_ = NULL;
  stop_reason_ = 0;
  time_spent_charging_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Transactions::~Transactions() {
  SharedDtor();
}

void Transactions::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete id_tag_;
    delete price_scheme_;
  }
}

void Transactions::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Transactions& Transactions::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

Transactions* Transactions::default_instance_ = NULL;

Transactions* Transactions::New() const {
  return new Transactions;
}

void Transactions::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    transaction_id_ = GOOGLE_ULONGLONG(0);
    connector_id_ = 0;
    if (has_id_tag()) {
      if (id_tag_ != NULL) id_tag_->::cl_message::IdToken::Clear();
    }
    meter_start_ = 0;
    meter_stop_ = 0;
    time_start_ = 0;
    time_stop_ = 0;
    if (has_price_scheme()) {
      if (price_scheme_ != NULL) price_scheme_->::cl_message::PriceScheme::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    stop_reason_ = 0;
    time_spent_charging_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Transactions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 transaction_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &transaction_id_)));
          set_has_transaction_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_connector_id;
        break;
      }

      // optional int32 connector_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_connector_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &connector_id_)));
          set_has_connector_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_id_tag;
        break;
      }

      // required .cl_message.IdToken id_tag = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_id_tag:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id_tag()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_meter_start;
        break;
      }

      // required int32 meter_start = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_meter_start:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &meter_start_)));
          set_has_meter_start();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_meter_stop;
        break;
      }

      // required int32 meter_stop = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_meter_stop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &meter_stop_)));
          set_has_meter_stop();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_time_start;
        break;
      }

      // required int32 time_start = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time_start:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &time_start_)));
          set_has_time_start();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_time_stop;
        break;
      }

      // required int32 time_stop = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time_stop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &time_stop_)));
          set_has_time_stop();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_price_scheme;
        break;
      }

      // optional .cl_message.PriceScheme price_scheme = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_price_scheme:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_price_scheme()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_stop_reason;
        break;
      }

      // required int32 stop_reason = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_stop_reason:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &stop_reason_)));
          set_has_stop_reason();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_time_spent_charging;
        break;
      }

      // optional int32 time_spent_charging = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time_spent_charging:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &time_spent_charging_)));
          set_has_time_spent_charging();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Transactions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 transaction_id = 1;
  if (has_transaction_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->transaction_id(), output);
  }

  // optional int32 connector_id = 2;
  if (has_connector_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->connector_id(), output);
  }

  // required .cl_message.IdToken id_tag = 3;
  if (has_id_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->id_tag(), output);
  }

  // required int32 meter_start = 4;
  if (has_meter_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->meter_start(), output);
  }

  // required int32 meter_stop = 5;
  if (has_meter_stop()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->meter_stop(), output);
  }

  // required int32 time_start = 6;
  if (has_time_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->time_start(), output);
  }

  // required int32 time_stop = 7;
  if (has_time_stop()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->time_stop(), output);
  }

  // optional .cl_message.PriceScheme price_scheme = 8;
  if (has_price_scheme()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->price_scheme(), output);
  }

  // required int32 stop_reason = 9;
  if (has_stop_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->stop_reason(), output);
  }

  // optional int32 time_spent_charging = 10;
  if (has_time_spent_charging()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->time_spent_charging(), output);
  }

}

int Transactions::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 transaction_id = 1;
    if (has_transaction_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->transaction_id());
    }

    // optional int32 connector_id = 2;
    if (has_connector_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->connector_id());
    }

    // required .cl_message.IdToken id_tag = 3;
    if (has_id_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id_tag());
    }

    // required int32 meter_start = 4;
    if (has_meter_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->meter_start());
    }

    // required int32 meter_stop = 5;
    if (has_meter_stop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->meter_stop());
    }

    // required int32 time_start = 6;
    if (has_time_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->time_start());
    }

    // required int32 time_stop = 7;
    if (has_time_stop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->time_stop());
    }

    // optional .cl_message.PriceScheme price_scheme = 8;
    if (has_price_scheme()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->price_scheme());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required int32 stop_reason = 9;
    if (has_stop_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->stop_reason());
    }

    // optional int32 time_spent_charging = 10;
    if (has_time_spent_charging()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->time_spent_charging());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Transactions::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Transactions*>(&from));
}

void Transactions::MergeFrom(const Transactions& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_transaction_id()) {
      set_transaction_id(from.transaction_id());
    }
    if (from.has_connector_id()) {
      set_connector_id(from.connector_id());
    }
    if (from.has_id_tag()) {
      mutable_id_tag()->::cl_message::IdToken::MergeFrom(from.id_tag());
    }
    if (from.has_meter_start()) {
      set_meter_start(from.meter_start());
    }
    if (from.has_meter_stop()) {
      set_meter_stop(from.meter_stop());
    }
    if (from.has_time_start()) {
      set_time_start(from.time_start());
    }
    if (from.has_time_stop()) {
      set_time_stop(from.time_stop());
    }
    if (from.has_price_scheme()) {
      mutable_price_scheme()->::cl_message::PriceScheme::MergeFrom(from.price_scheme());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_stop_reason()) {
      set_stop_reason(from.stop_reason());
    }
    if (from.has_time_spent_charging()) {
      set_time_spent_charging(from.time_spent_charging());
    }
  }
}

void Transactions::CopyFrom(const Transactions& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Transactions::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000017c) != 0x0000017c) return false;

  if (has_id_tag()) {
    if (!this->id_tag().IsInitialized()) return false;
  }
  if (has_price_scheme()) {
    if (!this->price_scheme().IsInitialized()) return false;
  }
  return true;
}

void Transactions::Swap(Transactions* other) {
  if (other != this) {
    std::swap(transaction_id_, other->transaction_id_);
    std::swap(connector_id_, other->connector_id_);
    std::swap(id_tag_, other->id_tag_);
    std::swap(meter_start_, other->meter_start_);
    std::swap(meter_stop_, other->meter_stop_);
    std::swap(time_start_, other->time_start_);
    std::swap(time_stop_, other->time_stop_);
    std::swap(price_scheme_, other->price_scheme_);
    std::swap(stop_reason_, other->stop_reason_);
    std::swap(time_spent_charging_, other->time_spent_charging_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Transactions::GetTypeName() const {
  return "cl_message.Transactions";
}


// ===================================================================

#ifndef _MSC_VER
const int Tariff::kTariffidFieldNumber;
const int Tariff::kDisplayTextFieldNumber;
const int Tariff::kPriceUnitFieldNumber;
const int Tariff::kPriceFieldNumber;
#endif  // !_MSC_VER

Tariff::Tariff()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Tariff::InitAsDefaultInstance() {
}

Tariff::Tariff(const Tariff& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Tariff::SharedCtor() {
  _cached_size_ = 0;
  tariffid_ = 0;
  display_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  price_unit_ = 0;
  price_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Tariff::~Tariff() {
  SharedDtor();
}

void Tariff::SharedDtor() {
  if (display_text_ != &::google::protobuf::internal::kEmptyString) {
    delete display_text_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Tariff::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Tariff& Tariff::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

Tariff* Tariff::default_instance_ = NULL;

Tariff* Tariff::New() const {
  return new Tariff;
}

void Tariff::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tariffid_ = 0;
    if (has_display_text()) {
      if (display_text_ != &::google::protobuf::internal::kEmptyString) {
        display_text_->clear();
      }
    }
    price_unit_ = 0;
    price_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Tariff::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 tariffid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tariffid_)));
          set_has_tariffid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_display_text;
        break;
      }

      // optional string display_text = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_display_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_display_text()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_price_unit;
        break;
      }

      // optional .cl_message.PricingUnit price_unit = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_price_unit:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cl_message::PricingUnit_IsValid(value)) {
            set_price_unit(static_cast< ::cl_message::PricingUnit >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_price;
        break;
      }

      // required int32 price = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Tariff::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 tariffid = 1;
  if (has_tariffid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->tariffid(), output);
  }

  // optional string display_text = 2;
  if (has_display_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->display_text(), output);
  }

  // optional .cl_message.PricingUnit price_unit = 3;
  if (has_price_unit()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->price_unit(), output);
  }

  // required int32 price = 4;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->price(), output);
  }

}

int Tariff::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 tariffid = 1;
    if (has_tariffid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tariffid());
    }

    // optional string display_text = 2;
    if (has_display_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->display_text());
    }

    // optional .cl_message.PricingUnit price_unit = 3;
    if (has_price_unit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->price_unit());
    }

    // required int32 price = 4;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->price());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Tariff::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Tariff*>(&from));
}

void Tariff::MergeFrom(const Tariff& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tariffid()) {
      set_tariffid(from.tariffid());
    }
    if (from.has_display_text()) {
      set_display_text(from.display_text());
    }
    if (from.has_price_unit()) {
      set_price_unit(from.price_unit());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
  }
}

void Tariff::CopyFrom(const Tariff& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Tariff::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;

  return true;
}

void Tariff::Swap(Tariff* other) {
  if (other != this) {
    std::swap(tariffid_, other->tariffid_);
    std::swap(display_text_, other->display_text_);
    std::swap(price_unit_, other->price_unit_);
    std::swap(price_, other->price_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Tariff::GetTypeName() const {
  return "cl_message.Tariff";
}


// ===================================================================

#ifndef _MSC_VER
const int PriceScheme::kPriceSchemeIdFieldNumber;
const int PriceScheme::kDisplayTextFieldNumber;
const int PriceScheme::kExpiryDateFieldNumber;
const int PriceScheme::kTariffFieldNumber;
#endif  // !_MSC_VER

PriceScheme::PriceScheme()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PriceScheme::InitAsDefaultInstance() {
}

PriceScheme::PriceScheme(const PriceScheme& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PriceScheme::SharedCtor() {
  _cached_size_ = 0;
  price_scheme_id_ = 0;
  display_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  expiry_date_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PriceScheme::~PriceScheme() {
  SharedDtor();
}

void PriceScheme::SharedDtor() {
  if (display_text_ != &::google::protobuf::internal::kEmptyString) {
    delete display_text_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PriceScheme::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PriceScheme& PriceScheme::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

PriceScheme* PriceScheme::default_instance_ = NULL;

PriceScheme* PriceScheme::New() const {
  return new PriceScheme;
}

void PriceScheme::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    price_scheme_id_ = 0;
    if (has_display_text()) {
      if (display_text_ != &::google::protobuf::internal::kEmptyString) {
        display_text_->clear();
      }
    }
    expiry_date_ = 0;
  }
  tariff_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PriceScheme::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 price_scheme_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &price_scheme_id_)));
          set_has_price_scheme_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_display_text;
        break;
      }

      // optional string display_text = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_display_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_display_text()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_expiry_date;
        break;
      }

      // optional int32 expiry_date = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_expiry_date:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &expiry_date_)));
          set_has_expiry_date();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_tariff;
        break;
      }

      // repeated .cl_message.Tariff tariff = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tariff:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tariff()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_tariff;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PriceScheme::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 price_scheme_id = 1;
  if (has_price_scheme_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->price_scheme_id(), output);
  }

  // optional string display_text = 2;
  if (has_display_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->display_text(), output);
  }

  // optional int32 expiry_date = 3;
  if (has_expiry_date()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->expiry_date(), output);
  }

  // repeated .cl_message.Tariff tariff = 4;
  for (int i = 0; i < this->tariff_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->tariff(i), output);
  }

}

int PriceScheme::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 price_scheme_id = 1;
    if (has_price_scheme_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->price_scheme_id());
    }

    // optional string display_text = 2;
    if (has_display_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->display_text());
    }

    // optional int32 expiry_date = 3;
    if (has_expiry_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->expiry_date());
    }

  }
  // repeated .cl_message.Tariff tariff = 4;
  total_size += 1 * this->tariff_size();
  for (int i = 0; i < this->tariff_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tariff(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PriceScheme::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PriceScheme*>(&from));
}

void PriceScheme::MergeFrom(const PriceScheme& from) {
  GOOGLE_CHECK_NE(&from, this);
  tariff_.MergeFrom(from.tariff_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_price_scheme_id()) {
      set_price_scheme_id(from.price_scheme_id());
    }
    if (from.has_display_text()) {
      set_display_text(from.display_text());
    }
    if (from.has_expiry_date()) {
      set_expiry_date(from.expiry_date());
    }
  }
}

void PriceScheme::CopyFrom(const PriceScheme& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PriceScheme::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < tariff_size(); i++) {
    if (!this->tariff(i).IsInitialized()) return false;
  }
  return true;
}

void PriceScheme::Swap(PriceScheme* other) {
  if (other != this) {
    std::swap(price_scheme_id_, other->price_scheme_id_);
    std::swap(display_text_, other->display_text_);
    std::swap(expiry_date_, other->expiry_date_);
    tariff_.Swap(&other->tariff_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PriceScheme::GetTypeName() const {
  return "cl_message.PriceScheme";
}


// ===================================================================

#ifndef _MSC_VER
const int ConfigOption::kNameFieldNumber;
const int ConfigOption::kValueFieldNumber;
#endif  // !_MSC_VER

ConfigOption::ConfigOption()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ConfigOption::InitAsDefaultInstance() {
}

ConfigOption::ConfigOption(const ConfigOption& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ConfigOption::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConfigOption::~ConfigOption() {
  SharedDtor();
}

void ConfigOption::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ConfigOption::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConfigOption& ConfigOption::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

ConfigOption* ConfigOption::default_instance_ = NULL;

ConfigOption* ConfigOption::New() const {
  return new ConfigOption;
}

void ConfigOption::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::kEmptyString) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ConfigOption::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // required string value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ConfigOption::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->value(), output);
  }

}

int ConfigOption::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConfigOption::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConfigOption*>(&from));
}

void ConfigOption::MergeFrom(const ConfigOption& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ConfigOption::CopyFrom(const ConfigOption& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigOption::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ConfigOption::Swap(ConfigOption* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConfigOption::GetTypeName() const {
  return "cl_message.ConfigOption";
}


// ===================================================================

#ifndef _MSC_VER
const int ConfigSection::kSectionFieldNumber;
const int ConfigSection::kNameFieldNumber;
const int ConfigSection::kValueFieldNumber;
const int ConfigSection::kOptionsFieldNumber;
#endif  // !_MSC_VER

ConfigSection::ConfigSection()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ConfigSection::InitAsDefaultInstance() {
}

ConfigSection::ConfigSection(const ConfigSection& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ConfigSection::SharedCtor() {
  _cached_size_ = 0;
  section_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConfigSection::~ConfigSection() {
  SharedDtor();
}

void ConfigSection::SharedDtor() {
  if (section_ != &::google::protobuf::internal::kEmptyString) {
    delete section_;
  }
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ConfigSection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConfigSection& ConfigSection::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

ConfigSection* ConfigSection::default_instance_ = NULL;

ConfigSection* ConfigSection::New() const {
  return new ConfigSection;
}

void ConfigSection::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_section()) {
      if (section_ != &::google::protobuf::internal::kEmptyString) {
        section_->clear();
      }
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    value_ = 0;
  }
  options_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ConfigSection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string section = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_section()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_value;
        break;
      }

      // optional int32 value = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_options;
        break;
      }

      // repeated .cl_message.ConfigOption options = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_options:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_options()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_options;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ConfigSection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string section = 1;
  if (has_section()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->section(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional int32 value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->value(), output);
  }

  // repeated .cl_message.ConfigOption options = 4;
  for (int i = 0; i < this->options_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->options(i), output);
  }

}

int ConfigSection::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string section = 1;
    if (has_section()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->section());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->value());
    }

  }
  // repeated .cl_message.ConfigOption options = 4;
  total_size += 1 * this->options_size();
  for (int i = 0; i < this->options_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->options(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConfigSection::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConfigSection*>(&from));
}

void ConfigSection::MergeFrom(const ConfigSection& from) {
  GOOGLE_CHECK_NE(&from, this);
  options_.MergeFrom(from.options_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_section()) {
      set_section(from.section());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
}

void ConfigSection::CopyFrom(const ConfigSection& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigSection::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < options_size(); i++) {
    if (!this->options(i).IsInitialized()) return false;
  }
  return true;
}

void ConfigSection::Swap(ConfigSection* other) {
  if (other != this) {
    std::swap(section_, other->section_);
    std::swap(name_, other->name_);
    std::swap(value_, other->value_);
    options_.Swap(&other->options_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ConfigSection::GetTypeName() const {
  return "cl_message.ConfigSection";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestStart_Request::kConnectorIdFieldNumber;
const int RequestStart_Request::kIdTagFieldNumber;
const int RequestStart_Request::kPinCodeFieldNumber;
const int RequestStart_Request::kTransparentFieldNumber;
#endif  // !_MSC_VER

RequestStart_Request::RequestStart_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestStart_Request::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_tag_ = const_cast< ::cl_message::IdToken*>(
      ::cl_message::IdToken::internal_default_instance());
#else
  id_tag_ = const_cast< ::cl_message::IdToken*>(&::cl_message::IdToken::default_instance());
#endif
}

RequestStart_Request::RequestStart_Request(const RequestStart_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestStart_Request::SharedCtor() {
  _cached_size_ = 0;
  connector_id_ = 0;
  id_tag_ = NULL;
  pin_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  transparent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestStart_Request::~RequestStart_Request() {
  SharedDtor();
}

void RequestStart_Request::SharedDtor() {
  if (pin_code_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_code_;
  }
  if (transparent_ != &::google::protobuf::internal::kEmptyString) {
    delete transparent_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete id_tag_;
  }
}

void RequestStart_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestStart_Request& RequestStart_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

RequestStart_Request* RequestStart_Request::default_instance_ = NULL;

RequestStart_Request* RequestStart_Request::New() const {
  return new RequestStart_Request;
}

void RequestStart_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    connector_id_ = 0;
    if (has_id_tag()) {
      if (id_tag_ != NULL) id_tag_->::cl_message::IdToken::Clear();
    }
    if (has_pin_code()) {
      if (pin_code_ != &::google::protobuf::internal::kEmptyString) {
        pin_code_->clear();
      }
    }
    if (has_transparent()) {
      if (transparent_ != &::google::protobuf::internal::kEmptyString) {
        transparent_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestStart_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 connector_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &connector_id_)));
          set_has_connector_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_id_tag;
        break;
      }

      // required .cl_message.IdToken id_tag = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_id_tag:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id_tag()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_pin_code;
        break;
      }

      // optional string pin_code = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pin_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pin_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_transparent;
        break;
      }

      // optional string transparent = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transparent:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_transparent()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestStart_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 connector_id = 1;
  if (has_connector_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->connector_id(), output);
  }

  // required .cl_message.IdToken id_tag = 2;
  if (has_id_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->id_tag(), output);
  }

  // optional string pin_code = 3;
  if (has_pin_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->pin_code(), output);
  }

  // optional string transparent = 4;
  if (has_transparent()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->transparent(), output);
  }

}

int RequestStart_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 connector_id = 1;
    if (has_connector_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->connector_id());
    }

    // required .cl_message.IdToken id_tag = 2;
    if (has_id_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id_tag());
    }

    // optional string pin_code = 3;
    if (has_pin_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pin_code());
    }

    // optional string transparent = 4;
    if (has_transparent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->transparent());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestStart_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestStart_Request*>(&from));
}

void RequestStart_Request::MergeFrom(const RequestStart_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_connector_id()) {
      set_connector_id(from.connector_id());
    }
    if (from.has_id_tag()) {
      mutable_id_tag()->::cl_message::IdToken::MergeFrom(from.id_tag());
    }
    if (from.has_pin_code()) {
      set_pin_code(from.pin_code());
    }
    if (from.has_transparent()) {
      set_transparent(from.transparent());
    }
  }
}

void RequestStart_Request::CopyFrom(const RequestStart_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestStart_Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (has_id_tag()) {
    if (!this->id_tag().IsInitialized()) return false;
  }
  return true;
}

void RequestStart_Request::Swap(RequestStart_Request* other) {
  if (other != this) {
    std::swap(connector_id_, other->connector_id_);
    std::swap(id_tag_, other->id_tag_);
    std::swap(pin_code_, other->pin_code_);
    std::swap(transparent_, other->transparent_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestStart_Request::GetTypeName() const {
  return "cl_message.RequestStart.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int RequestStart_Confirm::kStatusFieldNumber;
#endif  // !_MSC_VER

RequestStart_Confirm::RequestStart_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestStart_Confirm::InitAsDefaultInstance() {
}

RequestStart_Confirm::RequestStart_Confirm(const RequestStart_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestStart_Confirm::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestStart_Confirm::~RequestStart_Confirm() {
  SharedDtor();
}

void RequestStart_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestStart_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestStart_Confirm& RequestStart_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

RequestStart_Confirm* RequestStart_Confirm::default_instance_ = NULL;

RequestStart_Confirm* RequestStart_Confirm::New() const {
  return new RequestStart_Confirm;
}

void RequestStart_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestStart_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestStart_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

}

int RequestStart_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestStart_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestStart_Confirm*>(&from));
}

void RequestStart_Confirm::MergeFrom(const RequestStart_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
  }
}

void RequestStart_Confirm::CopyFrom(const RequestStart_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestStart_Confirm::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestStart_Confirm::Swap(RequestStart_Confirm* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestStart_Confirm::GetTypeName() const {
  return "cl_message.RequestStart.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int RequestStart::kReqFieldNumber;
const int RequestStart::kConfFieldNumber;
#endif  // !_MSC_VER

RequestStart::RequestStart()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestStart::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::RequestStart_Request*>(
      ::cl_message::RequestStart_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::RequestStart_Request*>(&::cl_message::RequestStart_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::RequestStart_Confirm*>(
      ::cl_message::RequestStart_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::RequestStart_Confirm*>(&::cl_message::RequestStart_Confirm::default_instance());
#endif
}

RequestStart::RequestStart(const RequestStart& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestStart::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestStart::~RequestStart() {
  SharedDtor();
}

void RequestStart::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void RequestStart::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestStart& RequestStart::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

RequestStart* RequestStart::default_instance_ = NULL;

RequestStart* RequestStart::New() const {
  return new RequestStart;
}

void RequestStart::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::RequestStart_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::RequestStart_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestStart::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.RequestStart.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.RequestStart.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestStart::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.RequestStart.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.RequestStart.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int RequestStart::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.RequestStart.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.RequestStart.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestStart::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestStart*>(&from));
}

void RequestStart::MergeFrom(const RequestStart& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::RequestStart_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::RequestStart_Confirm::MergeFrom(from.conf());
    }
  }
}

void RequestStart::CopyFrom(const RequestStart& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestStart::IsInitialized() const {

  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  if (has_conf()) {
    if (!this->conf().IsInitialized()) return false;
  }
  return true;
}

void RequestStart::Swap(RequestStart* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestStart::GetTypeName() const {
  return "cl_message.RequestStart";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestStop_Request::kTransactionIdFieldNumber;
#endif  // !_MSC_VER

RequestStop_Request::RequestStop_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestStop_Request::InitAsDefaultInstance() {
}

RequestStop_Request::RequestStop_Request(const RequestStop_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestStop_Request::SharedCtor() {
  _cached_size_ = 0;
  transaction_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestStop_Request::~RequestStop_Request() {
  SharedDtor();
}

void RequestStop_Request::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestStop_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestStop_Request& RequestStop_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

RequestStop_Request* RequestStop_Request::default_instance_ = NULL;

RequestStop_Request* RequestStop_Request::New() const {
  return new RequestStop_Request;
}

void RequestStop_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    transaction_id_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestStop_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 transaction_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &transaction_id_)));
          set_has_transaction_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestStop_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 transaction_id = 1;
  if (has_transaction_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->transaction_id(), output);
  }

}

int RequestStop_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 transaction_id = 1;
    if (has_transaction_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->transaction_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestStop_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestStop_Request*>(&from));
}

void RequestStop_Request::MergeFrom(const RequestStop_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_transaction_id()) {
      set_transaction_id(from.transaction_id());
    }
  }
}

void RequestStop_Request::CopyFrom(const RequestStop_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestStop_Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestStop_Request::Swap(RequestStop_Request* other) {
  if (other != this) {
    std::swap(transaction_id_, other->transaction_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestStop_Request::GetTypeName() const {
  return "cl_message.RequestStop.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int RequestStop_Confirm::kStatusFieldNumber;
#endif  // !_MSC_VER

RequestStop_Confirm::RequestStop_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestStop_Confirm::InitAsDefaultInstance() {
}

RequestStop_Confirm::RequestStop_Confirm(const RequestStop_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestStop_Confirm::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestStop_Confirm::~RequestStop_Confirm() {
  SharedDtor();
}

void RequestStop_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestStop_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestStop_Confirm& RequestStop_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

RequestStop_Confirm* RequestStop_Confirm::default_instance_ = NULL;

RequestStop_Confirm* RequestStop_Confirm::New() const {
  return new RequestStop_Confirm;
}

void RequestStop_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestStop_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestStop_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

}

int RequestStop_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestStop_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestStop_Confirm*>(&from));
}

void RequestStop_Confirm::MergeFrom(const RequestStop_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
  }
}

void RequestStop_Confirm::CopyFrom(const RequestStop_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestStop_Confirm::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RequestStop_Confirm::Swap(RequestStop_Confirm* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestStop_Confirm::GetTypeName() const {
  return "cl_message.RequestStop.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int RequestStop::kReqFieldNumber;
const int RequestStop::kConfFieldNumber;
#endif  // !_MSC_VER

RequestStop::RequestStop()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestStop::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::RequestStop_Request*>(
      ::cl_message::RequestStop_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::RequestStop_Request*>(&::cl_message::RequestStop_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::RequestStop_Confirm*>(
      ::cl_message::RequestStop_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::RequestStop_Confirm*>(&::cl_message::RequestStop_Confirm::default_instance());
#endif
}

RequestStop::RequestStop(const RequestStop& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestStop::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestStop::~RequestStop() {
  SharedDtor();
}

void RequestStop::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void RequestStop::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestStop& RequestStop::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

RequestStop* RequestStop::default_instance_ = NULL;

RequestStop* RequestStop::New() const {
  return new RequestStop;
}

void RequestStop::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::RequestStop_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::RequestStop_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestStop::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.RequestStop.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.RequestStop.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestStop::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.RequestStop.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.RequestStop.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int RequestStop::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.RequestStop.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.RequestStop.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestStop::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestStop*>(&from));
}

void RequestStop::MergeFrom(const RequestStop& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::RequestStop_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::RequestStop_Confirm::MergeFrom(from.conf());
    }
  }
}

void RequestStop::CopyFrom(const RequestStop& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestStop::IsInitialized() const {

  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  if (has_conf()) {
    if (!this->conf().IsInitialized()) return false;
  }
  return true;
}

void RequestStop::Swap(RequestStop* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestStop::GetTypeName() const {
  return "cl_message.RequestStop";
}


// ===================================================================

#ifndef _MSC_VER
const int GetTransactions_Request::kStartTimeFieldNumber;
const int GetTransactions_Request::kEndTimeFieldNumber;
const int GetTransactions_Request::kPosFieldNumber;
const int GetTransactions_Request::kCountFieldNumber;
#endif  // !_MSC_VER

GetTransactions_Request::GetTransactions_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetTransactions_Request::InitAsDefaultInstance() {
}

GetTransactions_Request::GetTransactions_Request(const GetTransactions_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetTransactions_Request::SharedCtor() {
  _cached_size_ = 0;
  start_time_ = 0;
  end_time_ = 0;
  pos_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetTransactions_Request::~GetTransactions_Request() {
  SharedDtor();
}

void GetTransactions_Request::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetTransactions_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetTransactions_Request& GetTransactions_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

GetTransactions_Request* GetTransactions_Request::default_instance_ = NULL;

GetTransactions_Request* GetTransactions_Request::New() const {
  return new GetTransactions_Request;
}

void GetTransactions_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    start_time_ = 0;
    end_time_ = 0;
    pos_ = 0;
    count_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetTransactions_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 start_time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &start_time_)));
          set_has_start_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_end_time;
        break;
      }

      // optional int32 end_time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &end_time_)));
          set_has_end_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_pos;
        break;
      }

      // optional int32 pos = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pos_)));
          set_has_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_count;
        break;
      }

      // optional int32 count = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetTransactions_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 start_time = 1;
  if (has_start_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->start_time(), output);
  }

  // optional int32 end_time = 2;
  if (has_end_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->end_time(), output);
  }

  // optional int32 pos = 3;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->pos(), output);
  }

  // optional int32 count = 4;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->count(), output);
  }

}

int GetTransactions_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 start_time = 1;
    if (has_start_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->start_time());
    }

    // optional int32 end_time = 2;
    if (has_end_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->end_time());
    }

    // optional int32 pos = 3;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pos());
    }

    // optional int32 count = 4;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetTransactions_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetTransactions_Request*>(&from));
}

void GetTransactions_Request::MergeFrom(const GetTransactions_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start_time()) {
      set_start_time(from.start_time());
    }
    if (from.has_end_time()) {
      set_end_time(from.end_time());
    }
    if (from.has_pos()) {
      set_pos(from.pos());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
}

void GetTransactions_Request::CopyFrom(const GetTransactions_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTransactions_Request::IsInitialized() const {

  return true;
}

void GetTransactions_Request::Swap(GetTransactions_Request* other) {
  if (other != this) {
    std::swap(start_time_, other->start_time_);
    std::swap(end_time_, other->end_time_);
    std::swap(pos_, other->pos_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetTransactions_Request::GetTypeName() const {
  return "cl_message.GetTransactions.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int GetTransactions_Confirm::kCountFieldNumber;
#endif  // !_MSC_VER

GetTransactions_Confirm::GetTransactions_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetTransactions_Confirm::InitAsDefaultInstance() {
}

GetTransactions_Confirm::GetTransactions_Confirm(const GetTransactions_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetTransactions_Confirm::SharedCtor() {
  _cached_size_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetTransactions_Confirm::~GetTransactions_Confirm() {
  SharedDtor();
}

void GetTransactions_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetTransactions_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetTransactions_Confirm& GetTransactions_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

GetTransactions_Confirm* GetTransactions_Confirm::default_instance_ = NULL;

GetTransactions_Confirm* GetTransactions_Confirm::New() const {
  return new GetTransactions_Confirm;
}

void GetTransactions_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    count_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetTransactions_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetTransactions_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 count = 1;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->count(), output);
  }

}

int GetTransactions_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 count = 1;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetTransactions_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetTransactions_Confirm*>(&from));
}

void GetTransactions_Confirm::MergeFrom(const GetTransactions_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_count()) {
      set_count(from.count());
    }
  }
}

void GetTransactions_Confirm::CopyFrom(const GetTransactions_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTransactions_Confirm::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetTransactions_Confirm::Swap(GetTransactions_Confirm* other) {
  if (other != this) {
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetTransactions_Confirm::GetTypeName() const {
  return "cl_message.GetTransactions.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int GetTransactions::kReqFieldNumber;
const int GetTransactions::kConfFieldNumber;
#endif  // !_MSC_VER

GetTransactions::GetTransactions()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetTransactions::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::GetTransactions_Request*>(
      ::cl_message::GetTransactions_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::GetTransactions_Request*>(&::cl_message::GetTransactions_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::GetTransactions_Confirm*>(
      ::cl_message::GetTransactions_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::GetTransactions_Confirm*>(&::cl_message::GetTransactions_Confirm::default_instance());
#endif
}

GetTransactions::GetTransactions(const GetTransactions& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetTransactions::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetTransactions::~GetTransactions() {
  SharedDtor();
}

void GetTransactions::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void GetTransactions::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetTransactions& GetTransactions::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

GetTransactions* GetTransactions::default_instance_ = NULL;

GetTransactions* GetTransactions::New() const {
  return new GetTransactions;
}

void GetTransactions::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::GetTransactions_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::GetTransactions_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetTransactions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.GetTransactions.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.GetTransactions.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetTransactions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.GetTransactions.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.GetTransactions.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int GetTransactions::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.GetTransactions.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.GetTransactions.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetTransactions::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetTransactions*>(&from));
}

void GetTransactions::MergeFrom(const GetTransactions& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::GetTransactions_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::GetTransactions_Confirm::MergeFrom(from.conf());
    }
  }
}

void GetTransactions::CopyFrom(const GetTransactions& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTransactions::IsInitialized() const {

  if (has_conf()) {
    if (!this->conf().IsInitialized()) return false;
  }
  return true;
}

void GetTransactions::Swap(GetTransactions* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetTransactions::GetTypeName() const {
  return "cl_message.GetTransactions";
}


// ===================================================================

#ifndef _MSC_VER
const int UpgradeFirmware_Request::kLocationFieldNumber;
const int UpgradeFirmware_Request::kMd5FieldNumber;
const int UpgradeFirmware_Request::kRetriesFieldNumber;
const int UpgradeFirmware_Request::kRetrieveDateFieldNumber;
const int UpgradeFirmware_Request::kRetryIntervalFieldNumber;
#endif  // !_MSC_VER

UpgradeFirmware_Request::UpgradeFirmware_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpgradeFirmware_Request::InitAsDefaultInstance() {
}

UpgradeFirmware_Request::UpgradeFirmware_Request(const UpgradeFirmware_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpgradeFirmware_Request::SharedCtor() {
  _cached_size_ = 0;
  location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  retries_ = 0;
  retrieve_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  retry_interval_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpgradeFirmware_Request::~UpgradeFirmware_Request() {
  SharedDtor();
}

void UpgradeFirmware_Request::SharedDtor() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (md5_ != &::google::protobuf::internal::kEmptyString) {
    delete md5_;
  }
  if (retrieve_date_ != &::google::protobuf::internal::kEmptyString) {
    delete retrieve_date_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpgradeFirmware_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpgradeFirmware_Request& UpgradeFirmware_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

UpgradeFirmware_Request* UpgradeFirmware_Request::default_instance_ = NULL;

UpgradeFirmware_Request* UpgradeFirmware_Request::New() const {
  return new UpgradeFirmware_Request;
}

void UpgradeFirmware_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_location()) {
      if (location_ != &::google::protobuf::internal::kEmptyString) {
        location_->clear();
      }
    }
    if (has_md5()) {
      if (md5_ != &::google::protobuf::internal::kEmptyString) {
        md5_->clear();
      }
    }
    retries_ = 0;
    if (has_retrieve_date()) {
      if (retrieve_date_ != &::google::protobuf::internal::kEmptyString) {
        retrieve_date_->clear();
      }
    }
    retry_interval_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpgradeFirmware_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string location = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_location()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_md5;
        break;
      }

      // required string md5 = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_md5:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_md5()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_retries;
        break;
      }

      // optional int32 retries = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_retries:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &retries_)));
          set_has_retries();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_retrieve_date;
        break;
      }

      // optional string retrieve_date = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_retrieve_date:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_retrieve_date()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_retry_interval;
        break;
      }

      // optional int32 retry_interval = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_retry_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &retry_interval_)));
          set_has_retry_interval();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpgradeFirmware_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string location = 1;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->location(), output);
  }

  // required string md5 = 2;
  if (has_md5()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->md5(), output);
  }

  // optional int32 retries = 3;
  if (has_retries()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->retries(), output);
  }

  // optional string retrieve_date = 4;
  if (has_retrieve_date()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->retrieve_date(), output);
  }

  // optional int32 retry_interval = 5;
  if (has_retry_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->retry_interval(), output);
  }

}

int UpgradeFirmware_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string location = 1;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->location());
    }

    // required string md5 = 2;
    if (has_md5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->md5());
    }

    // optional int32 retries = 3;
    if (has_retries()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->retries());
    }

    // optional string retrieve_date = 4;
    if (has_retrieve_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->retrieve_date());
    }

    // optional int32 retry_interval = 5;
    if (has_retry_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->retry_interval());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpgradeFirmware_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpgradeFirmware_Request*>(&from));
}

void UpgradeFirmware_Request::MergeFrom(const UpgradeFirmware_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_location()) {
      set_location(from.location());
    }
    if (from.has_md5()) {
      set_md5(from.md5());
    }
    if (from.has_retries()) {
      set_retries(from.retries());
    }
    if (from.has_retrieve_date()) {
      set_retrieve_date(from.retrieve_date());
    }
    if (from.has_retry_interval()) {
      set_retry_interval(from.retry_interval());
    }
  }
}

void UpgradeFirmware_Request::CopyFrom(const UpgradeFirmware_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpgradeFirmware_Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void UpgradeFirmware_Request::Swap(UpgradeFirmware_Request* other) {
  if (other != this) {
    std::swap(location_, other->location_);
    std::swap(md5_, other->md5_);
    std::swap(retries_, other->retries_);
    std::swap(retrieve_date_, other->retrieve_date_);
    std::swap(retry_interval_, other->retry_interval_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpgradeFirmware_Request::GetTypeName() const {
  return "cl_message.UpgradeFirmware.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int UpgradeFirmware_Confirm::kStatusFieldNumber;
#endif  // !_MSC_VER

UpgradeFirmware_Confirm::UpgradeFirmware_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpgradeFirmware_Confirm::InitAsDefaultInstance() {
}

UpgradeFirmware_Confirm::UpgradeFirmware_Confirm(const UpgradeFirmware_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpgradeFirmware_Confirm::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpgradeFirmware_Confirm::~UpgradeFirmware_Confirm() {
  SharedDtor();
}

void UpgradeFirmware_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpgradeFirmware_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpgradeFirmware_Confirm& UpgradeFirmware_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

UpgradeFirmware_Confirm* UpgradeFirmware_Confirm::default_instance_ = NULL;

UpgradeFirmware_Confirm* UpgradeFirmware_Confirm::New() const {
  return new UpgradeFirmware_Confirm;
}

void UpgradeFirmware_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpgradeFirmware_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpgradeFirmware_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

}

int UpgradeFirmware_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpgradeFirmware_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpgradeFirmware_Confirm*>(&from));
}

void UpgradeFirmware_Confirm::MergeFrom(const UpgradeFirmware_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
  }
}

void UpgradeFirmware_Confirm::CopyFrom(const UpgradeFirmware_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpgradeFirmware_Confirm::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UpgradeFirmware_Confirm::Swap(UpgradeFirmware_Confirm* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpgradeFirmware_Confirm::GetTypeName() const {
  return "cl_message.UpgradeFirmware.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int UpgradeFirmware::kReqFieldNumber;
const int UpgradeFirmware::kConfFieldNumber;
#endif  // !_MSC_VER

UpgradeFirmware::UpgradeFirmware()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpgradeFirmware::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::UpgradeFirmware_Request*>(
      ::cl_message::UpgradeFirmware_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::UpgradeFirmware_Request*>(&::cl_message::UpgradeFirmware_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::UpgradeFirmware_Confirm*>(
      ::cl_message::UpgradeFirmware_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::UpgradeFirmware_Confirm*>(&::cl_message::UpgradeFirmware_Confirm::default_instance());
#endif
}

UpgradeFirmware::UpgradeFirmware(const UpgradeFirmware& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpgradeFirmware::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpgradeFirmware::~UpgradeFirmware() {
  SharedDtor();
}

void UpgradeFirmware::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void UpgradeFirmware::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpgradeFirmware& UpgradeFirmware::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

UpgradeFirmware* UpgradeFirmware::default_instance_ = NULL;

UpgradeFirmware* UpgradeFirmware::New() const {
  return new UpgradeFirmware;
}

void UpgradeFirmware::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::UpgradeFirmware_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::UpgradeFirmware_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpgradeFirmware::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.UpgradeFirmware.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.UpgradeFirmware.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpgradeFirmware::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.UpgradeFirmware.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.UpgradeFirmware.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int UpgradeFirmware::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.UpgradeFirmware.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.UpgradeFirmware.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpgradeFirmware::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpgradeFirmware*>(&from));
}

void UpgradeFirmware::MergeFrom(const UpgradeFirmware& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::UpgradeFirmware_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::UpgradeFirmware_Confirm::MergeFrom(from.conf());
    }
  }
}

void UpgradeFirmware::CopyFrom(const UpgradeFirmware& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpgradeFirmware::IsInitialized() const {

  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  if (has_conf()) {
    if (!this->conf().IsInitialized()) return false;
  }
  return true;
}

void UpgradeFirmware::Swap(UpgradeFirmware* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpgradeFirmware::GetTypeName() const {
  return "cl_message.UpgradeFirmware";
}


// ===================================================================

#ifndef _MSC_VER
const int SetConfiguration_Request::kFilenameFieldNumber;
const int SetConfiguration_Request::kSectionsFieldNumber;
#endif  // !_MSC_VER

SetConfiguration_Request::SetConfiguration_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SetConfiguration_Request::InitAsDefaultInstance() {
}

SetConfiguration_Request::SetConfiguration_Request(const SetConfiguration_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SetConfiguration_Request::SharedCtor() {
  _cached_size_ = 0;
  filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetConfiguration_Request::~SetConfiguration_Request() {
  SharedDtor();
}

void SetConfiguration_Request::SharedDtor() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SetConfiguration_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SetConfiguration_Request& SetConfiguration_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

SetConfiguration_Request* SetConfiguration_Request::default_instance_ = NULL;

SetConfiguration_Request* SetConfiguration_Request::New() const {
  return new SetConfiguration_Request;
}

void SetConfiguration_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_filename()) {
      if (filename_ != &::google::protobuf::internal::kEmptyString) {
        filename_->clear();
      }
    }
  }
  sections_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SetConfiguration_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string filename = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filename()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_sections;
        break;
      }

      // repeated .cl_message.ConfigSection sections = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sections:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sections()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_sections;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SetConfiguration_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string filename = 1;
  if (has_filename()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->filename(), output);
  }

  // repeated .cl_message.ConfigSection sections = 2;
  for (int i = 0; i < this->sections_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->sections(i), output);
  }

}

int SetConfiguration_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string filename = 1;
    if (has_filename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filename());
    }

  }
  // repeated .cl_message.ConfigSection sections = 2;
  total_size += 1 * this->sections_size();
  for (int i = 0; i < this->sections_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sections(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetConfiguration_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SetConfiguration_Request*>(&from));
}

void SetConfiguration_Request::MergeFrom(const SetConfiguration_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  sections_.MergeFrom(from.sections_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filename()) {
      set_filename(from.filename());
    }
  }
}

void SetConfiguration_Request::CopyFrom(const SetConfiguration_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetConfiguration_Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < sections_size(); i++) {
    if (!this->sections(i).IsInitialized()) return false;
  }
  return true;
}

void SetConfiguration_Request::Swap(SetConfiguration_Request* other) {
  if (other != this) {
    std::swap(filename_, other->filename_);
    sections_.Swap(&other->sections_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SetConfiguration_Request::GetTypeName() const {
  return "cl_message.SetConfiguration.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SetConfiguration_Confirm::kStatusFieldNumber;
#endif  // !_MSC_VER

SetConfiguration_Confirm::SetConfiguration_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SetConfiguration_Confirm::InitAsDefaultInstance() {
}

SetConfiguration_Confirm::SetConfiguration_Confirm(const SetConfiguration_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SetConfiguration_Confirm::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetConfiguration_Confirm::~SetConfiguration_Confirm() {
  SharedDtor();
}

void SetConfiguration_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SetConfiguration_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SetConfiguration_Confirm& SetConfiguration_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

SetConfiguration_Confirm* SetConfiguration_Confirm::default_instance_ = NULL;

SetConfiguration_Confirm* SetConfiguration_Confirm::New() const {
  return new SetConfiguration_Confirm;
}

void SetConfiguration_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SetConfiguration_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SetConfiguration_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

}

int SetConfiguration_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetConfiguration_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SetConfiguration_Confirm*>(&from));
}

void SetConfiguration_Confirm::MergeFrom(const SetConfiguration_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
  }
}

void SetConfiguration_Confirm::CopyFrom(const SetConfiguration_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetConfiguration_Confirm::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SetConfiguration_Confirm::Swap(SetConfiguration_Confirm* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SetConfiguration_Confirm::GetTypeName() const {
  return "cl_message.SetConfiguration.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SetConfiguration::kReqFieldNumber;
const int SetConfiguration::kConfFieldNumber;
#endif  // !_MSC_VER

SetConfiguration::SetConfiguration()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SetConfiguration::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::SetConfiguration_Request*>(
      ::cl_message::SetConfiguration_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::SetConfiguration_Request*>(&::cl_message::SetConfiguration_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::SetConfiguration_Confirm*>(
      ::cl_message::SetConfiguration_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::SetConfiguration_Confirm*>(&::cl_message::SetConfiguration_Confirm::default_instance());
#endif
}

SetConfiguration::SetConfiguration(const SetConfiguration& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SetConfiguration::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetConfiguration::~SetConfiguration() {
  SharedDtor();
}

void SetConfiguration::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void SetConfiguration::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SetConfiguration& SetConfiguration::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

SetConfiguration* SetConfiguration::default_instance_ = NULL;

SetConfiguration* SetConfiguration::New() const {
  return new SetConfiguration;
}

void SetConfiguration::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::SetConfiguration_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::SetConfiguration_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SetConfiguration::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.SetConfiguration.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.SetConfiguration.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SetConfiguration::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.SetConfiguration.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.SetConfiguration.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int SetConfiguration::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.SetConfiguration.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.SetConfiguration.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetConfiguration::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SetConfiguration*>(&from));
}

void SetConfiguration::MergeFrom(const SetConfiguration& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::SetConfiguration_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::SetConfiguration_Confirm::MergeFrom(from.conf());
    }
  }
}

void SetConfiguration::CopyFrom(const SetConfiguration& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetConfiguration::IsInitialized() const {

  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  if (has_conf()) {
    if (!this->conf().IsInitialized()) return false;
  }
  return true;
}

void SetConfiguration::Swap(SetConfiguration* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SetConfiguration::GetTypeName() const {
  return "cl_message.SetConfiguration";
}


// ===================================================================

#ifndef _MSC_VER
const int SetPricing_Request::kPriceSchemeFieldNumber;
#endif  // !_MSC_VER

SetPricing_Request::SetPricing_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SetPricing_Request::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  price_scheme_ = const_cast< ::cl_message::PriceScheme*>(
      ::cl_message::PriceScheme::internal_default_instance());
#else
  price_scheme_ = const_cast< ::cl_message::PriceScheme*>(&::cl_message::PriceScheme::default_instance());
#endif
}

SetPricing_Request::SetPricing_Request(const SetPricing_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SetPricing_Request::SharedCtor() {
  _cached_size_ = 0;
  price_scheme_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetPricing_Request::~SetPricing_Request() {
  SharedDtor();
}

void SetPricing_Request::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete price_scheme_;
  }
}

void SetPricing_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SetPricing_Request& SetPricing_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

SetPricing_Request* SetPricing_Request::default_instance_ = NULL;

SetPricing_Request* SetPricing_Request::New() const {
  return new SetPricing_Request;
}

void SetPricing_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_price_scheme()) {
      if (price_scheme_ != NULL) price_scheme_->::cl_message::PriceScheme::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SetPricing_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .cl_message.PriceScheme price_scheme = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_price_scheme()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SetPricing_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .cl_message.PriceScheme price_scheme = 1;
  if (has_price_scheme()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->price_scheme(), output);
  }

}

int SetPricing_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .cl_message.PriceScheme price_scheme = 1;
    if (has_price_scheme()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->price_scheme());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetPricing_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SetPricing_Request*>(&from));
}

void SetPricing_Request::MergeFrom(const SetPricing_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_price_scheme()) {
      mutable_price_scheme()->::cl_message::PriceScheme::MergeFrom(from.price_scheme());
    }
  }
}

void SetPricing_Request::CopyFrom(const SetPricing_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetPricing_Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_price_scheme()) {
    if (!this->price_scheme().IsInitialized()) return false;
  }
  return true;
}

void SetPricing_Request::Swap(SetPricing_Request* other) {
  if (other != this) {
    std::swap(price_scheme_, other->price_scheme_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SetPricing_Request::GetTypeName() const {
  return "cl_message.SetPricing.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SetPricing_Confirm::kStatusFieldNumber;
#endif  // !_MSC_VER

SetPricing_Confirm::SetPricing_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SetPricing_Confirm::InitAsDefaultInstance() {
}

SetPricing_Confirm::SetPricing_Confirm(const SetPricing_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SetPricing_Confirm::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetPricing_Confirm::~SetPricing_Confirm() {
  SharedDtor();
}

void SetPricing_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SetPricing_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SetPricing_Confirm& SetPricing_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

SetPricing_Confirm* SetPricing_Confirm::default_instance_ = NULL;

SetPricing_Confirm* SetPricing_Confirm::New() const {
  return new SetPricing_Confirm;
}

void SetPricing_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SetPricing_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SetPricing_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

}

int SetPricing_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetPricing_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SetPricing_Confirm*>(&from));
}

void SetPricing_Confirm::MergeFrom(const SetPricing_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
  }
}

void SetPricing_Confirm::CopyFrom(const SetPricing_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetPricing_Confirm::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SetPricing_Confirm::Swap(SetPricing_Confirm* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SetPricing_Confirm::GetTypeName() const {
  return "cl_message.SetPricing.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int SetPricing::kReqFieldNumber;
const int SetPricing::kConfFieldNumber;
#endif  // !_MSC_VER

SetPricing::SetPricing()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SetPricing::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::SetPricing_Request*>(
      ::cl_message::SetPricing_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::SetPricing_Request*>(&::cl_message::SetPricing_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::SetPricing_Confirm*>(
      ::cl_message::SetPricing_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::SetPricing_Confirm*>(&::cl_message::SetPricing_Confirm::default_instance());
#endif
}

SetPricing::SetPricing(const SetPricing& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SetPricing::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetPricing::~SetPricing() {
  SharedDtor();
}

void SetPricing::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void SetPricing::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SetPricing& SetPricing::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

SetPricing* SetPricing::default_instance_ = NULL;

SetPricing* SetPricing::New() const {
  return new SetPricing;
}

void SetPricing::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::SetPricing_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::SetPricing_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SetPricing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.SetPricing.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.SetPricing.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SetPricing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.SetPricing.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.SetPricing.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int SetPricing::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.SetPricing.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.SetPricing.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetPricing::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SetPricing*>(&from));
}

void SetPricing::MergeFrom(const SetPricing& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::SetPricing_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::SetPricing_Confirm::MergeFrom(from.conf());
    }
  }
}

void SetPricing::CopyFrom(const SetPricing& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetPricing::IsInitialized() const {

  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  if (has_conf()) {
    if (!this->conf().IsInitialized()) return false;
  }
  return true;
}

void SetPricing::Swap(SetPricing* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SetPricing::GetTypeName() const {
  return "cl_message.SetPricing";
}


// ===================================================================

#ifndef _MSC_VER
const int Reset_Request::kResetTypeFieldNumber;
const int Reset_Request::kConnectorIdFieldNumber;
#endif  // !_MSC_VER

Reset_Request::Reset_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Reset_Request::InitAsDefaultInstance() {
}

Reset_Request::Reset_Request(const Reset_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Reset_Request::SharedCtor() {
  _cached_size_ = 0;
  reset_type_ = 0;
  connector_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Reset_Request::~Reset_Request() {
  SharedDtor();
}

void Reset_Request::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Reset_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Reset_Request& Reset_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

Reset_Request* Reset_Request::default_instance_ = NULL;

Reset_Request* Reset_Request::New() const {
  return new Reset_Request;
}

void Reset_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reset_type_ = 0;
    connector_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Reset_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 reset_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reset_type_)));
          set_has_reset_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_connector_id;
        break;
      }

      // optional int32 connector_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_connector_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &connector_id_)));
          set_has_connector_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Reset_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 reset_type = 1;
  if (has_reset_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reset_type(), output);
  }

  // optional int32 connector_id = 2;
  if (has_connector_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->connector_id(), output);
  }

}

int Reset_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 reset_type = 1;
    if (has_reset_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reset_type());
    }

    // optional int32 connector_id = 2;
    if (has_connector_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->connector_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Reset_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Reset_Request*>(&from));
}

void Reset_Request::MergeFrom(const Reset_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reset_type()) {
      set_reset_type(from.reset_type());
    }
    if (from.has_connector_id()) {
      set_connector_id(from.connector_id());
    }
  }
}

void Reset_Request::CopyFrom(const Reset_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reset_Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Reset_Request::Swap(Reset_Request* other) {
  if (other != this) {
    std::swap(reset_type_, other->reset_type_);
    std::swap(connector_id_, other->connector_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Reset_Request::GetTypeName() const {
  return "cl_message.Reset.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Reset_Confirm::kStatusFieldNumber;
#endif  // !_MSC_VER

Reset_Confirm::Reset_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Reset_Confirm::InitAsDefaultInstance() {
}

Reset_Confirm::Reset_Confirm(const Reset_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Reset_Confirm::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Reset_Confirm::~Reset_Confirm() {
  SharedDtor();
}

void Reset_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Reset_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Reset_Confirm& Reset_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

Reset_Confirm* Reset_Confirm::default_instance_ = NULL;

Reset_Confirm* Reset_Confirm::New() const {
  return new Reset_Confirm;
}

void Reset_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Reset_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Reset_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

}

int Reset_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Reset_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Reset_Confirm*>(&from));
}

void Reset_Confirm::MergeFrom(const Reset_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
  }
}

void Reset_Confirm::CopyFrom(const Reset_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reset_Confirm::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Reset_Confirm::Swap(Reset_Confirm* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Reset_Confirm::GetTypeName() const {
  return "cl_message.Reset.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Reset::kReqFieldNumber;
const int Reset::kConfFieldNumber;
#endif  // !_MSC_VER

Reset::Reset()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Reset::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::Reset_Request*>(
      ::cl_message::Reset_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::Reset_Request*>(&::cl_message::Reset_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::Reset_Confirm*>(
      ::cl_message::Reset_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::Reset_Confirm*>(&::cl_message::Reset_Confirm::default_instance());
#endif
}

Reset::Reset(const Reset& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Reset::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Reset::~Reset() {
  SharedDtor();
}

void Reset::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void Reset::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Reset& Reset::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

Reset* Reset::default_instance_ = NULL;

Reset* Reset::New() const {
  return new Reset;
}

void Reset::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::Reset_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::Reset_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Reset::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.Reset.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.Reset.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Reset::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.Reset.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.Reset.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int Reset::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.Reset.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.Reset.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Reset::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Reset*>(&from));
}

void Reset::MergeFrom(const Reset& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::Reset_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::Reset_Confirm::MergeFrom(from.conf());
    }
  }
}

void Reset::CopyFrom(const Reset& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reset::IsInitialized() const {

  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  if (has_conf()) {
    if (!this->conf().IsInitialized()) return false;
  }
  return true;
}

void Reset::Swap(Reset* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Reset::GetTypeName() const {
  return "cl_message.Reset";
}


// ===================================================================

#ifndef _MSC_VER
const int ParkLock_Request::kLockidFieldNumber;
const int ParkLock_Request::kLockFieldNumber;
#endif  // !_MSC_VER

ParkLock_Request::ParkLock_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ParkLock_Request::InitAsDefaultInstance() {
}

ParkLock_Request::ParkLock_Request(const ParkLock_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ParkLock_Request::SharedCtor() {
  _cached_size_ = 0;
  lockid_ = 0;
  lock_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ParkLock_Request::~ParkLock_Request() {
  SharedDtor();
}

void ParkLock_Request::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ParkLock_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ParkLock_Request& ParkLock_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

ParkLock_Request* ParkLock_Request::default_instance_ = NULL;

ParkLock_Request* ParkLock_Request::New() const {
  return new ParkLock_Request;
}

void ParkLock_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    lockid_ = 0;
    lock_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ParkLock_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 lockid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lockid_)));
          set_has_lockid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_lock;
        break;
      }

      // required int32 lock = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lock:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lock_)));
          set_has_lock();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ParkLock_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 lockid = 1;
  if (has_lockid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->lockid(), output);
  }

  // required int32 lock = 2;
  if (has_lock()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lock(), output);
  }

}

int ParkLock_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 lockid = 1;
    if (has_lockid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lockid());
    }

    // required int32 lock = 2;
    if (has_lock()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lock());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ParkLock_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ParkLock_Request*>(&from));
}

void ParkLock_Request::MergeFrom(const ParkLock_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_lockid()) {
      set_lockid(from.lockid());
    }
    if (from.has_lock()) {
      set_lock(from.lock());
    }
  }
}

void ParkLock_Request::CopyFrom(const ParkLock_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParkLock_Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ParkLock_Request::Swap(ParkLock_Request* other) {
  if (other != this) {
    std::swap(lockid_, other->lockid_);
    std::swap(lock_, other->lock_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ParkLock_Request::GetTypeName() const {
  return "cl_message.ParkLock.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ParkLock_Confirm::kStatusFieldNumber;
#endif  // !_MSC_VER

ParkLock_Confirm::ParkLock_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ParkLock_Confirm::InitAsDefaultInstance() {
}

ParkLock_Confirm::ParkLock_Confirm(const ParkLock_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ParkLock_Confirm::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ParkLock_Confirm::~ParkLock_Confirm() {
  SharedDtor();
}

void ParkLock_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ParkLock_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ParkLock_Confirm& ParkLock_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

ParkLock_Confirm* ParkLock_Confirm::default_instance_ = NULL;

ParkLock_Confirm* ParkLock_Confirm::New() const {
  return new ParkLock_Confirm;
}

void ParkLock_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ParkLock_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ParkLock_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

}

int ParkLock_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ParkLock_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ParkLock_Confirm*>(&from));
}

void ParkLock_Confirm::MergeFrom(const ParkLock_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
  }
}

void ParkLock_Confirm::CopyFrom(const ParkLock_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParkLock_Confirm::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ParkLock_Confirm::Swap(ParkLock_Confirm* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ParkLock_Confirm::GetTypeName() const {
  return "cl_message.ParkLock.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ParkLock::kReqFieldNumber;
const int ParkLock::kConfFieldNumber;
#endif  // !_MSC_VER

ParkLock::ParkLock()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ParkLock::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::ParkLock_Request*>(
      ::cl_message::ParkLock_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::ParkLock_Request*>(&::cl_message::ParkLock_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::ParkLock_Confirm*>(
      ::cl_message::ParkLock_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::ParkLock_Confirm*>(&::cl_message::ParkLock_Confirm::default_instance());
#endif
}

ParkLock::ParkLock(const ParkLock& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ParkLock::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ParkLock::~ParkLock() {
  SharedDtor();
}

void ParkLock::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void ParkLock::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ParkLock& ParkLock::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

ParkLock* ParkLock::default_instance_ = NULL;

ParkLock* ParkLock::New() const {
  return new ParkLock;
}

void ParkLock::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::ParkLock_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::ParkLock_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ParkLock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.ParkLock.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.ParkLock.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ParkLock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.ParkLock.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.ParkLock.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int ParkLock::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.ParkLock.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.ParkLock.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ParkLock::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ParkLock*>(&from));
}

void ParkLock::MergeFrom(const ParkLock& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::ParkLock_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::ParkLock_Confirm::MergeFrom(from.conf());
    }
  }
}

void ParkLock::CopyFrom(const ParkLock& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParkLock::IsInitialized() const {

  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  if (has_conf()) {
    if (!this->conf().IsInitialized()) return false;
  }
  return true;
}

void ParkLock::Swap(ParkLock* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ParkLock::GetTypeName() const {
  return "cl_message.ParkLock";
}


// ===================================================================

#ifndef _MSC_VER
const int Authorize_Request::kIdTagFieldNumber;
#endif  // !_MSC_VER

Authorize_Request::Authorize_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Authorize_Request::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_tag_ = const_cast< ::cl_message::IdToken*>(
      ::cl_message::IdToken::internal_default_instance());
#else
  id_tag_ = const_cast< ::cl_message::IdToken*>(&::cl_message::IdToken::default_instance());
#endif
}

Authorize_Request::Authorize_Request(const Authorize_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Authorize_Request::SharedCtor() {
  _cached_size_ = 0;
  id_tag_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Authorize_Request::~Authorize_Request() {
  SharedDtor();
}

void Authorize_Request::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete id_tag_;
  }
}

void Authorize_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Authorize_Request& Authorize_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

Authorize_Request* Authorize_Request::default_instance_ = NULL;

Authorize_Request* Authorize_Request::New() const {
  return new Authorize_Request;
}

void Authorize_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id_tag()) {
      if (id_tag_ != NULL) id_tag_->::cl_message::IdToken::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Authorize_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .cl_message.IdToken id_tag = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id_tag()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Authorize_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .cl_message.IdToken id_tag = 1;
  if (has_id_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->id_tag(), output);
  }

}

int Authorize_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .cl_message.IdToken id_tag = 1;
    if (has_id_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id_tag());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Authorize_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Authorize_Request*>(&from));
}

void Authorize_Request::MergeFrom(const Authorize_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id_tag()) {
      mutable_id_tag()->::cl_message::IdToken::MergeFrom(from.id_tag());
    }
  }
}

void Authorize_Request::CopyFrom(const Authorize_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Authorize_Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_id_tag()) {
    if (!this->id_tag().IsInitialized()) return false;
  }
  return true;
}

void Authorize_Request::Swap(Authorize_Request* other) {
  if (other != this) {
    std::swap(id_tag_, other->id_tag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Authorize_Request::GetTypeName() const {
  return "cl_message.Authorize.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Authorize_Confirm::kIdInfoFieldNumber;
const int Authorize_Confirm::kPriceSchemeIdFieldNumber;
#endif  // !_MSC_VER

Authorize_Confirm::Authorize_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Authorize_Confirm::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_info_ = const_cast< ::cl_message::IdTagInfo*>(
      ::cl_message::IdTagInfo::internal_default_instance());
#else
  id_info_ = const_cast< ::cl_message::IdTagInfo*>(&::cl_message::IdTagInfo::default_instance());
#endif
}

Authorize_Confirm::Authorize_Confirm(const Authorize_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Authorize_Confirm::SharedCtor() {
  _cached_size_ = 0;
  id_info_ = NULL;
  price_scheme_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Authorize_Confirm::~Authorize_Confirm() {
  SharedDtor();
}

void Authorize_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete id_info_;
  }
}

void Authorize_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Authorize_Confirm& Authorize_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

Authorize_Confirm* Authorize_Confirm::default_instance_ = NULL;

Authorize_Confirm* Authorize_Confirm::New() const {
  return new Authorize_Confirm;
}

void Authorize_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_id_info()) {
      if (id_info_ != NULL) id_info_->::cl_message::IdTagInfo::Clear();
    }
    price_scheme_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Authorize_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.IdTagInfo id_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_price_scheme_id;
        break;
      }

      // optional int32 price_scheme_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_price_scheme_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &price_scheme_id_)));
          set_has_price_scheme_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Authorize_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.IdTagInfo id_info = 1;
  if (has_id_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->id_info(), output);
  }

  // optional int32 price_scheme_id = 2;
  if (has_price_scheme_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->price_scheme_id(), output);
  }

}

int Authorize_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.IdTagInfo id_info = 1;
    if (has_id_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id_info());
    }

    // optional int32 price_scheme_id = 2;
    if (has_price_scheme_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->price_scheme_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Authorize_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Authorize_Confirm*>(&from));
}

void Authorize_Confirm::MergeFrom(const Authorize_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id_info()) {
      mutable_id_info()->::cl_message::IdTagInfo::MergeFrom(from.id_info());
    }
    if (from.has_price_scheme_id()) {
      set_price_scheme_id(from.price_scheme_id());
    }
  }
}

void Authorize_Confirm::CopyFrom(const Authorize_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Authorize_Confirm::IsInitialized() const {

  if (has_id_info()) {
    if (!this->id_info().IsInitialized()) return false;
  }
  return true;
}

void Authorize_Confirm::Swap(Authorize_Confirm* other) {
  if (other != this) {
    std::swap(id_info_, other->id_info_);
    std::swap(price_scheme_id_, other->price_scheme_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Authorize_Confirm::GetTypeName() const {
  return "cl_message.Authorize.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Authorize::kReqFieldNumber;
const int Authorize::kConfFieldNumber;
#endif  // !_MSC_VER

Authorize::Authorize()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Authorize::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::Authorize_Request*>(
      ::cl_message::Authorize_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::Authorize_Request*>(&::cl_message::Authorize_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::Authorize_Confirm*>(
      ::cl_message::Authorize_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::Authorize_Confirm*>(&::cl_message::Authorize_Confirm::default_instance());
#endif
}

Authorize::Authorize(const Authorize& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Authorize::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Authorize::~Authorize() {
  SharedDtor();
}

void Authorize::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void Authorize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Authorize& Authorize::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

Authorize* Authorize::default_instance_ = NULL;

Authorize* Authorize::New() const {
  return new Authorize;
}

void Authorize::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::Authorize_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::Authorize_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Authorize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.Authorize.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.Authorize.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Authorize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.Authorize.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.Authorize.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int Authorize::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.Authorize.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.Authorize.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Authorize::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Authorize*>(&from));
}

void Authorize::MergeFrom(const Authorize& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::Authorize_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::Authorize_Confirm::MergeFrom(from.conf());
    }
  }
}

void Authorize::CopyFrom(const Authorize& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Authorize::IsInitialized() const {

  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  if (has_conf()) {
    if (!this->conf().IsInitialized()) return false;
  }
  return true;
}

void Authorize::Swap(Authorize* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Authorize::GetTypeName() const {
  return "cl_message.Authorize";
}


// ===================================================================

#ifndef _MSC_VER
const int TransactionStarted_Request::kConnectorIdFieldNumber;
const int TransactionStarted_Request::kIdTagFieldNumber;
const int TransactionStarted_Request::kMeterStartFieldNumber;
const int TransactionStarted_Request::kTimestampFieldNumber;
const int TransactionStarted_Request::kPriceSchemeIdFieldNumber;
const int TransactionStarted_Request::kTransactionIdFieldNumber;
const int TransactionStarted_Request::kPinCodeFieldNumber;
const int TransactionStarted_Request::kTransparentFieldNumber;
#endif  // !_MSC_VER

TransactionStarted_Request::TransactionStarted_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TransactionStarted_Request::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_tag_ = const_cast< ::cl_message::IdToken*>(
      ::cl_message::IdToken::internal_default_instance());
#else
  id_tag_ = const_cast< ::cl_message::IdToken*>(&::cl_message::IdToken::default_instance());
#endif
}

TransactionStarted_Request::TransactionStarted_Request(const TransactionStarted_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TransactionStarted_Request::SharedCtor() {
  _cached_size_ = 0;
  connector_id_ = 0;
  id_tag_ = NULL;
  meter_start_ = 0;
  timestamp_ = 0;
  price_scheme_id_ = 0;
  transaction_id_ = GOOGLE_ULONGLONG(0);
  pin_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  transparent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionStarted_Request::~TransactionStarted_Request() {
  SharedDtor();
}

void TransactionStarted_Request::SharedDtor() {
  if (pin_code_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_code_;
  }
  if (transparent_ != &::google::protobuf::internal::kEmptyString) {
    delete transparent_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete id_tag_;
  }
}

void TransactionStarted_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransactionStarted_Request& TransactionStarted_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

TransactionStarted_Request* TransactionStarted_Request::default_instance_ = NULL;

TransactionStarted_Request* TransactionStarted_Request::New() const {
  return new TransactionStarted_Request;
}

void TransactionStarted_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    connector_id_ = 0;
    if (has_id_tag()) {
      if (id_tag_ != NULL) id_tag_->::cl_message::IdToken::Clear();
    }
    meter_start_ = 0;
    timestamp_ = 0;
    price_scheme_id_ = 0;
    transaction_id_ = GOOGLE_ULONGLONG(0);
    if (has_pin_code()) {
      if (pin_code_ != &::google::protobuf::internal::kEmptyString) {
        pin_code_->clear();
      }
    }
    if (has_transparent()) {
      if (transparent_ != &::google::protobuf::internal::kEmptyString) {
        transparent_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TransactionStarted_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 connector_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &connector_id_)));
          set_has_connector_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_id_tag;
        break;
      }

      // required .cl_message.IdToken id_tag = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_id_tag:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id_tag()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_meter_start;
        break;
      }

      // required int32 meter_start = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_meter_start:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &meter_start_)));
          set_has_meter_start();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_timestamp;
        break;
      }

      // required int32 timestamp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_price_scheme_id;
        break;
      }

      // optional int32 price_scheme_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_price_scheme_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &price_scheme_id_)));
          set_has_price_scheme_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_transaction_id;
        break;
      }

      // optional uint64 transaction_id = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_transaction_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &transaction_id_)));
          set_has_transaction_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_pin_code;
        break;
      }

      // optional string pin_code = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pin_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pin_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_transparent;
        break;
      }

      // optional string transparent = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transparent:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_transparent()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransactionStarted_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 connector_id = 1;
  if (has_connector_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->connector_id(), output);
  }

  // required .cl_message.IdToken id_tag = 2;
  if (has_id_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->id_tag(), output);
  }

  // required int32 meter_start = 3;
  if (has_meter_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->meter_start(), output);
  }

  // required int32 timestamp = 4;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->timestamp(), output);
  }

  // optional int32 price_scheme_id = 5;
  if (has_price_scheme_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->price_scheme_id(), output);
  }

  // optional uint64 transaction_id = 6;
  if (has_transaction_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->transaction_id(), output);
  }

  // optional string pin_code = 7;
  if (has_pin_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->pin_code(), output);
  }

  // optional string transparent = 8;
  if (has_transparent()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      8, this->transparent(), output);
  }

}

int TransactionStarted_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 connector_id = 1;
    if (has_connector_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->connector_id());
    }

    // required .cl_message.IdToken id_tag = 2;
    if (has_id_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id_tag());
    }

    // required int32 meter_start = 3;
    if (has_meter_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->meter_start());
    }

    // required int32 timestamp = 4;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->timestamp());
    }

    // optional int32 price_scheme_id = 5;
    if (has_price_scheme_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->price_scheme_id());
    }

    // optional uint64 transaction_id = 6;
    if (has_transaction_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->transaction_id());
    }

    // optional string pin_code = 7;
    if (has_pin_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pin_code());
    }

    // optional string transparent = 8;
    if (has_transparent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->transparent());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionStarted_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransactionStarted_Request*>(&from));
}

void TransactionStarted_Request::MergeFrom(const TransactionStarted_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_connector_id()) {
      set_connector_id(from.connector_id());
    }
    if (from.has_id_tag()) {
      mutable_id_tag()->::cl_message::IdToken::MergeFrom(from.id_tag());
    }
    if (from.has_meter_start()) {
      set_meter_start(from.meter_start());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_price_scheme_id()) {
      set_price_scheme_id(from.price_scheme_id());
    }
    if (from.has_transaction_id()) {
      set_transaction_id(from.transaction_id());
    }
    if (from.has_pin_code()) {
      set_pin_code(from.pin_code());
    }
    if (from.has_transparent()) {
      set_transparent(from.transparent());
    }
  }
}

void TransactionStarted_Request::CopyFrom(const TransactionStarted_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionStarted_Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;

  if (has_id_tag()) {
    if (!this->id_tag().IsInitialized()) return false;
  }
  return true;
}

void TransactionStarted_Request::Swap(TransactionStarted_Request* other) {
  if (other != this) {
    std::swap(connector_id_, other->connector_id_);
    std::swap(id_tag_, other->id_tag_);
    std::swap(meter_start_, other->meter_start_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(price_scheme_id_, other->price_scheme_id_);
    std::swap(transaction_id_, other->transaction_id_);
    std::swap(pin_code_, other->pin_code_);
    std::swap(transparent_, other->transparent_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TransactionStarted_Request::GetTypeName() const {
  return "cl_message.TransactionStarted.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TransactionStarted_Confirm::kTransactionIdFieldNumber;
const int TransactionStarted_Confirm::kIdInfoFieldNumber;
const int TransactionStarted_Confirm::kMaxAllowedHoursFieldNumber;
const int TransactionStarted_Confirm::kMaxAllowedKwhFieldNumber;
#endif  // !_MSC_VER

TransactionStarted_Confirm::TransactionStarted_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TransactionStarted_Confirm::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_info_ = const_cast< ::cl_message::IdTagInfo*>(
      ::cl_message::IdTagInfo::internal_default_instance());
#else
  id_info_ = const_cast< ::cl_message::IdTagInfo*>(&::cl_message::IdTagInfo::default_instance());
#endif
}

TransactionStarted_Confirm::TransactionStarted_Confirm(const TransactionStarted_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TransactionStarted_Confirm::SharedCtor() {
  _cached_size_ = 0;
  transaction_id_ = GOOGLE_ULONGLONG(0);
  id_info_ = NULL;
  max_allowed_hours_ = 0;
  max_allowed_kwh_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionStarted_Confirm::~TransactionStarted_Confirm() {
  SharedDtor();
}

void TransactionStarted_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete id_info_;
  }
}

void TransactionStarted_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransactionStarted_Confirm& TransactionStarted_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

TransactionStarted_Confirm* TransactionStarted_Confirm::default_instance_ = NULL;

TransactionStarted_Confirm* TransactionStarted_Confirm::New() const {
  return new TransactionStarted_Confirm;
}

void TransactionStarted_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    transaction_id_ = GOOGLE_ULONGLONG(0);
    if (has_id_info()) {
      if (id_info_ != NULL) id_info_->::cl_message::IdTagInfo::Clear();
    }
    max_allowed_hours_ = 0;
    max_allowed_kwh_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TransactionStarted_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 transaction_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &transaction_id_)));
          set_has_transaction_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_id_info;
        break;
      }

      // optional .cl_message.IdTagInfo id_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_id_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_max_allowed_hours;
        break;
      }

      // optional int32 max_allowed_hours = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_allowed_hours:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_allowed_hours_)));
          set_has_max_allowed_hours();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_max_allowed_kwh;
        break;
      }

      // optional int32 max_allowed_kwh = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_allowed_kwh:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_allowed_kwh_)));
          set_has_max_allowed_kwh();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransactionStarted_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 transaction_id = 1;
  if (has_transaction_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->transaction_id(), output);
  }

  // optional .cl_message.IdTagInfo id_info = 2;
  if (has_id_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->id_info(), output);
  }

  // optional int32 max_allowed_hours = 3;
  if (has_max_allowed_hours()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->max_allowed_hours(), output);
  }

  // optional int32 max_allowed_kwh = 4;
  if (has_max_allowed_kwh()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->max_allowed_kwh(), output);
  }

}

int TransactionStarted_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 transaction_id = 1;
    if (has_transaction_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->transaction_id());
    }

    // optional .cl_message.IdTagInfo id_info = 2;
    if (has_id_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id_info());
    }

    // optional int32 max_allowed_hours = 3;
    if (has_max_allowed_hours()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_allowed_hours());
    }

    // optional int32 max_allowed_kwh = 4;
    if (has_max_allowed_kwh()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_allowed_kwh());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionStarted_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransactionStarted_Confirm*>(&from));
}

void TransactionStarted_Confirm::MergeFrom(const TransactionStarted_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_transaction_id()) {
      set_transaction_id(from.transaction_id());
    }
    if (from.has_id_info()) {
      mutable_id_info()->::cl_message::IdTagInfo::MergeFrom(from.id_info());
    }
    if (from.has_max_allowed_hours()) {
      set_max_allowed_hours(from.max_allowed_hours());
    }
    if (from.has_max_allowed_kwh()) {
      set_max_allowed_kwh(from.max_allowed_kwh());
    }
  }
}

void TransactionStarted_Confirm::CopyFrom(const TransactionStarted_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionStarted_Confirm::IsInitialized() const {

  if (has_id_info()) {
    if (!this->id_info().IsInitialized()) return false;
  }
  return true;
}

void TransactionStarted_Confirm::Swap(TransactionStarted_Confirm* other) {
  if (other != this) {
    std::swap(transaction_id_, other->transaction_id_);
    std::swap(id_info_, other->id_info_);
    std::swap(max_allowed_hours_, other->max_allowed_hours_);
    std::swap(max_allowed_kwh_, other->max_allowed_kwh_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TransactionStarted_Confirm::GetTypeName() const {
  return "cl_message.TransactionStarted.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TransactionStarted::kReqFieldNumber;
const int TransactionStarted::kConfFieldNumber;
#endif  // !_MSC_VER

TransactionStarted::TransactionStarted()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TransactionStarted::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::TransactionStarted_Request*>(
      ::cl_message::TransactionStarted_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::TransactionStarted_Request*>(&::cl_message::TransactionStarted_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::TransactionStarted_Confirm*>(
      ::cl_message::TransactionStarted_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::TransactionStarted_Confirm*>(&::cl_message::TransactionStarted_Confirm::default_instance());
#endif
}

TransactionStarted::TransactionStarted(const TransactionStarted& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TransactionStarted::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionStarted::~TransactionStarted() {
  SharedDtor();
}

void TransactionStarted::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void TransactionStarted::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransactionStarted& TransactionStarted::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

TransactionStarted* TransactionStarted::default_instance_ = NULL;

TransactionStarted* TransactionStarted::New() const {
  return new TransactionStarted;
}

void TransactionStarted::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::TransactionStarted_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::TransactionStarted_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TransactionStarted::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.TransactionStarted.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.TransactionStarted.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransactionStarted::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.TransactionStarted.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.TransactionStarted.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int TransactionStarted::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.TransactionStarted.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.TransactionStarted.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionStarted::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransactionStarted*>(&from));
}

void TransactionStarted::MergeFrom(const TransactionStarted& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::TransactionStarted_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::TransactionStarted_Confirm::MergeFrom(from.conf());
    }
  }
}

void TransactionStarted::CopyFrom(const TransactionStarted& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionStarted::IsInitialized() const {

  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  if (has_conf()) {
    if (!this->conf().IsInitialized()) return false;
  }
  return true;
}

void TransactionStarted::Swap(TransactionStarted* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TransactionStarted::GetTypeName() const {
  return "cl_message.TransactionStarted";
}


// ===================================================================

#ifndef _MSC_VER
const int TransactionStopped_Request::kTransactionIdFieldNumber;
const int TransactionStopped_Request::kIdTagFieldNumber;
const int TransactionStopped_Request::kMeterStopFieldNumber;
const int TransactionStopped_Request::kTimestampFieldNumber;
const int TransactionStopped_Request::kStopReasonFieldNumber;
const int TransactionStopped_Request::kTimeSpentChargingFieldNumber;
#endif  // !_MSC_VER

TransactionStopped_Request::TransactionStopped_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TransactionStopped_Request::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_tag_ = const_cast< ::cl_message::IdToken*>(
      ::cl_message::IdToken::internal_default_instance());
#else
  id_tag_ = const_cast< ::cl_message::IdToken*>(&::cl_message::IdToken::default_instance());
#endif
}

TransactionStopped_Request::TransactionStopped_Request(const TransactionStopped_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TransactionStopped_Request::SharedCtor() {
  _cached_size_ = 0;
  transaction_id_ = GOOGLE_ULONGLONG(0);
  id_tag_ = NULL;
  meter_stop_ = 0;
  timestamp_ = 0;
  stop_reason_ = 0;
  time_spent_charging_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionStopped_Request::~TransactionStopped_Request() {
  SharedDtor();
}

void TransactionStopped_Request::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete id_tag_;
  }
}

void TransactionStopped_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransactionStopped_Request& TransactionStopped_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

TransactionStopped_Request* TransactionStopped_Request::default_instance_ = NULL;

TransactionStopped_Request* TransactionStopped_Request::New() const {
  return new TransactionStopped_Request;
}

void TransactionStopped_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    transaction_id_ = GOOGLE_ULONGLONG(0);
    if (has_id_tag()) {
      if (id_tag_ != NULL) id_tag_->::cl_message::IdToken::Clear();
    }
    meter_stop_ = 0;
    timestamp_ = 0;
    stop_reason_ = 0;
    time_spent_charging_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TransactionStopped_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 transaction_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &transaction_id_)));
          set_has_transaction_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_id_tag;
        break;
      }

      // required .cl_message.IdToken id_tag = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_id_tag:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id_tag()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_meter_stop;
        break;
      }

      // required int32 meter_stop = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_meter_stop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &meter_stop_)));
          set_has_meter_stop();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_timestamp;
        break;
      }

      // required int32 timestamp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_stop_reason;
        break;
      }

      // required int32 stop_reason = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_stop_reason:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &stop_reason_)));
          set_has_stop_reason();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_time_spent_charging;
        break;
      }

      // optional int32 time_spent_charging = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time_spent_charging:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &time_spent_charging_)));
          set_has_time_spent_charging();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransactionStopped_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 transaction_id = 1;
  if (has_transaction_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->transaction_id(), output);
  }

  // required .cl_message.IdToken id_tag = 2;
  if (has_id_tag()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->id_tag(), output);
  }

  // required int32 meter_stop = 3;
  if (has_meter_stop()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->meter_stop(), output);
  }

  // required int32 timestamp = 4;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->timestamp(), output);
  }

  // required int32 stop_reason = 5;
  if (has_stop_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->stop_reason(), output);
  }

  // optional int32 time_spent_charging = 6;
  if (has_time_spent_charging()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->time_spent_charging(), output);
  }

}

int TransactionStopped_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 transaction_id = 1;
    if (has_transaction_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->transaction_id());
    }

    // required .cl_message.IdToken id_tag = 2;
    if (has_id_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->id_tag());
    }

    // required int32 meter_stop = 3;
    if (has_meter_stop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->meter_stop());
    }

    // required int32 timestamp = 4;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->timestamp());
    }

    // required int32 stop_reason = 5;
    if (has_stop_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->stop_reason());
    }

    // optional int32 time_spent_charging = 6;
    if (has_time_spent_charging()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->time_spent_charging());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionStopped_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransactionStopped_Request*>(&from));
}

void TransactionStopped_Request::MergeFrom(const TransactionStopped_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_transaction_id()) {
      set_transaction_id(from.transaction_id());
    }
    if (from.has_id_tag()) {
      mutable_id_tag()->::cl_message::IdToken::MergeFrom(from.id_tag());
    }
    if (from.has_meter_stop()) {
      set_meter_stop(from.meter_stop());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_stop_reason()) {
      set_stop_reason(from.stop_reason());
    }
    if (from.has_time_spent_charging()) {
      set_time_spent_charging(from.time_spent_charging());
    }
  }
}

void TransactionStopped_Request::CopyFrom(const TransactionStopped_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionStopped_Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001e) != 0x0000001e) return false;

  if (has_id_tag()) {
    if (!this->id_tag().IsInitialized()) return false;
  }
  return true;
}

void TransactionStopped_Request::Swap(TransactionStopped_Request* other) {
  if (other != this) {
    std::swap(transaction_id_, other->transaction_id_);
    std::swap(id_tag_, other->id_tag_);
    std::swap(meter_stop_, other->meter_stop_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(stop_reason_, other->stop_reason_);
    std::swap(time_spent_charging_, other->time_spent_charging_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TransactionStopped_Request::GetTypeName() const {
  return "cl_message.TransactionStopped.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TransactionStopped_Confirm::kTotalCostFieldNumber;
#endif  // !_MSC_VER

TransactionStopped_Confirm::TransactionStopped_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TransactionStopped_Confirm::InitAsDefaultInstance() {
}

TransactionStopped_Confirm::TransactionStopped_Confirm(const TransactionStopped_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TransactionStopped_Confirm::SharedCtor() {
  _cached_size_ = 0;
  total_cost_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionStopped_Confirm::~TransactionStopped_Confirm() {
  SharedDtor();
}

void TransactionStopped_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TransactionStopped_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransactionStopped_Confirm& TransactionStopped_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

TransactionStopped_Confirm* TransactionStopped_Confirm::default_instance_ = NULL;

TransactionStopped_Confirm* TransactionStopped_Confirm::New() const {
  return new TransactionStopped_Confirm;
}

void TransactionStopped_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    total_cost_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TransactionStopped_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 total_cost = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_cost_)));
          set_has_total_cost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransactionStopped_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 total_cost = 1;
  if (has_total_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->total_cost(), output);
  }

}

int TransactionStopped_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 total_cost = 1;
    if (has_total_cost()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->total_cost());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionStopped_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransactionStopped_Confirm*>(&from));
}

void TransactionStopped_Confirm::MergeFrom(const TransactionStopped_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_total_cost()) {
      set_total_cost(from.total_cost());
    }
  }
}

void TransactionStopped_Confirm::CopyFrom(const TransactionStopped_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionStopped_Confirm::IsInitialized() const {

  return true;
}

void TransactionStopped_Confirm::Swap(TransactionStopped_Confirm* other) {
  if (other != this) {
    std::swap(total_cost_, other->total_cost_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TransactionStopped_Confirm::GetTypeName() const {
  return "cl_message.TransactionStopped.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TransactionStopped::kReqFieldNumber;
const int TransactionStopped::kConfFieldNumber;
#endif  // !_MSC_VER

TransactionStopped::TransactionStopped()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TransactionStopped::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::TransactionStopped_Request*>(
      ::cl_message::TransactionStopped_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::TransactionStopped_Request*>(&::cl_message::TransactionStopped_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::TransactionStopped_Confirm*>(
      ::cl_message::TransactionStopped_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::TransactionStopped_Confirm*>(&::cl_message::TransactionStopped_Confirm::default_instance());
#endif
}

TransactionStopped::TransactionStopped(const TransactionStopped& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TransactionStopped::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionStopped::~TransactionStopped() {
  SharedDtor();
}

void TransactionStopped::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void TransactionStopped::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransactionStopped& TransactionStopped::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

TransactionStopped* TransactionStopped::default_instance_ = NULL;

TransactionStopped* TransactionStopped::New() const {
  return new TransactionStopped;
}

void TransactionStopped::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::TransactionStopped_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::TransactionStopped_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TransactionStopped::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.TransactionStopped.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.TransactionStopped.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransactionStopped::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.TransactionStopped.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.TransactionStopped.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int TransactionStopped::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.TransactionStopped.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.TransactionStopped.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionStopped::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransactionStopped*>(&from));
}

void TransactionStopped::MergeFrom(const TransactionStopped& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::TransactionStopped_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::TransactionStopped_Confirm::MergeFrom(from.conf());
    }
  }
}

void TransactionStopped::CopyFrom(const TransactionStopped& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionStopped::IsInitialized() const {

  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  return true;
}

void TransactionStopped::Swap(TransactionStopped* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TransactionStopped::GetTypeName() const {
  return "cl_message.TransactionStopped";
}


// ===================================================================

#ifndef _MSC_VER
const int TransactionRecords_Request::kChecksumFieldNumber;
const int TransactionRecords_Request::kRecordsFieldNumber;
#endif  // !_MSC_VER

TransactionRecords_Request::TransactionRecords_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TransactionRecords_Request::InitAsDefaultInstance() {
}

TransactionRecords_Request::TransactionRecords_Request(const TransactionRecords_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TransactionRecords_Request::SharedCtor() {
  _cached_size_ = 0;
  checksum_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionRecords_Request::~TransactionRecords_Request() {
  SharedDtor();
}

void TransactionRecords_Request::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TransactionRecords_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransactionRecords_Request& TransactionRecords_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

TransactionRecords_Request* TransactionRecords_Request::default_instance_ = NULL;

TransactionRecords_Request* TransactionRecords_Request::New() const {
  return new TransactionRecords_Request;
}

void TransactionRecords_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    checksum_ = 0;
  }
  records_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TransactionRecords_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 checksum = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checksum_)));
          set_has_checksum();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_records;
        break;
      }

      // repeated .cl_message.Transactions records = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_records:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_records()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_records;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransactionRecords_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 checksum = 1;
  if (has_checksum()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->checksum(), output);
  }

  // repeated .cl_message.Transactions records = 2;
  for (int i = 0; i < this->records_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->records(i), output);
  }

}

int TransactionRecords_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 checksum = 1;
    if (has_checksum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checksum());
    }

  }
  // repeated .cl_message.Transactions records = 2;
  total_size += 1 * this->records_size();
  for (int i = 0; i < this->records_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->records(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionRecords_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransactionRecords_Request*>(&from));
}

void TransactionRecords_Request::MergeFrom(const TransactionRecords_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  records_.MergeFrom(from.records_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_checksum()) {
      set_checksum(from.checksum());
    }
  }
}

void TransactionRecords_Request::CopyFrom(const TransactionRecords_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionRecords_Request::IsInitialized() const {

  for (int i = 0; i < records_size(); i++) {
    if (!this->records(i).IsInitialized()) return false;
  }
  return true;
}

void TransactionRecords_Request::Swap(TransactionRecords_Request* other) {
  if (other != this) {
    std::swap(checksum_, other->checksum_);
    records_.Swap(&other->records_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TransactionRecords_Request::GetTypeName() const {
  return "cl_message.TransactionRecords.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TransactionRecords_Confirm::kStatusFieldNumber;
const int TransactionRecords_Confirm::kTransactionIdFieldNumber;
#endif  // !_MSC_VER

TransactionRecords_Confirm::TransactionRecords_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TransactionRecords_Confirm::InitAsDefaultInstance() {
}

TransactionRecords_Confirm::TransactionRecords_Confirm(const TransactionRecords_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TransactionRecords_Confirm::SharedCtor() {
  _cached_size_ = 0;
  status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionRecords_Confirm::~TransactionRecords_Confirm() {
  SharedDtor();
}

void TransactionRecords_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TransactionRecords_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransactionRecords_Confirm& TransactionRecords_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

TransactionRecords_Confirm* TransactionRecords_Confirm::default_instance_ = NULL;

TransactionRecords_Confirm* TransactionRecords_Confirm::New() const {
  return new TransactionRecords_Confirm;
}

void TransactionRecords_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 0;
  }
  transaction_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TransactionRecords_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_transaction_id;
        break;
      }

      // repeated uint64 transaction_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_transaction_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 16, input, this->mutable_transaction_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_transaction_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_transaction_id;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransactionRecords_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->status(), output);
  }

  // repeated uint64 transaction_id = 2;
  for (int i = 0; i < this->transaction_id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      2, this->transaction_id(i), output);
  }

}

int TransactionRecords_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

  }
  // repeated uint64 transaction_id = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->transaction_id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->transaction_id(i));
    }
    total_size += 1 * this->transaction_id_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionRecords_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransactionRecords_Confirm*>(&from));
}

void TransactionRecords_Confirm::MergeFrom(const TransactionRecords_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  transaction_id_.MergeFrom(from.transaction_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
  }
}

void TransactionRecords_Confirm::CopyFrom(const TransactionRecords_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionRecords_Confirm::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TransactionRecords_Confirm::Swap(TransactionRecords_Confirm* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    transaction_id_.Swap(&other->transaction_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TransactionRecords_Confirm::GetTypeName() const {
  return "cl_message.TransactionRecords.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int TransactionRecords::kReqFieldNumber;
const int TransactionRecords::kConfFieldNumber;
#endif  // !_MSC_VER

TransactionRecords::TransactionRecords()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TransactionRecords::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::TransactionRecords_Request*>(
      ::cl_message::TransactionRecords_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::TransactionRecords_Request*>(&::cl_message::TransactionRecords_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::TransactionRecords_Confirm*>(
      ::cl_message::TransactionRecords_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::TransactionRecords_Confirm*>(&::cl_message::TransactionRecords_Confirm::default_instance());
#endif
}

TransactionRecords::TransactionRecords(const TransactionRecords& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TransactionRecords::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionRecords::~TransactionRecords() {
  SharedDtor();
}

void TransactionRecords::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void TransactionRecords::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TransactionRecords& TransactionRecords::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

TransactionRecords* TransactionRecords::default_instance_ = NULL;

TransactionRecords* TransactionRecords::New() const {
  return new TransactionRecords;
}

void TransactionRecords::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::TransactionRecords_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::TransactionRecords_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TransactionRecords::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.TransactionRecords.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.TransactionRecords.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransactionRecords::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.TransactionRecords.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.TransactionRecords.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int TransactionRecords::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.TransactionRecords.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.TransactionRecords.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionRecords::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TransactionRecords*>(&from));
}

void TransactionRecords::MergeFrom(const TransactionRecords& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::TransactionRecords_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::TransactionRecords_Confirm::MergeFrom(from.conf());
    }
  }
}

void TransactionRecords::CopyFrom(const TransactionRecords& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionRecords::IsInitialized() const {

  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  if (has_conf()) {
    if (!this->conf().IsInitialized()) return false;
  }
  return true;
}

void TransactionRecords::Swap(TransactionRecords* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TransactionRecords::GetTypeName() const {
  return "cl_message.TransactionRecords";
}


// ===================================================================

#ifndef _MSC_VER
const int MeasureValue::kElectricityFieldNumber;
const int MeasureValue::kPowerFieldNumber;
const int MeasureValue::kCurrentAFieldNumber;
const int MeasureValue::kCurrentBFieldNumber;
const int MeasureValue::kCurrentCFieldNumber;
const int MeasureValue::kVoltageAFieldNumber;
const int MeasureValue::kVoltageBFieldNumber;
const int MeasureValue::kVoltageCFieldNumber;
#endif  // !_MSC_VER

MeasureValue::MeasureValue()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MeasureValue::InitAsDefaultInstance() {
}

MeasureValue::MeasureValue(const MeasureValue& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MeasureValue::SharedCtor() {
  _cached_size_ = 0;
  electricity_ = 0;
  power_ = 0;
  currenta_ = 0;
  currentb_ = 0;
  currentc_ = 0;
  voltagea_ = 0;
  voltageb_ = 0;
  voltagec_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MeasureValue::~MeasureValue() {
  SharedDtor();
}

void MeasureValue::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MeasureValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MeasureValue& MeasureValue::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

MeasureValue* MeasureValue::default_instance_ = NULL;

MeasureValue* MeasureValue::New() const {
  return new MeasureValue;
}

void MeasureValue::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    electricity_ = 0;
    power_ = 0;
    currenta_ = 0;
    currentb_ = 0;
    currentc_ = 0;
    voltagea_ = 0;
    voltageb_ = 0;
    voltagec_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MeasureValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 Electricity = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &electricity_)));
          set_has_electricity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_Power;
        break;
      }

      // optional int32 Power = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Power:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &power_)));
          set_has_power();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_CurrentA;
        break;
      }

      // optional int32 CurrentA = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_CurrentA:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currenta_)));
          set_has_currenta();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_CurrentB;
        break;
      }

      // optional int32 CurrentB = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_CurrentB:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currentb_)));
          set_has_currentb();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_CurrentC;
        break;
      }

      // optional int32 CurrentC = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_CurrentC:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currentc_)));
          set_has_currentc();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_VoltageA;
        break;
      }

      // optional int32 VoltageA = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_VoltageA:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &voltagea_)));
          set_has_voltagea();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_VoltageB;
        break;
      }

      // optional int32 VoltageB = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_VoltageB:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &voltageb_)));
          set_has_voltageb();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_VoltageC;
        break;
      }

      // optional int32 VoltageC = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_VoltageC:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &voltagec_)));
          set_has_voltagec();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MeasureValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 Electricity = 1;
  if (has_electricity()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->electricity(), output);
  }

  // optional int32 Power = 2;
  if (has_power()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->power(), output);
  }

  // optional int32 CurrentA = 3;
  if (has_currenta()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->currenta(), output);
  }

  // optional int32 CurrentB = 4;
  if (has_currentb()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->currentb(), output);
  }

  // optional int32 CurrentC = 5;
  if (has_currentc()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->currentc(), output);
  }

  // optional int32 VoltageA = 6;
  if (has_voltagea()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->voltagea(), output);
  }

  // optional int32 VoltageB = 7;
  if (has_voltageb()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->voltageb(), output);
  }

  // optional int32 VoltageC = 8;
  if (has_voltagec()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->voltagec(), output);
  }

}

int MeasureValue::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 Electricity = 1;
    if (has_electricity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->electricity());
    }

    // optional int32 Power = 2;
    if (has_power()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->power());
    }

    // optional int32 CurrentA = 3;
    if (has_currenta()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currenta());
    }

    // optional int32 CurrentB = 4;
    if (has_currentb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currentb());
    }

    // optional int32 CurrentC = 5;
    if (has_currentc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currentc());
    }

    // optional int32 VoltageA = 6;
    if (has_voltagea()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->voltagea());
    }

    // optional int32 VoltageB = 7;
    if (has_voltageb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->voltageb());
    }

    // optional int32 VoltageC = 8;
    if (has_voltagec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->voltagec());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MeasureValue::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MeasureValue*>(&from));
}

void MeasureValue::MergeFrom(const MeasureValue& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_electricity()) {
      set_electricity(from.electricity());
    }
    if (from.has_power()) {
      set_power(from.power());
    }
    if (from.has_currenta()) {
      set_currenta(from.currenta());
    }
    if (from.has_currentb()) {
      set_currentb(from.currentb());
    }
    if (from.has_currentc()) {
      set_currentc(from.currentc());
    }
    if (from.has_voltagea()) {
      set_voltagea(from.voltagea());
    }
    if (from.has_voltageb()) {
      set_voltageb(from.voltageb());
    }
    if (from.has_voltagec()) {
      set_voltagec(from.voltagec());
    }
  }
}

void MeasureValue::CopyFrom(const MeasureValue& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MeasureValue::IsInitialized() const {

  return true;
}

void MeasureValue::Swap(MeasureValue* other) {
  if (other != this) {
    std::swap(electricity_, other->electricity_);
    std::swap(power_, other->power_);
    std::swap(currenta_, other->currenta_);
    std::swap(currentb_, other->currentb_);
    std::swap(currentc_, other->currentc_);
    std::swap(voltagea_, other->voltagea_);
    std::swap(voltageb_, other->voltageb_);
    std::swap(voltagec_, other->voltagec_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MeasureValue::GetTypeName() const {
  return "cl_message.MeasureValue";
}


// ===================================================================

#ifndef _MSC_VER
const int Measure_Request::kConnectorIdFieldNumber;
const int Measure_Request::kTransactionIdFieldNumber;
const int Measure_Request::kValueFieldNumber;
#endif  // !_MSC_VER

Measure_Request::Measure_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Measure_Request::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  value_ = const_cast< ::cl_message::MeasureValue*>(
      ::cl_message::MeasureValue::internal_default_instance());
#else
  value_ = const_cast< ::cl_message::MeasureValue*>(&::cl_message::MeasureValue::default_instance());
#endif
}

Measure_Request::Measure_Request(const Measure_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Measure_Request::SharedCtor() {
  _cached_size_ = 0;
  connector_id_ = 0;
  transaction_id_ = GOOGLE_ULONGLONG(0);
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Measure_Request::~Measure_Request() {
  SharedDtor();
}

void Measure_Request::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete value_;
  }
}

void Measure_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Measure_Request& Measure_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

Measure_Request* Measure_Request::default_instance_ = NULL;

Measure_Request* Measure_Request::New() const {
  return new Measure_Request;
}

void Measure_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    connector_id_ = 0;
    transaction_id_ = GOOGLE_ULONGLONG(0);
    if (has_value()) {
      if (value_ != NULL) value_->::cl_message::MeasureValue::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Measure_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 connector_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &connector_id_)));
          set_has_connector_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_transaction_id;
        break;
      }

      // optional uint64 transaction_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_transaction_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &transaction_id_)));
          set_has_transaction_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }

      // required .cl_message.MeasureValue value = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Measure_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 connector_id = 1;
  if (has_connector_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->connector_id(), output);
  }

  // optional uint64 transaction_id = 2;
  if (has_transaction_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->transaction_id(), output);
  }

  // required .cl_message.MeasureValue value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->value(), output);
  }

}

int Measure_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 connector_id = 1;
    if (has_connector_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->connector_id());
    }

    // optional uint64 transaction_id = 2;
    if (has_transaction_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->transaction_id());
    }

    // required .cl_message.MeasureValue value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->value());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Measure_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Measure_Request*>(&from));
}

void Measure_Request::MergeFrom(const Measure_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_connector_id()) {
      set_connector_id(from.connector_id());
    }
    if (from.has_transaction_id()) {
      set_transaction_id(from.transaction_id());
    }
    if (from.has_value()) {
      mutable_value()->::cl_message::MeasureValue::MergeFrom(from.value());
    }
  }
}

void Measure_Request::CopyFrom(const Measure_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Measure_Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  return true;
}

void Measure_Request::Swap(Measure_Request* other) {
  if (other != this) {
    std::swap(connector_id_, other->connector_id_);
    std::swap(transaction_id_, other->transaction_id_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Measure_Request::GetTypeName() const {
  return "cl_message.Measure.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
#endif  // !_MSC_VER

Measure_Confirm::Measure_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Measure_Confirm::InitAsDefaultInstance() {
}

Measure_Confirm::Measure_Confirm(const Measure_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Measure_Confirm::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Measure_Confirm::~Measure_Confirm() {
  SharedDtor();
}

void Measure_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Measure_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Measure_Confirm& Measure_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

Measure_Confirm* Measure_Confirm::default_instance_ = NULL;

Measure_Confirm* Measure_Confirm::New() const {
  return new Measure_Confirm;
}

void Measure_Confirm::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Measure_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void Measure_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int Measure_Confirm::ByteSize() const {
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Measure_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Measure_Confirm*>(&from));
}

void Measure_Confirm::MergeFrom(const Measure_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void Measure_Confirm::CopyFrom(const Measure_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Measure_Confirm::IsInitialized() const {

  return true;
}

void Measure_Confirm::Swap(Measure_Confirm* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Measure_Confirm::GetTypeName() const {
  return "cl_message.Measure.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Measure::kReqFieldNumber;
const int Measure::kConfFieldNumber;
#endif  // !_MSC_VER

Measure::Measure()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Measure::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::Measure_Request*>(
      ::cl_message::Measure_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::Measure_Request*>(&::cl_message::Measure_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::Measure_Confirm*>(
      ::cl_message::Measure_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::Measure_Confirm*>(&::cl_message::Measure_Confirm::default_instance());
#endif
}

Measure::Measure(const Measure& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Measure::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Measure::~Measure() {
  SharedDtor();
}

void Measure::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void Measure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Measure& Measure::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

Measure* Measure::default_instance_ = NULL;

Measure* Measure::New() const {
  return new Measure;
}

void Measure::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::Measure_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::Measure_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Measure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.Measure.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.Measure.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Measure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.Measure.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.Measure.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int Measure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.Measure.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.Measure.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Measure::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Measure*>(&from));
}

void Measure::MergeFrom(const Measure& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::Measure_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::Measure_Confirm::MergeFrom(from.conf());
    }
  }
}

void Measure::CopyFrom(const Measure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Measure::IsInitialized() const {

  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  return true;
}

void Measure::Swap(Measure* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Measure::GetTypeName() const {
  return "cl_message.Measure";
}


// ===================================================================

#ifndef _MSC_VER
const int BootNotification_Request::kVersionFieldNumber;
const int BootNotification_Request::kCpVersionFieldNumber;
const int BootNotification_Request::kClientVersionFieldNumber;
const int BootNotification_Request::kFirmwareVersionFieldNumber;
#endif  // !_MSC_VER

BootNotification_Request::BootNotification_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BootNotification_Request::InitAsDefaultInstance() {
}

BootNotification_Request::BootNotification_Request(const BootNotification_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BootNotification_Request::SharedCtor() {
  _cached_size_ = 0;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  cp_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  firmware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BootNotification_Request::~BootNotification_Request() {
  SharedDtor();
}

void BootNotification_Request::SharedDtor() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (cp_version_ != &::google::protobuf::internal::kEmptyString) {
    delete cp_version_;
  }
  if (client_version_ != &::google::protobuf::internal::kEmptyString) {
    delete client_version_;
  }
  if (firmware_version_ != &::google::protobuf::internal::kEmptyString) {
    delete firmware_version_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BootNotification_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BootNotification_Request& BootNotification_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

BootNotification_Request* BootNotification_Request::default_instance_ = NULL;

BootNotification_Request* BootNotification_Request::New() const {
  return new BootNotification_Request;
}

void BootNotification_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_cp_version()) {
      if (cp_version_ != &::google::protobuf::internal::kEmptyString) {
        cp_version_->clear();
      }
    }
    if (has_client_version()) {
      if (client_version_ != &::google::protobuf::internal::kEmptyString) {
        client_version_->clear();
      }
    }
    if (has_firmware_version()) {
      if (firmware_version_ != &::google::protobuf::internal::kEmptyString) {
        firmware_version_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BootNotification_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_cp_version;
        break;
      }

      // optional string cp_version = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cp_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cp_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_client_version;
        break;
      }

      // optional string client_version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_client_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_client_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_firmware_version;
        break;
      }

      // optional string firmware_version = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_firmware_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_firmware_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BootNotification_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->version(), output);
  }

  // optional string cp_version = 2;
  if (has_cp_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->cp_version(), output);
  }

  // optional string client_version = 3;
  if (has_client_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->client_version(), output);
  }

  // optional string firmware_version = 4;
  if (has_firmware_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->firmware_version(), output);
  }

}

int BootNotification_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional string cp_version = 2;
    if (has_cp_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cp_version());
    }

    // optional string client_version = 3;
    if (has_client_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->client_version());
    }

    // optional string firmware_version = 4;
    if (has_firmware_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->firmware_version());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BootNotification_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BootNotification_Request*>(&from));
}

void BootNotification_Request::MergeFrom(const BootNotification_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_cp_version()) {
      set_cp_version(from.cp_version());
    }
    if (from.has_client_version()) {
      set_client_version(from.client_version());
    }
    if (from.has_firmware_version()) {
      set_firmware_version(from.firmware_version());
    }
  }
}

void BootNotification_Request::CopyFrom(const BootNotification_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BootNotification_Request::IsInitialized() const {

  return true;
}

void BootNotification_Request::Swap(BootNotification_Request* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(cp_version_, other->cp_version_);
    std::swap(client_version_, other->client_version_);
    std::swap(firmware_version_, other->firmware_version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BootNotification_Request::GetTypeName() const {
  return "cl_message.BootNotification.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BootNotification_Confirm::kTimestampFieldNumber;
const int BootNotification_Confirm::kHbIntervalFieldNumber;
const int BootNotification_Confirm::kMeterIdleIntervalFieldNumber;
const int BootNotification_Confirm::kMeterChargeIntervalFieldNumber;
#endif  // !_MSC_VER

BootNotification_Confirm::BootNotification_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BootNotification_Confirm::InitAsDefaultInstance() {
}

BootNotification_Confirm::BootNotification_Confirm(const BootNotification_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BootNotification_Confirm::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = 0;
  hb_interval_ = 0;
  meter_idle_interval_ = 0;
  meter_charge_interval_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BootNotification_Confirm::~BootNotification_Confirm() {
  SharedDtor();
}

void BootNotification_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BootNotification_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BootNotification_Confirm& BootNotification_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

BootNotification_Confirm* BootNotification_Confirm::default_instance_ = NULL;

BootNotification_Confirm* BootNotification_Confirm::New() const {
  return new BootNotification_Confirm;
}

void BootNotification_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    timestamp_ = 0;
    hb_interval_ = 0;
    meter_idle_interval_ = 0;
    meter_charge_interval_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BootNotification_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 timestamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_hb_interval;
        break;
      }

      // optional int32 hb_interval = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hb_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &hb_interval_)));
          set_has_hb_interval();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_meter_idle_interval;
        break;
      }

      // optional int32 meter_idle_interval = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_meter_idle_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &meter_idle_interval_)));
          set_has_meter_idle_interval();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_meter_charge_interval;
        break;
      }

      // optional int32 meter_charge_interval = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_meter_charge_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &meter_charge_interval_)));
          set_has_meter_charge_interval();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BootNotification_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->timestamp(), output);
  }

  // optional int32 hb_interval = 2;
  if (has_hb_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->hb_interval(), output);
  }

  // optional int32 meter_idle_interval = 3;
  if (has_meter_idle_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->meter_idle_interval(), output);
  }

  // optional int32 meter_charge_interval = 4;
  if (has_meter_charge_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->meter_charge_interval(), output);
  }

}

int BootNotification_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->timestamp());
    }

    // optional int32 hb_interval = 2;
    if (has_hb_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->hb_interval());
    }

    // optional int32 meter_idle_interval = 3;
    if (has_meter_idle_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->meter_idle_interval());
    }

    // optional int32 meter_charge_interval = 4;
    if (has_meter_charge_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->meter_charge_interval());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BootNotification_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BootNotification_Confirm*>(&from));
}

void BootNotification_Confirm::MergeFrom(const BootNotification_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_hb_interval()) {
      set_hb_interval(from.hb_interval());
    }
    if (from.has_meter_idle_interval()) {
      set_meter_idle_interval(from.meter_idle_interval());
    }
    if (from.has_meter_charge_interval()) {
      set_meter_charge_interval(from.meter_charge_interval());
    }
  }
}

void BootNotification_Confirm::CopyFrom(const BootNotification_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BootNotification_Confirm::IsInitialized() const {

  return true;
}

void BootNotification_Confirm::Swap(BootNotification_Confirm* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(hb_interval_, other->hb_interval_);
    std::swap(meter_idle_interval_, other->meter_idle_interval_);
    std::swap(meter_charge_interval_, other->meter_charge_interval_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BootNotification_Confirm::GetTypeName() const {
  return "cl_message.BootNotification.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int BootNotification::kReqFieldNumber;
const int BootNotification::kConfFieldNumber;
#endif  // !_MSC_VER

BootNotification::BootNotification()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BootNotification::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::BootNotification_Request*>(
      ::cl_message::BootNotification_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::BootNotification_Request*>(&::cl_message::BootNotification_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::BootNotification_Confirm*>(
      ::cl_message::BootNotification_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::BootNotification_Confirm*>(&::cl_message::BootNotification_Confirm::default_instance());
#endif
}

BootNotification::BootNotification(const BootNotification& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BootNotification::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BootNotification::~BootNotification() {
  SharedDtor();
}

void BootNotification::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void BootNotification::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BootNotification& BootNotification::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

BootNotification* BootNotification::default_instance_ = NULL;

BootNotification* BootNotification::New() const {
  return new BootNotification;
}

void BootNotification::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::BootNotification_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::BootNotification_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BootNotification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.BootNotification.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.BootNotification.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BootNotification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.BootNotification.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.BootNotification.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int BootNotification::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.BootNotification.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.BootNotification.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BootNotification::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BootNotification*>(&from));
}

void BootNotification::MergeFrom(const BootNotification& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::BootNotification_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::BootNotification_Confirm::MergeFrom(from.conf());
    }
  }
}

void BootNotification::CopyFrom(const BootNotification& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BootNotification::IsInitialized() const {

  return true;
}

void BootNotification::Swap(BootNotification* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BootNotification::GetTypeName() const {
  return "cl_message.BootNotification";
}


// ===================================================================

#ifndef _MSC_VER
const int StatusNotification::kConnectorIdFieldNumber;
const int StatusNotification::kStatusFieldNumber;
#endif  // !_MSC_VER

StatusNotification::StatusNotification()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StatusNotification::InitAsDefaultInstance() {
}

StatusNotification::StatusNotification(const StatusNotification& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StatusNotification::SharedCtor() {
  _cached_size_ = 0;
  connector_id_ = 0;
  status_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StatusNotification::~StatusNotification() {
  SharedDtor();
}

void StatusNotification::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StatusNotification::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StatusNotification& StatusNotification::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

StatusNotification* StatusNotification::default_instance_ = NULL;

StatusNotification* StatusNotification::New() const {
  return new StatusNotification;
}

void StatusNotification::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    connector_id_ = 0;
    status_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StatusNotification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 connector_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &connector_id_)));
          set_has_connector_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // required .cl_message.ChargerStatus status = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cl_message::ChargerStatus_IsValid(value)) {
            set_status(static_cast< ::cl_message::ChargerStatus >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StatusNotification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 connector_id = 1;
  if (has_connector_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->connector_id(), output);
  }

  // required .cl_message.ChargerStatus status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

}

int StatusNotification::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 connector_id = 1;
    if (has_connector_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->connector_id());
    }

    // required .cl_message.ChargerStatus status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StatusNotification::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StatusNotification*>(&from));
}

void StatusNotification::MergeFrom(const StatusNotification& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_connector_id()) {
      set_connector_id(from.connector_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
}

void StatusNotification::CopyFrom(const StatusNotification& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusNotification::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void StatusNotification::Swap(StatusNotification* other) {
  if (other != this) {
    std::swap(connector_id_, other->connector_id_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StatusNotification::GetTypeName() const {
  return "cl_message.StatusNotification";
}


// ===================================================================

#ifndef _MSC_VER
const int FirmwareStatusNotifcation::kStatusFieldNumber;
#endif  // !_MSC_VER

FirmwareStatusNotifcation::FirmwareStatusNotifcation()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FirmwareStatusNotifcation::InitAsDefaultInstance() {
}

FirmwareStatusNotifcation::FirmwareStatusNotifcation(const FirmwareStatusNotifcation& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FirmwareStatusNotifcation::SharedCtor() {
  _cached_size_ = 0;
  status_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FirmwareStatusNotifcation::~FirmwareStatusNotifcation() {
  SharedDtor();
}

void FirmwareStatusNotifcation::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FirmwareStatusNotifcation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FirmwareStatusNotifcation& FirmwareStatusNotifcation::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

FirmwareStatusNotifcation* FirmwareStatusNotifcation::default_instance_ = NULL;

FirmwareStatusNotifcation* FirmwareStatusNotifcation::New() const {
  return new FirmwareStatusNotifcation;
}

void FirmwareStatusNotifcation::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    status_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FirmwareStatusNotifcation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .cl_message.FirmwareStatus status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cl_message::FirmwareStatus_IsValid(value)) {
            set_status(static_cast< ::cl_message::FirmwareStatus >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FirmwareStatusNotifcation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .cl_message.FirmwareStatus status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->status(), output);
  }

}

int FirmwareStatusNotifcation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .cl_message.FirmwareStatus status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirmwareStatusNotifcation::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FirmwareStatusNotifcation*>(&from));
}

void FirmwareStatusNotifcation::MergeFrom(const FirmwareStatusNotifcation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
  }
}

void FirmwareStatusNotifcation::CopyFrom(const FirmwareStatusNotifcation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirmwareStatusNotifcation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FirmwareStatusNotifcation::Swap(FirmwareStatusNotifcation* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FirmwareStatusNotifcation::GetTypeName() const {
  return "cl_message.FirmwareStatusNotifcation";
}


// ===================================================================

#ifndef _MSC_VER
const int SensorStatusNotification::kDeviceidFieldNumber;
const int SensorStatusNotification::kIdFieldNumber;
const int SensorStatusNotification::kTypeFieldNumber;
const int SensorStatusNotification::kStatusFieldNumber;
const int SensorStatusNotification::kCapacityFieldNumber;
#endif  // !_MSC_VER

SensorStatusNotification::SensorStatusNotification()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SensorStatusNotification::InitAsDefaultInstance() {
}

SensorStatusNotification::SensorStatusNotification(const SensorStatusNotification& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SensorStatusNotification::SharedCtor() {
  _cached_size_ = 0;
  deviceid_ = 0;
  id_ = 0;
  type_ = 0;
  status_ = 0;
  capacity_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SensorStatusNotification::~SensorStatusNotification() {
  SharedDtor();
}

void SensorStatusNotification::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SensorStatusNotification::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SensorStatusNotification& SensorStatusNotification::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

SensorStatusNotification* SensorStatusNotification::default_instance_ = NULL;

SensorStatusNotification* SensorStatusNotification::New() const {
  return new SensorStatusNotification;
}

void SensorStatusNotification::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    deviceid_ = 0;
    id_ = 0;
    type_ = 0;
    status_ = 0;
    capacity_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SensorStatusNotification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 deviceid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &deviceid_)));
          set_has_deviceid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // required int32 id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // required int32 type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_status;
        break;
      }

      // required int32 status = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &status_)));
          set_has_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_capacity;
        break;
      }

      // optional int32 capacity = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_capacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &capacity_)));
          set_has_capacity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SensorStatusNotification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 deviceid = 1;
  if (has_deviceid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->deviceid(), output);
  }

  // required int32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->id(), output);
  }

  // required int32 type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->type(), output);
  }

  // required int32 status = 4;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->status(), output);
  }

  // optional int32 capacity = 5;
  if (has_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->capacity(), output);
  }

}

int SensorStatusNotification::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 deviceid = 1;
    if (has_deviceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->deviceid());
    }

    // required int32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // required int32 type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // required int32 status = 4;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->status());
    }

    // optional int32 capacity = 5;
    if (has_capacity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->capacity());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SensorStatusNotification::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SensorStatusNotification*>(&from));
}

void SensorStatusNotification::MergeFrom(const SensorStatusNotification& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_deviceid()) {
      set_deviceid(from.deviceid());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_capacity()) {
      set_capacity(from.capacity());
    }
  }
}

void SensorStatusNotification::CopyFrom(const SensorStatusNotification& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorStatusNotification::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;

  return true;
}

void SensorStatusNotification::Swap(SensorStatusNotification* other) {
  if (other != this) {
    std::swap(deviceid_, other->deviceid_);
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(status_, other->status_);
    std::swap(capacity_, other->capacity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SensorStatusNotification::GetTypeName() const {
  return "cl_message.SensorStatusNotification";
}


// ===================================================================

#ifndef _MSC_VER
const int Consumption::kTariffidFieldNumber;
const int Consumption::kTariffQtyFieldNumber;
#endif  // !_MSC_VER

Consumption::Consumption()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Consumption::InitAsDefaultInstance() {
}

Consumption::Consumption(const Consumption& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Consumption::SharedCtor() {
  _cached_size_ = 0;
  tariffid_ = 0;
  tariff_qty_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Consumption::~Consumption() {
  SharedDtor();
}

void Consumption::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Consumption::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Consumption& Consumption::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

Consumption* Consumption::default_instance_ = NULL;

Consumption* Consumption::New() const {
  return new Consumption;
}

void Consumption::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tariffid_ = 0;
    tariff_qty_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Consumption::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 tariffid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tariffid_)));
          set_has_tariffid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_tariff_qty;
        break;
      }

      // required int32 tariff_qty = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tariff_qty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tariff_qty_)));
          set_has_tariff_qty();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Consumption::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 tariffid = 1;
  if (has_tariffid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->tariffid(), output);
  }

  // required int32 tariff_qty = 2;
  if (has_tariff_qty()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->tariff_qty(), output);
  }

}

int Consumption::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 tariffid = 1;
    if (has_tariffid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tariffid());
    }

    // required int32 tariff_qty = 2;
    if (has_tariff_qty()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tariff_qty());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Consumption::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Consumption*>(&from));
}

void Consumption::MergeFrom(const Consumption& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tariffid()) {
      set_tariffid(from.tariffid());
    }
    if (from.has_tariff_qty()) {
      set_tariff_qty(from.tariff_qty());
    }
  }
}

void Consumption::CopyFrom(const Consumption& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Consumption::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Consumption::Swap(Consumption* other) {
  if (other != this) {
    std::swap(tariffid_, other->tariffid_);
    std::swap(tariff_qty_, other->tariff_qty_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Consumption::GetTypeName() const {
  return "cl_message.Consumption";
}


// ===================================================================

#ifndef _MSC_VER
const int GetCost_Request::kPriceSchemeIdFieldNumber;
const int GetCost_Request::kLocalConsumptionFieldNumber;
#endif  // !_MSC_VER

GetCost_Request::GetCost_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetCost_Request::InitAsDefaultInstance() {
}

GetCost_Request::GetCost_Request(const GetCost_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetCost_Request::SharedCtor() {
  _cached_size_ = 0;
  price_scheme_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetCost_Request::~GetCost_Request() {
  SharedDtor();
}

void GetCost_Request::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetCost_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetCost_Request& GetCost_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

GetCost_Request* GetCost_Request::default_instance_ = NULL;

GetCost_Request* GetCost_Request::New() const {
  return new GetCost_Request;
}

void GetCost_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    price_scheme_id_ = 0;
  }
  local_consumption_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetCost_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 price_scheme_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &price_scheme_id_)));
          set_has_price_scheme_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_local_consumption;
        break;
      }

      // repeated .cl_message.Consumption local_consumption = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_local_consumption:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_local_consumption()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_local_consumption;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetCost_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 price_scheme_id = 1;
  if (has_price_scheme_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->price_scheme_id(), output);
  }

  // repeated .cl_message.Consumption local_consumption = 2;
  for (int i = 0; i < this->local_consumption_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->local_consumption(i), output);
  }

}

int GetCost_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 price_scheme_id = 1;
    if (has_price_scheme_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->price_scheme_id());
    }

  }
  // repeated .cl_message.Consumption local_consumption = 2;
  total_size += 1 * this->local_consumption_size();
  for (int i = 0; i < this->local_consumption_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->local_consumption(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetCost_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetCost_Request*>(&from));
}

void GetCost_Request::MergeFrom(const GetCost_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  local_consumption_.MergeFrom(from.local_consumption_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_price_scheme_id()) {
      set_price_scheme_id(from.price_scheme_id());
    }
  }
}

void GetCost_Request::CopyFrom(const GetCost_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetCost_Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < local_consumption_size(); i++) {
    if (!this->local_consumption(i).IsInitialized()) return false;
  }
  return true;
}

void GetCost_Request::Swap(GetCost_Request* other) {
  if (other != this) {
    std::swap(price_scheme_id_, other->price_scheme_id_);
    local_consumption_.Swap(&other->local_consumption_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetCost_Request::GetTypeName() const {
  return "cl_message.GetCost.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int GetCost_Confirm::kPriceSchemeIdFieldNumber;
const int GetCost_Confirm::kTotalCostFieldNumber;
const int GetCost_Confirm::kConsumFieldNumber;
#endif  // !_MSC_VER

GetCost_Confirm::GetCost_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetCost_Confirm::InitAsDefaultInstance() {
}

GetCost_Confirm::GetCost_Confirm(const GetCost_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetCost_Confirm::SharedCtor() {
  _cached_size_ = 0;
  price_scheme_id_ = 0;
  total_cost_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetCost_Confirm::~GetCost_Confirm() {
  SharedDtor();
}

void GetCost_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetCost_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetCost_Confirm& GetCost_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

GetCost_Confirm* GetCost_Confirm::default_instance_ = NULL;

GetCost_Confirm* GetCost_Confirm::New() const {
  return new GetCost_Confirm;
}

void GetCost_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    price_scheme_id_ = 0;
    total_cost_ = 0;
  }
  consum_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetCost_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 price_scheme_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &price_scheme_id_)));
          set_has_price_scheme_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_total_cost;
        break;
      }

      // required int32 total_cost = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_total_cost:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_cost_)));
          set_has_total_cost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_consum;
        break;
      }

      // repeated .cl_message.Consumption consum = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_consum:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_consum()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_consum;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetCost_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 price_scheme_id = 1;
  if (has_price_scheme_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->price_scheme_id(), output);
  }

  // required int32 total_cost = 2;
  if (has_total_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->total_cost(), output);
  }

  // repeated .cl_message.Consumption consum = 3;
  for (int i = 0; i < this->consum_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->consum(i), output);
  }

}

int GetCost_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 price_scheme_id = 1;
    if (has_price_scheme_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->price_scheme_id());
    }

    // required int32 total_cost = 2;
    if (has_total_cost()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->total_cost());
    }

  }
  // repeated .cl_message.Consumption consum = 3;
  total_size += 1 * this->consum_size();
  for (int i = 0; i < this->consum_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->consum(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetCost_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetCost_Confirm*>(&from));
}

void GetCost_Confirm::MergeFrom(const GetCost_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  consum_.MergeFrom(from.consum_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_price_scheme_id()) {
      set_price_scheme_id(from.price_scheme_id());
    }
    if (from.has_total_cost()) {
      set_total_cost(from.total_cost());
    }
  }
}

void GetCost_Confirm::CopyFrom(const GetCost_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetCost_Confirm::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  for (int i = 0; i < consum_size(); i++) {
    if (!this->consum(i).IsInitialized()) return false;
  }
  return true;
}

void GetCost_Confirm::Swap(GetCost_Confirm* other) {
  if (other != this) {
    std::swap(price_scheme_id_, other->price_scheme_id_);
    std::swap(total_cost_, other->total_cost_);
    consum_.Swap(&other->consum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetCost_Confirm::GetTypeName() const {
  return "cl_message.GetCost.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int GetCost::kReqFieldNumber;
const int GetCost::kConfFieldNumber;
#endif  // !_MSC_VER

GetCost::GetCost()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GetCost::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::GetCost_Request*>(
      ::cl_message::GetCost_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::GetCost_Request*>(&::cl_message::GetCost_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::GetCost_Confirm*>(
      ::cl_message::GetCost_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::GetCost_Confirm*>(&::cl_message::GetCost_Confirm::default_instance());
#endif
}

GetCost::GetCost(const GetCost& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GetCost::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetCost::~GetCost() {
  SharedDtor();
}

void GetCost::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void GetCost::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetCost& GetCost::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

GetCost* GetCost::default_instance_ = NULL;

GetCost* GetCost::New() const {
  return new GetCost;
}

void GetCost::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::GetCost_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::GetCost_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GetCost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.GetCost.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.GetCost.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetCost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.GetCost.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.GetCost.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int GetCost::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.GetCost.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.GetCost.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetCost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetCost*>(&from));
}

void GetCost::MergeFrom(const GetCost& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::GetCost_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::GetCost_Confirm::MergeFrom(from.conf());
    }
  }
}

void GetCost::CopyFrom(const GetCost& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetCost::IsInitialized() const {

  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  if (has_conf()) {
    if (!this->conf().IsInitialized()) return false;
  }
  return true;
}

void GetCost::Swap(GetCost* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetCost::GetTypeName() const {
  return "cl_message.GetCost";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginGW_Request::kDeviceidFieldNumber;
#endif  // !_MSC_VER

LoginGW_Request::LoginGW_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginGW_Request::InitAsDefaultInstance() {
}

LoginGW_Request::LoginGW_Request(const LoginGW_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginGW_Request::SharedCtor() {
  _cached_size_ = 0;
  deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginGW_Request::~LoginGW_Request() {
  SharedDtor();
}

void LoginGW_Request::SharedDtor() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginGW_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginGW_Request& LoginGW_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

LoginGW_Request* LoginGW_Request::default_instance_ = NULL;

LoginGW_Request* LoginGW_Request::New() const {
  return new LoginGW_Request;
}

void LoginGW_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_deviceid()) {
      if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
        deviceid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginGW_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string deviceid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_deviceid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginGW_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string deviceid = 1;
  if (has_deviceid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->deviceid(), output);
  }

}

int LoginGW_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string deviceid = 1;
    if (has_deviceid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->deviceid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginGW_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginGW_Request*>(&from));
}

void LoginGW_Request::MergeFrom(const LoginGW_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_deviceid()) {
      set_deviceid(from.deviceid());
    }
  }
}

void LoginGW_Request::CopyFrom(const LoginGW_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginGW_Request::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void LoginGW_Request::Swap(LoginGW_Request* other) {
  if (other != this) {
    std::swap(deviceid_, other->deviceid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginGW_Request::GetTypeName() const {
  return "cl_message.LoginGW.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int LoginGW_Confirm::kAcceptFieldNumber;
const int LoginGW_Confirm::kEvseIdFieldNumber;
const int LoginGW_Confirm::kCpidFieldNumber;
const int LoginGW_Confirm::kVersionFieldNumber;
const int LoginGW_Confirm::kIsonlineFieldNumber;
const int LoginGW_Confirm::kTimestampFieldNumber;
#endif  // !_MSC_VER

LoginGW_Confirm::LoginGW_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginGW_Confirm::InitAsDefaultInstance() {
}

LoginGW_Confirm::LoginGW_Confirm(const LoginGW_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginGW_Confirm::SharedCtor() {
  _cached_size_ = 0;
  accept_ = false;
  evse_id_ = 0;
  cpid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  isonline_ = false;
  timestamp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginGW_Confirm::~LoginGW_Confirm() {
  SharedDtor();
}

void LoginGW_Confirm::SharedDtor() {
  if (cpid_ != &::google::protobuf::internal::kEmptyString) {
    delete cpid_;
  }
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginGW_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginGW_Confirm& LoginGW_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

LoginGW_Confirm* LoginGW_Confirm::default_instance_ = NULL;

LoginGW_Confirm* LoginGW_Confirm::New() const {
  return new LoginGW_Confirm;
}

void LoginGW_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    accept_ = false;
    evse_id_ = 0;
    if (has_cpid()) {
      if (cpid_ != &::google::protobuf::internal::kEmptyString) {
        cpid_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    isonline_ = false;
    timestamp_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginGW_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool accept = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &accept_)));
          set_has_accept();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_evse_id;
        break;
      }

      // optional int32 evse_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_evse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &evse_id_)));
          set_has_evse_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_cpid;
        break;
      }

      // optional string cpid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cpid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cpid()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_version;
        break;
      }

      // optional string version = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_isonline;
        break;
      }

      // optional bool isonline = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isonline:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isonline_)));
          set_has_isonline();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_timestamp;
        break;
      }

      // optional int32 timestamp = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginGW_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool accept = 1;
  if (has_accept()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->accept(), output);
  }

  // optional int32 evse_id = 2;
  if (has_evse_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->evse_id(), output);
  }

  // optional string cpid = 3;
  if (has_cpid()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->cpid(), output);
  }

  // optional string version = 4;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->version(), output);
  }

  // optional bool isonline = 5;
  if (has_isonline()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->isonline(), output);
  }

  // optional int32 timestamp = 6;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->timestamp(), output);
  }

}

int LoginGW_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool accept = 1;
    if (has_accept()) {
      total_size += 1 + 1;
    }

    // optional int32 evse_id = 2;
    if (has_evse_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->evse_id());
    }

    // optional string cpid = 3;
    if (has_cpid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cpid());
    }

    // optional string version = 4;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional bool isonline = 5;
    if (has_isonline()) {
      total_size += 1 + 1;
    }

    // optional int32 timestamp = 6;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->timestamp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginGW_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginGW_Confirm*>(&from));
}

void LoginGW_Confirm::MergeFrom(const LoginGW_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_accept()) {
      set_accept(from.accept());
    }
    if (from.has_evse_id()) {
      set_evse_id(from.evse_id());
    }
    if (from.has_cpid()) {
      set_cpid(from.cpid());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_isonline()) {
      set_isonline(from.isonline());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
}

void LoginGW_Confirm::CopyFrom(const LoginGW_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginGW_Confirm::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void LoginGW_Confirm::Swap(LoginGW_Confirm* other) {
  if (other != this) {
    std::swap(accept_, other->accept_);
    std::swap(evse_id_, other->evse_id_);
    std::swap(cpid_, other->cpid_);
    std::swap(version_, other->version_);
    std::swap(isonline_, other->isonline_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginGW_Confirm::GetTypeName() const {
  return "cl_message.LoginGW.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int LoginGW::kReqFieldNumber;
const int LoginGW::kConfFieldNumber;
#endif  // !_MSC_VER

LoginGW::LoginGW()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginGW::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::LoginGW_Request*>(
      ::cl_message::LoginGW_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::LoginGW_Request*>(&::cl_message::LoginGW_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::LoginGW_Confirm*>(
      ::cl_message::LoginGW_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::LoginGW_Confirm*>(&::cl_message::LoginGW_Confirm::default_instance());
#endif
}

LoginGW::LoginGW(const LoginGW& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginGW::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginGW::~LoginGW() {
  SharedDtor();
}

void LoginGW::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void LoginGW::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginGW& LoginGW::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

LoginGW* LoginGW::default_instance_ = NULL;

LoginGW* LoginGW::New() const {
  return new LoginGW;
}

void LoginGW::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::LoginGW_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::LoginGW_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginGW::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.LoginGW.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.LoginGW.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginGW::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.LoginGW.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.LoginGW.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int LoginGW::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.LoginGW.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.LoginGW.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginGW::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginGW*>(&from));
}

void LoginGW::MergeFrom(const LoginGW& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::LoginGW_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::LoginGW_Confirm::MergeFrom(from.conf());
    }
  }
}

void LoginGW::CopyFrom(const LoginGW& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginGW::IsInitialized() const {

  if (has_req()) {
    if (!this->req().IsInitialized()) return false;
  }
  if (has_conf()) {
    if (!this->conf().IsInitialized()) return false;
  }
  return true;
}

void LoginGW::Swap(LoginGW* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginGW::GetTypeName() const {
  return "cl_message.LoginGW";
}


// ===================================================================

#ifndef _MSC_VER
const int HeartbeatGW_Request::kTimestampFieldNumber;
#endif  // !_MSC_VER

HeartbeatGW_Request::HeartbeatGW_Request()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void HeartbeatGW_Request::InitAsDefaultInstance() {
}

HeartbeatGW_Request::HeartbeatGW_Request(const HeartbeatGW_Request& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void HeartbeatGW_Request::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeartbeatGW_Request::~HeartbeatGW_Request() {
  SharedDtor();
}

void HeartbeatGW_Request::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void HeartbeatGW_Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HeartbeatGW_Request& HeartbeatGW_Request::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

HeartbeatGW_Request* HeartbeatGW_Request::default_instance_ = NULL;

HeartbeatGW_Request* HeartbeatGW_Request::New() const {
  return new HeartbeatGW_Request;
}

void HeartbeatGW_Request::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    timestamp_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HeartbeatGW_Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 timestamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HeartbeatGW_Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->timestamp(), output);
  }

}

int HeartbeatGW_Request::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->timestamp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartbeatGW_Request::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HeartbeatGW_Request*>(&from));
}

void HeartbeatGW_Request::MergeFrom(const HeartbeatGW_Request& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
}

void HeartbeatGW_Request::CopyFrom(const HeartbeatGW_Request& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatGW_Request::IsInitialized() const {

  return true;
}

void HeartbeatGW_Request::Swap(HeartbeatGW_Request* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string HeartbeatGW_Request::GetTypeName() const {
  return "cl_message.HeartbeatGW.Request";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int HeartbeatGW_Confirm::kRssiFieldNumber;
#endif  // !_MSC_VER

HeartbeatGW_Confirm::HeartbeatGW_Confirm()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void HeartbeatGW_Confirm::InitAsDefaultInstance() {
}

HeartbeatGW_Confirm::HeartbeatGW_Confirm(const HeartbeatGW_Confirm& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void HeartbeatGW_Confirm::SharedCtor() {
  _cached_size_ = 0;
  rssi_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeartbeatGW_Confirm::~HeartbeatGW_Confirm() {
  SharedDtor();
}

void HeartbeatGW_Confirm::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void HeartbeatGW_Confirm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HeartbeatGW_Confirm& HeartbeatGW_Confirm::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

HeartbeatGW_Confirm* HeartbeatGW_Confirm::default_instance_ = NULL;

HeartbeatGW_Confirm* HeartbeatGW_Confirm::New() const {
  return new HeartbeatGW_Confirm;
}

void HeartbeatGW_Confirm::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    rssi_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HeartbeatGW_Confirm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 rssi = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rssi_)));
          set_has_rssi();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HeartbeatGW_Confirm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 rssi = 1;
  if (has_rssi()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->rssi(), output);
  }

}

int HeartbeatGW_Confirm::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 rssi = 1;
    if (has_rssi()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rssi());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartbeatGW_Confirm::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HeartbeatGW_Confirm*>(&from));
}

void HeartbeatGW_Confirm::MergeFrom(const HeartbeatGW_Confirm& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rssi()) {
      set_rssi(from.rssi());
    }
  }
}

void HeartbeatGW_Confirm::CopyFrom(const HeartbeatGW_Confirm& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatGW_Confirm::IsInitialized() const {

  return true;
}

void HeartbeatGW_Confirm::Swap(HeartbeatGW_Confirm* other) {
  if (other != this) {
    std::swap(rssi_, other->rssi_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string HeartbeatGW_Confirm::GetTypeName() const {
  return "cl_message.HeartbeatGW.Confirm";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int HeartbeatGW::kReqFieldNumber;
const int HeartbeatGW::kConfFieldNumber;
#endif  // !_MSC_VER

HeartbeatGW::HeartbeatGW()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void HeartbeatGW::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  req_ = const_cast< ::cl_message::HeartbeatGW_Request*>(
      ::cl_message::HeartbeatGW_Request::internal_default_instance());
#else
  req_ = const_cast< ::cl_message::HeartbeatGW_Request*>(&::cl_message::HeartbeatGW_Request::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  conf_ = const_cast< ::cl_message::HeartbeatGW_Confirm*>(
      ::cl_message::HeartbeatGW_Confirm::internal_default_instance());
#else
  conf_ = const_cast< ::cl_message::HeartbeatGW_Confirm*>(&::cl_message::HeartbeatGW_Confirm::default_instance());
#endif
}

HeartbeatGW::HeartbeatGW(const HeartbeatGW& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void HeartbeatGW::SharedCtor() {
  _cached_size_ = 0;
  req_ = NULL;
  conf_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeartbeatGW::~HeartbeatGW() {
  SharedDtor();
}

void HeartbeatGW::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete req_;
    delete conf_;
  }
}

void HeartbeatGW::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HeartbeatGW& HeartbeatGW::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

HeartbeatGW* HeartbeatGW::default_instance_ = NULL;

HeartbeatGW* HeartbeatGW::New() const {
  return new HeartbeatGW;
}

void HeartbeatGW::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_req()) {
      if (req_ != NULL) req_->::cl_message::HeartbeatGW_Request::Clear();
    }
    if (has_conf()) {
      if (conf_ != NULL) conf_->::cl_message::HeartbeatGW_Confirm::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool HeartbeatGW::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cl_message.HeartbeatGW.Request req = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_req()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_conf;
        break;
      }

      // optional .cl_message.HeartbeatGW.Confirm conf = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_conf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_conf()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HeartbeatGW::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .cl_message.HeartbeatGW.Request req = 1;
  if (has_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->req(), output);
  }

  // optional .cl_message.HeartbeatGW.Confirm conf = 2;
  if (has_conf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->conf(), output);
  }

}

int HeartbeatGW::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .cl_message.HeartbeatGW.Request req = 1;
    if (has_req()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->req());
    }

    // optional .cl_message.HeartbeatGW.Confirm conf = 2;
    if (has_conf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->conf());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartbeatGW::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HeartbeatGW*>(&from));
}

void HeartbeatGW::MergeFrom(const HeartbeatGW& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_req()) {
      mutable_req()->::cl_message::HeartbeatGW_Request::MergeFrom(from.req());
    }
    if (from.has_conf()) {
      mutable_conf()->::cl_message::HeartbeatGW_Confirm::MergeFrom(from.conf());
    }
  }
}

void HeartbeatGW::CopyFrom(const HeartbeatGW& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatGW::IsInitialized() const {

  return true;
}

void HeartbeatGW::Swap(HeartbeatGW* other) {
  if (other != this) {
    std::swap(req_, other->req_);
    std::swap(conf_, other->conf_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string HeartbeatGW::GetTypeName() const {
  return "cl_message.HeartbeatGW";
}


// ===================================================================

#ifndef _MSC_VER
const int NetstatGW::kIsonlineFieldNumber;
const int NetstatGW::kTimestampFieldNumber;
#endif  // !_MSC_VER

NetstatGW::NetstatGW()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NetstatGW::InitAsDefaultInstance() {
}

NetstatGW::NetstatGW(const NetstatGW& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NetstatGW::SharedCtor() {
  _cached_size_ = 0;
  isonline_ = false;
  timestamp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NetstatGW::~NetstatGW() {
  SharedDtor();
}

void NetstatGW::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NetstatGW::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NetstatGW& NetstatGW::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cl_5fmessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cl_5fmessage_2eproto();
#endif
  return *default_instance_;
}

NetstatGW* NetstatGW::default_instance_ = NULL;

NetstatGW* NetstatGW::New() const {
  return new NetstatGW;
}

void NetstatGW::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    isonline_ = false;
    timestamp_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NetstatGW::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool isonline = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isonline_)));
          set_has_isonline();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_timestamp;
        break;
      }

      // optional int32 timestamp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NetstatGW::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool isonline = 1;
  if (has_isonline()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->isonline(), output);
  }

  // optional int32 timestamp = 2;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->timestamp(), output);
  }

}

int NetstatGW::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool isonline = 1;
    if (has_isonline()) {
      total_size += 1 + 1;
    }

    // optional int32 timestamp = 2;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->timestamp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NetstatGW::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NetstatGW*>(&from));
}

void NetstatGW::MergeFrom(const NetstatGW& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_isonline()) {
      set_isonline(from.isonline());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
}

void NetstatGW::CopyFrom(const NetstatGW& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetstatGW::IsInitialized() const {

  return true;
}

void NetstatGW::Swap(NetstatGW* other) {
  if (other != this) {
    std::swap(isonline_, other->isonline_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NetstatGW::GetTypeName() const {
  return "cl_message.NetstatGW";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace cl_message

// @@protoc_insertion_point(global_scope)
